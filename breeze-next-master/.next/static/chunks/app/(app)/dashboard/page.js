/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/(app)/dashboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Ctinder%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Cusers%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Cstyles%5Cdashboard.css&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Ctinder%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Cusers%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Cstyles%5Cdashboard.css&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/tinder/page.js */ \"(app-pages-browser)/./src/app/tinder/page.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/users/page.js */ \"(app-pages-browser)/./src/app/users/page.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/styles/dashboard.css */ \"(app-pages-browser)/./src/styles/dashboard.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1EJTNBJTVDSW50ZXJuU2hpcCU1Q2JyZWV6ZS1uZXh0LW1hc3RlciU1Q2JyZWV6ZS1uZXh0LW1hc3RlciU1Q3NyYyU1Q2FwcCU1Q3RpbmRlciU1Q3BhZ2UuanMmbW9kdWxlcz1EJTNBJTVDSW50ZXJuU2hpcCU1Q2JyZWV6ZS1uZXh0LW1hc3RlciU1Q2JyZWV6ZS1uZXh0LW1hc3RlciU1Q3NyYyU1Q2FwcCU1Q3VzZXJzJTVDcGFnZS5qcyZtb2R1bGVzPUQlM0ElNUNJbnRlcm5TaGlwJTVDYnJlZXplLW5leHQtbWFzdGVyJTVDYnJlZXplLW5leHQtbWFzdGVyJTVDc3JjJTVDc3R5bGVzJTVDZGFzaGJvYXJkLmNzcyZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBLQUFzSDtBQUN0SCx3S0FBcUg7QUFDckgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8zZmI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcSW50ZXJuU2hpcFxcXFxicmVlemUtbmV4dC1tYXN0ZXJcXFxcYnJlZXplLW5leHQtbWFzdGVyXFxcXHNyY1xcXFxhcHBcXFxcdGluZGVyXFxcXHBhZ2UuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXEludGVyblNoaXBcXFxcYnJlZXplLW5leHQtbWFzdGVyXFxcXGJyZWV6ZS1uZXh0LW1hc3RlclxcXFxzcmNcXFxcYXBwXFxcXHVzZXJzXFxcXHBhZ2UuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXEludGVyblNoaXBcXFxcYnJlZXplLW5leHQtbWFzdGVyXFxcXGJyZWV6ZS1uZXh0LW1hc3RlclxcXFxzcmNcXFxcc3R5bGVzXFxcXGRhc2hib2FyZC5jc3NcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Ctinder%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Cusers%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Cstyles%5Cdashboard.css&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./lib/axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLGdIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanM/NTNlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"(app-pages-browser)/./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"(app-pages-browser)/./node_modules/axios/lib/core/createError.js\");\nmodule.exports = function xhrAdapter(config) {\n    return new Promise(function dispatchXhrRequest(resolve, reject) {\n        var requestData = config.data;\n        var requestHeaders = config.headers;\n        var responseType = config.responseType;\n        if (utils.isFormData(requestData)) {\n            delete requestHeaders[\"Content-Type\"]; // Let the browser set it\n        }\n        var request = new XMLHttpRequest();\n        // HTTP basic authentication\n        if (config.auth) {\n            var username = config.auth.username || \"\";\n            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : \"\";\n            requestHeaders.Authorization = \"Basic \" + btoa(username + \":\" + password);\n        }\n        var fullPath = buildFullPath(config.baseURL, config.url);\n        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n        // Set the request timeout in MS\n        request.timeout = config.timeout;\n        function onloadend() {\n            if (!request) {\n                return;\n            }\n            // Prepare the response\n            var responseHeaders = \"getAllResponseHeaders\" in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n            var responseData = !responseType || responseType === \"text\" || responseType === \"json\" ? request.responseText : request.response;\n            var response = {\n                data: responseData,\n                status: request.status,\n                statusText: request.statusText,\n                headers: responseHeaders,\n                config: config,\n                request: request\n            };\n            settle(resolve, reject, response);\n            // Clean up request\n            request = null;\n        }\n        if (\"onloadend\" in request) {\n            // Use onloadend if available\n            request.onloadend = onloadend;\n        } else {\n            // Listen for ready state to emulate onloadend\n            request.onreadystatechange = function handleLoad() {\n                if (!request || request.readyState !== 4) {\n                    return;\n                }\n                // The request errored out and we didn't get a response, this will be\n                // handled by onerror instead\n                // With one exception: request that using file: protocol, most browsers\n                // will return status as 0 even though it's a successful request\n                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf(\"file:\") === 0)) {\n                    return;\n                }\n                // readystate handler is calling before onerror or ontimeout handlers,\n                // so we should call onloadend on the next 'tick'\n                setTimeout(onloadend);\n            };\n        }\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        request.onabort = function handleAbort() {\n            if (!request) {\n                return;\n            }\n            reject(createError(\"Request aborted\", config, \"ECONNABORTED\", request));\n            // Clean up request\n            request = null;\n        };\n        // Handle low level network errors\n        request.onerror = function handleError() {\n            // Real errors are hidden from us by the browser\n            // onerror should only fire if it's a network error\n            reject(createError(\"Network Error\", config, null, request));\n            // Clean up request\n            request = null;\n        };\n        // Handle timeout\n        request.ontimeout = function handleTimeout() {\n            var timeoutErrorMessage = \"timeout of \" + config.timeout + \"ms exceeded\";\n            if (config.timeoutErrorMessage) {\n                timeoutErrorMessage = config.timeoutErrorMessage;\n            }\n            reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? \"ETIMEDOUT\" : \"ECONNABORTED\", request));\n            // Clean up request\n            request = null;\n        };\n        // Add xsrf header\n        // This is only done if running in a standard browser environment.\n        // Specifically not if we're in a web worker, or react-native.\n        if (utils.isStandardBrowserEnv()) {\n            // Add xsrf header\n            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n            if (xsrfValue) {\n                requestHeaders[config.xsrfHeaderName] = xsrfValue;\n            }\n        }\n        // Add headers to the request\n        if (\"setRequestHeader\" in request) {\n            utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n                if (typeof requestData === \"undefined\" && key.toLowerCase() === \"content-type\") {\n                    // Remove Content-Type if data is undefined\n                    delete requestHeaders[key];\n                } else {\n                    // Otherwise add header to the request\n                    request.setRequestHeader(key, val);\n                }\n            });\n        }\n        // Add withCredentials to request if needed\n        if (!utils.isUndefined(config.withCredentials)) {\n            request.withCredentials = !!config.withCredentials;\n        }\n        // Add responseType to request if needed\n        if (responseType && responseType !== \"json\") {\n            request.responseType = config.responseType;\n        }\n        // Handle progress if needed\n        if (typeof config.onDownloadProgress === \"function\") {\n            request.addEventListener(\"progress\", config.onDownloadProgress);\n        }\n        // Not all browsers support upload events\n        if (typeof config.onUploadProgress === \"function\" && request.upload) {\n            request.upload.addEventListener(\"progress\", config.onUploadProgress);\n        }\n        if (config.cancelToken) {\n            // Handle cancellation\n            config.cancelToken.promise.then(function onCanceled(cancel) {\n                if (!request) {\n                    return;\n                }\n                request.abort();\n                reject(cancel);\n                // Clean up request\n                request = null;\n            });\n        }\n        if (!requestData) {\n            requestData = null;\n        }\n        // Send the request\n        request.send(requestData);\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUksZ0JBQWdCSixtQkFBT0EsQ0FBQztBQUM1QixJQUFJSyxlQUFlTCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJTSxrQkFBa0JOLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlPLGNBQWNQLG1CQUFPQSxDQUFDO0FBRTFCUSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsV0FBV0MsTUFBTTtJQUN6QyxPQUFPLElBQUlDLFFBQVEsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUVDLE1BQU07UUFDNUQsSUFBSUMsY0FBY0wsT0FBT00sSUFBSTtRQUM3QixJQUFJQyxpQkFBaUJQLE9BQU9RLE9BQU87UUFDbkMsSUFBSUMsZUFBZVQsT0FBT1MsWUFBWTtRQUV0QyxJQUFJckIsTUFBTXNCLFVBQVUsQ0FBQ0wsY0FBYztZQUNqQyxPQUFPRSxjQUFjLENBQUMsZUFBZSxFQUFFLHlCQUF5QjtRQUNsRTtRQUVBLElBQUlJLFVBQVUsSUFBSUM7UUFFbEIsNEJBQTRCO1FBQzVCLElBQUlaLE9BQU9hLElBQUksRUFBRTtZQUNmLElBQUlDLFdBQVdkLE9BQU9hLElBQUksQ0FBQ0MsUUFBUSxJQUFJO1lBQ3ZDLElBQUlDLFdBQVdmLE9BQU9hLElBQUksQ0FBQ0UsUUFBUSxHQUFHQyxTQUFTQyxtQkFBbUJqQixPQUFPYSxJQUFJLENBQUNFLFFBQVEsS0FBSztZQUMzRlIsZUFBZVcsYUFBYSxHQUFHLFdBQVdDLEtBQUtMLFdBQVcsTUFBTUM7UUFDbEU7UUFFQSxJQUFJSyxXQUFXM0IsY0FBY08sT0FBT3FCLE9BQU8sRUFBRXJCLE9BQU9z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dEUsT0FBT3FFO2dCQUNQLG1CQUFtQjtnQkFDbkI5RCxVQUFVO1lBQ1o7UUFDRjtRQUVBLElBQUksQ0FBQ04sYUFBYTtZQUNoQkEsY0FBYztRQUNoQjtRQUVBLG1CQUFtQjtRQUNuQk0sUUFBUWdFLElBQUksQ0FBQ3RFO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz8xYTVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY29uZmlnLnRyYW5zaXRpb25hbCAmJiBjb25maWcudHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInNldHRsZSIsImNvb2tpZXMiLCJidWlsZFVSTCIsImJ1aWxkRnVsbFBhdGgiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJjcmVhdGVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ4aHJBZGFwdGVyIiwiY29uZmlnIiwiUHJvbWlzZSIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0RGF0YSIsImRhdGEiLCJyZXF1ZXN0SGVhZGVycyIsImhlYWRlcnMiLCJyZXNwb25zZVR5cGUiLCJpc0Zvcm1EYXRhIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkF1dGhvcml6YXRpb24iLCJidG9hIiwiZnVsbFBhdGgiLCJiYXNlVVJMIiwidXJsIiwib3BlbiIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsInRpbWVvdXQiLCJvbmxvYWRlbmQiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwiaW5kZXhPZiIsInNldFRpbWVvdXQiLCJvbmFib3J0IiwiaGFuZGxlQWJvcnQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwidGltZW91dEVycm9yTWVzc2FnZSIsInRyYW5zaXRpb25hbCIsImNsYXJpZnlUaW1lb3V0RXJyb3IiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsInhzcmZWYWx1ZSIsIndpdGhDcmVkZW50aWFscyIsInhzcmZDb29raWVOYW1lIiwicmVhZCIsInVuZGVmaW5lZCIsInhzcmZIZWFkZXJOYW1lIiwiZm9yRWFjaCIsInNldFJlcXVlc3RIZWFkZXIiLCJ2YWwiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImlzVW5kZWZpbmVkIiwib25Eb3dubG9hZFByb2dyZXNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsInByb21pc2UiLCJ0aGVuIiwib25DYW5jZWxlZCIsImNhbmNlbCIsImFib3J0Iiwic2VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"(app-pages-browser)/./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"(app-pages-browser)/./node_modules/axios/lib/defaults.js\");\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */ function createInstance(defaultConfig) {\n    var context = new Axios(defaultConfig);\n    var instance = bind(Axios.prototype.request, context);\n    // Copy axios.prototype to instance\n    utils.extend(instance, Axios.prototype, context);\n    // Copy context to instance\n    utils.extend(instance, context);\n    return instance;\n}\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\");\n// Expose all/spread\naxios.all = function all(promises) {\n    return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js\");\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js\");\nmodule.exports = axios;\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQztBQUV2Qjs7Ozs7Q0FLQyxHQUNELFNBQVNLLGVBQWVDLGFBQWE7SUFDbkMsSUFBSUMsVUFBVSxJQUFJTCxNQUFNSTtJQUN4QixJQUFJRSxXQUFXUCxLQUFLQyxNQUFNTyxTQUFTLENBQUNDLE9BQU8sRUFBRUg7SUFFN0MsbUNBQW1DO0lBQ25DUixNQUFNWSxNQUFNLENBQUNILFVBQVVOLE1BQU1PLFNBQVMsRUFBRUY7SUFFeEMsMkJBQTJCO0lBQzNCUixNQUFNWSxNQUFNLENBQUNILFVBQVVEO0lBRXZCLE9BQU9DO0FBQ1Q7QUFFQSw2Q0FBNkM7QUFDN0MsSUFBSUksUUFBUVAsZUFBZUQ7QUFFM0IsZ0RBQWdEO0FBQ2hEUSxNQUFNVixLQUFLLEdBQUdBO0FBRWQscUNBQXFDO0FBQ3JDVSxNQUFNQyxNQUFNLEdBQUcsU0FBU0EsT0FBT0MsY0FBYztJQUMzQyxPQUFPVCxlQUFlRixZQUFZUyxNQUFNUixRQUFRLEVBQUVVO0FBQ3BEO0FBRUEsOEJBQThCO0FBQzlCRixNQUFNRyxNQUFNLEdBQUdmLG1CQUFPQSxDQUFDO0FBQ3ZCWSxNQUFNSSxXQUFXLEdBQUdoQixtQkFBT0EsQ0FBQztBQUM1QlksTUFBTUssUUFBUSxHQUFHakIsbUJBQU9BLENBQUM7QUFFekIsb0JBQW9CO0FBQ3BCWSxNQUFNTSxHQUFHLEdBQUcsU0FBU0EsSUFBSUMsUUFBUTtJQUMvQixPQUFPQyxRQUFRRixHQUFHLENBQUNDO0FBQ3JCO0FBQ0FQLE1BQU1TLE1BQU0sR0FBR3JCLG1CQUFPQSxDQUFDO0FBRXZCLHNCQUFzQjtBQUN0QlksTUFBTVUsWUFBWSxHQUFHdEIsbUJBQU9BLENBQUM7QUFFN0J1QixPQUFPQyxPQUFPLEdBQUdaO0FBRWpCLG1EQUFtRDtBQUNuRFcseUJBQXNCLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanM/ZmFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJiaW5kIiwiQXhpb3MiLCJtZXJnZUNvbmZpZyIsImRlZmF1bHRzIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiY29udGV4dCIsImluc3RhbmNlIiwicHJvdG90eXBlIiwicmVxdWVzdCIsImV4dGVuZCIsImF4aW9zIiwiY3JlYXRlIiwiaW5zdGFuY2VDb25maWciLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJQcm9taXNlIiwic3ByZWFkIiwiaXNBeGlvc0Vycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/axios.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */ function Cancel(message) {\n    this.message = message;\n}\n_c = Cancel;\nCancel.prototype.toString = function toString() {\n    return \"Cancel\" + (this.message ? \": \" + this.message : \"\");\n};\nCancel.prototype.__CANCEL__ = true;\nmodule.exports = Cancel;\nvar _c;\n$RefreshReg$(_c, \"Cancel\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0EsT0FBT0MsT0FBTztJQUNyQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7QUFDakI7S0FGU0Q7QUFJVEEsT0FBT0UsU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBU0E7SUFDbkMsT0FBTyxXQUFZLEtBQUksQ0FBQ0YsT0FBTyxHQUFHLE9BQU8sSUFBSSxDQUFDQSxPQUFPLEdBQUcsRUFBQztBQUMzRDtBQUVBRCxPQUFPRSxTQUFTLENBQUNFLFVBQVUsR0FBRztBQUU5QkMsT0FBT0MsT0FBTyxHQUFHTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanM/ZDJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiJdLCJuYW1lcyI6WyJDYW5jZWwiLCJtZXNzYWdlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJfX0NBTkNFTF9fIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/Cancel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/Cancel.js\");\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */ function CancelToken(executor) {\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"executor must be a function.\");\n    }\n    var resolvePromise;\n    this.promise = new Promise(function promiseExecutor(resolve) {\n        resolvePromise = resolve;\n    });\n    var token = this;\n    executor(function cancel(message) {\n        if (token.reason) {\n            // Cancellation has already been requested\n            return;\n        }\n        token.reason = new Cancel(message);\n        resolvePromise(token.reason);\n    });\n}\n_c = CancelToken;\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */ CancelToken.prototype.throwIfRequested = function throwIfRequested() {\n    if (this.reason) {\n        throw this.reason;\n    }\n};\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */ CancelToken.source = function source() {\n    var cancel;\n    var token = new CancelToken(function executor(c) {\n        cancel = c;\n    });\n    return {\n        token: token,\n        cancel: cancel\n    };\n};\nmodule.exports = CancelToken;\nvar _c;\n$RefreshReg$(_c, \"CancelToken\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFckI7Ozs7O0NBS0MsR0FDRCxTQUFTQyxZQUFZQyxRQUFRO0lBQzNCLElBQUksT0FBT0EsYUFBYSxZQUFZO1FBQ2xDLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBLElBQUlDO0lBQ0osSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBUSxTQUFTQyxnQkFBZ0JDLE9BQU87UUFDekRKLGlCQUFpQkk7SUFDbkI7SUFFQSxJQUFJQyxRQUFRLElBQUk7SUFDaEJQLFNBQVMsU0FBU1EsT0FBT0MsT0FBTztRQUM5QixJQUFJRixNQUFNRyxNQUFNLEVBQUU7WUFDaEIsMENBQTBDO1lBQzFDO1FBQ0Y7UUFFQUgsTUFBTUcsTUFBTSxHQUFHLElBQUliLE9BQU9ZO1FBQzFCUCxlQUFlSyxNQUFNRyxNQUFNO0lBQzdCO0FBQ0Y7S0FwQlNYO0FBc0JUOztDQUVDLEdBQ0RBLFlBQVlZLFNBQVMsQ0FBQ0MsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDaEQsSUFBSSxJQUFJLENBQUNGLE1BQU0sRUFBRTtRQUNmLE1BQU0sSUFBSSxDQUFDQSxNQUFNO0lBQ25CO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRFgsWUFBWWMsTUFBTSxHQUFHLFNBQVNBO0lBQzVCLElBQUlMO0lBQ0osSUFBSUQsUUFBUSxJQUFJUixZQUFZLFNBQVNDLFNBQVNjLENBQUM7UUFDN0NOLFNBQVNNO0lBQ1g7SUFDQSxPQUFPO1FBQ0xQLE9BQU9BO1FBQ1BDLFFBQVFBO0lBQ1Y7QUFDRjtBQUVBTyxPQUFPQyxPQUFPLEdBQUdqQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz83MmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iXSwibmFtZXMiOlsiQ2FuY2VsIiwicmVxdWlyZSIsIkNhbmNlbFRva2VuIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2UiLCJQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwicmVzb2x2ZSIsInRva2VuIiwiY2FuY2VsIiwibWVzc2FnZSIsInJlYXNvbiIsInByb3RvdHlwZSIsInRocm93SWZSZXF1ZXN0ZWQiLCJzb3VyY2UiLCJjIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = function isCancel(value) {\n    return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxTQUFTQyxLQUFLO0lBQ3RDLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxTQUFTQSxNQUFNQyxVQUFVO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzP2MxN2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImlzQ2FuY2VsIiwidmFsdWUiLCJfX0NBTkNFTF9fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js\");\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */ function Axios(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n        request: new InterceptorManager(),\n        response: new InterceptorManager()\n    };\n}\n_c = Axios;\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */ Axios.prototype.request = function request(config) {\n    /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof config === \"string\") {\n        config = arguments[1] || {};\n        config.url = arguments[0];\n    } else {\n        config = config || {};\n    }\n    config = mergeConfig(this.defaults, config);\n    // Set config.method\n    if (config.method) {\n        config.method = config.method.toLowerCase();\n    } else if (this.defaults.method) {\n        config.method = this.defaults.method.toLowerCase();\n    } else {\n        config.method = \"get\";\n    }\n    var transitional = config.transitional;\n    if (transitional !== undefined) {\n        validator.assertOptions(transitional, {\n            silentJSONParsing: validators.transitional(validators.boolean, \"1.0.0\"),\n            forcedJSONParsing: validators.transitional(validators.boolean, \"1.0.0\"),\n            clarifyTimeoutError: validators.transitional(validators.boolean, \"1.0.0\")\n        }, false);\n    }\n    // filter out skipped interceptors\n    var requestInterceptorChain = [];\n    var synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n        if (typeof interceptor.runWhen === \"function\" && interceptor.runWhen(config) === false) {\n            return;\n        }\n        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n    var responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n    var promise;\n    if (!synchronousRequestInterceptors) {\n        var chain = [\n            dispatchRequest,\n            undefined\n        ];\n        Array.prototype.unshift.apply(chain, requestInterceptorChain);\n        chain = chain.concat(responseInterceptorChain);\n        promise = Promise.resolve(config);\n        while(chain.length){\n            promise = promise.then(chain.shift(), chain.shift());\n        }\n        return promise;\n    }\n    var newConfig = config;\n    while(requestInterceptorChain.length){\n        var onFulfilled = requestInterceptorChain.shift();\n        var onRejected = requestInterceptorChain.shift();\n        try {\n            newConfig = onFulfilled(newConfig);\n        } catch (error) {\n            onRejected(error);\n            break;\n        }\n    }\n    try {\n        promise = dispatchRequest(newConfig);\n    } catch (error) {\n        return Promise.reject(error);\n    }\n    while(responseInterceptorChain.length){\n        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n    }\n    return promise;\n};\nAxios.prototype.getUri = function getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, \"\");\n};\n// Provide aliases for supported request methods\nutils.forEach([\n    \"delete\",\n    \"get\",\n    \"head\",\n    \"options\"\n], function forEachMethodNoData(method) {\n    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {\n        return this.request(mergeConfig(config || {}, {\n            method: method,\n            url: url,\n            data: (config || {}).data\n        }));\n    };\n});\nutils.forEach([\n    \"post\",\n    \"put\",\n    \"patch\"\n], function forEachMethodWithData(method) {\n    /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) {\n        return this.request(mergeConfig(config || {}, {\n            method: method,\n            url: url,\n            data: data\n        }));\n    };\n});\nmodule.exports = Axios;\nvar _c;\n$RefreshReg$(_c, \"Axios\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLHFCQUFxQkYsbUJBQU9BLENBQUM7QUFDakMsSUFBSUcsa0JBQWtCSCxtQkFBT0EsQ0FBQztBQUM5QixJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQztBQUMxQixJQUFJSyxZQUFZTCxtQkFBT0EsQ0FBQztBQUV4QixJQUFJTSxhQUFhRCxVQUFVQyxVQUFVO0FBQ3JDOzs7O0NBSUMsR0FDRCxTQUFTQyxNQUFNQyxjQUFjO0lBQzNCLElBQUksQ0FBQ0MsUUFBUSxHQUFHRDtJQUNoQixJQUFJLENBQUNFLFlBQVksR0FBRztRQUNsQkMsU0FBUyxJQUFJVDtRQUNiVSxVQUFVLElBQUlWO0lBQ2hCO0FBQ0Y7S0FOU0s7QUFRVDs7OztDQUlDLEdBQ0RBLE1BQU1NLFNBQVMsQ0FBQ0YsT0FBTyxHQUFHLFNBQVNBLFFBQVFHLE1BQU07SUFDL0MsNEJBQTRCLEdBQzVCLDBEQUEwRDtJQUMxRCxJQUFJLE9BQU9BLFdBQVcsVUFBVTtRQUM5QkEsU0FBU0MsU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDO1FBQzFCRCxPQUFPRSxHQUFHLEdBQUdELFNBQVMsQ0FBQyxFQUFFO0lBQzNCLE9BQU87UUFDTEQsU0FBU0EsVUFBVSxDQUFDO0lBQ3RCO0lBRUFBLFNBQVNWLFlBQVksSUFBSSxDQUFDSyxRQUFRLEVBQUVLO0lBRXBDLG9CQUFvQjtJQUNwQixJQUFJQSxPQUFPRyxNQUFNLEVBQUU7UUFDakJILE9BQU9HLE1BQU0sR0FBR0gsT0FBT0csTUFBTSxDQUFDQyxXQUFXO0lBQzNDLE9BQU8sSUFBSSxJQUFJLENBQUNULFFBQVEsQ0FBQ1EsTUFBTSxFQUFFO1FBQy9CSCxPQUFPRyxNQUFNLEdBQUcsSUFBSSxDQUFDUixRQUFRLENB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QUFPLElBQUksQ0FBQ0gsT0FBTyxDQUFDUCxZQUFZVSxVQUFVLENBQUMsR0FBRztZQUM1Q0csUUFBUUE7WUFDUkQsS0FBS0E7WUFDTDJDLE1BQU0sQ0FBQzdDLFVBQVUsQ0FBQyxHQUFHNkMsSUFBSTtRQUMzQjtJQUNGO0FBQ0Y7QUFFQTVELE1BQU02QixPQUFPLENBQUM7SUFBQztJQUFRO0lBQU87Q0FBUSxFQUFFLFNBQVNnQyxzQkFBc0IzQyxNQUFNO0lBQzNFLHFCQUFxQixHQUNyQlYsTUFBTU0sU0FBUyxDQUFDSSxPQUFPLEdBQUcsU0FBU0QsR0FBRyxFQUFFMkMsSUFBSSxFQUFFN0MsTUFBTTtRQUNsRCxPQUFPLElBQUksQ0FBQ0gsT0FBTyxDQUFDUCxZQUFZVSxVQUFVLENBQUMsR0FBRztZQUM1Q0csUUFBUUE7WUFDUkQsS0FBS0E7WUFDTDJDLE1BQU1BO1FBQ1I7SUFDRjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBR3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8yOWZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImJ1aWxkVVJMIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwibWVyZ2VDb25maWciLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0b3JzIiwiQXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsImRlZmF1bHRzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInJlc3BvbnNlIiwicHJvdG90eXBlIiwiY29uZmlnIiwiYXJndW1lbnRzIiwidXJsIiwibWV0aG9kIiwidG9Mb3dlckNhc2UiLCJ0cmFuc2l0aW9uYWwiLCJ1bmRlZmluZWQiLCJhc3NlcnRPcHRpb25zIiwic2lsZW50SlNPTlBhcnNpbmciLCJib29sZWFuIiwiZm9yY2VkSlNPTlBhcnNpbmciLCJjbGFyaWZ5VGltZW91dEVycm9yIiwicmVxdWVzdEludGVyY2VwdG9yQ2hhaW4iLCJzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMiLCJmb3JFYWNoIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInJ1bldoZW4iLCJzeW5jaHJvbm91cyIsInVuc2hpZnQiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsInB1c2giLCJwcm9taXNlIiwiY2hhaW4iLCJBcnJheSIsImFwcGx5IiwiY29uY2F0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsZW5ndGgiLCJ0aGVuIiwic2hpZnQiLCJuZXdDb25maWciLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJlcnJvciIsInJlamVjdCIsImdldFVyaSIsInBhcmFtcyIsInBhcmFtc1NlcmlhbGl6ZXIiLCJyZXBsYWNlIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImRhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/Axios.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nfunction InterceptorManager() {\n    this.handlers = [];\n}\n_c = InterceptorManager;\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */ InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n    this.handlers.push({\n        fulfilled: fulfilled,\n        rejected: rejected,\n        synchronous: options ? options.synchronous : false,\n        runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n};\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */ InterceptorManager.prototype.eject = function eject(id) {\n    if (this.handlers[id]) {\n        this.handlers[id] = null;\n    }\n};\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */ InterceptorManager.prototype.forEach = function forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n        if (h !== null) {\n            fn(h);\n        }\n    });\n};\nmodule.exports = InterceptorManager;\nvar _c;\n$RefreshReg$(_c, \"InterceptorManager\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQixTQUFTQztJQUNQLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7QUFDcEI7S0FGU0Q7QUFJVDs7Ozs7OztDQU9DLEdBQ0RBLG1CQUFtQkUsU0FBUyxDQUFDQyxHQUFHLEdBQUcsU0FBU0EsSUFBSUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDMUUsSUFBSSxDQUFDTCxRQUFRLENBQUNNLElBQUksQ0FBQztRQUNqQkgsV0FBV0E7UUFDWEMsVUFBVUE7UUFDVkcsYUFBYUYsVUFBVUEsUUFBUUUsV0FBVyxHQUFHO1FBQzdDQyxTQUFTSCxVQUFVQSxRQUFRRyxPQUFPLEdBQUc7SUFDdkM7SUFDQSxPQUFPLElBQUksQ0FBQ1IsUUFBUSxDQUFDUyxNQUFNLEdBQUc7QUFDaEM7QUFFQTs7OztDQUlDLEdBQ0RWLG1CQUFtQkUsU0FBUyxDQUFDUyxLQUFLLEdBQUcsU0FBU0EsTUFBTUMsRUFBRTtJQUNwRCxJQUFJLElBQUksQ0FBQ1gsUUFBUSxDQUFDVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDWCxRQUFRLENBQUNXLEdBQUcsR0FBRztJQUN0QjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEWixtQkFBbUJFLFNBQVMsQ0FBQ1csT0FBTyxHQUFHLFNBQVNBLFFBQVFDLEVBQUU7SUFDeERoQixNQUFNZSxPQUFPLENBQUMsSUFBSSxDQUFDWixRQUFRLEVBQUUsU0FBU2MsZUFBZUMsQ0FBQztRQUNwRCxJQUFJQSxNQUFNLE1BQU07WUFDZEYsR0FBR0U7UUFDTDtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcz9jNzkyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiaGFuZGxlcnMiLCJwcm90b3R5cGUiLCJ1c2UiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsIm9wdGlvbnMiLCJwdXNoIiwic3luY2hyb25vdXMiLCJydW5XaGVuIiwibGVuZ3RoIiwiZWplY3QiLCJpZCIsImZvckVhY2giLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js\");\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */ module.exports = function buildFullPath(baseURL, requestedURL) {\n    if (baseURL && !isAbsoluteURL(requestedURL)) {\n        return combineURLs(baseURL, requestedURL);\n    }\n    return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsZ0JBQWdCQyxtQkFBT0EsQ0FBQztBQUM1QixJQUFJQyxjQUFjRCxtQkFBT0EsQ0FBQztBQUUxQjs7Ozs7Ozs7Q0FRQyxHQUNERSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsY0FBY0MsT0FBTyxFQUFFQyxZQUFZO0lBQzNELElBQUlELFdBQVcsQ0FBQ04sY0FBY08sZUFBZTtRQUMzQyxPQUFPTCxZQUFZSSxTQUFTQztJQUM5QjtJQUNBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanM/ZjAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIl0sIm5hbWVzIjpbImlzQWJzb2x1dGVVUkwiLCJyZXF1aXJlIiwiY29tYmluZVVSTHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiYnVpbGRGdWxsUGF0aCIsImJhc2VVUkwiLCJyZXF1ZXN0ZWRVUkwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"(app-pages-browser)/./node_modules/axios/lib/core/enhanceError.js\");\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */ module.exports = function createError(message, config, code, request, response) {\n    var error = new Error(message);\n    return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDO0FBRTNCOzs7Ozs7Ozs7Q0FTQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQzVFLElBQUlDLFFBQVEsSUFBSUMsTUFBTU47SUFDdEIsT0FBT0wsYUFBYVUsT0FBT0osUUFBUUMsTUFBTUMsU0FBU0M7QUFDcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzPzc3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiJdLCJuYW1lcyI6WyJlbmhhbmNlRXJyb3IiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZUVycm9yIiwibWVzc2FnZSIsImNvbmZpZyIsImNvZGUiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJlcnJvciIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/createError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"(app-pages-browser)/./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"(app-pages-browser)/./node_modules/axios/lib/defaults.js\");\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */ function throwIfCancellationRequested(config) {\n    if (config.cancelToken) {\n        config.cancelToken.throwIfRequested();\n    }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */ module.exports = function dispatchRequest(config) {\n    throwIfCancellationRequested(config);\n    // Ensure headers exist\n    config.headers = config.headers || {};\n    // Transform request data\n    config.data = transformData.call(config, config.data, config.headers, config.transformRequest);\n    // Flatten headers\n    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);\n    utils.forEach([\n        \"delete\",\n        \"get\",\n        \"head\",\n        \"post\",\n        \"put\",\n        \"patch\",\n        \"common\"\n    ], function cleanHeaderConfig(method) {\n        delete config.headers[method];\n    });\n    var adapter = config.adapter || defaults.adapter;\n    return adapter(config).then(function onAdapterResolution(response) {\n        throwIfCancellationRequested(config);\n        // Transform response data\n        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);\n        return response;\n    }, function onAdapterRejection(reason) {\n        if (!isCancel(reason)) {\n            throwIfCancellationRequested(config);\n            // Transform response data\n            if (reason && reason.response) {\n                reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);\n            }\n        }\n        return Promise.reject(reason);\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzVCLElBQUlFLFdBQVdGLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlHLFdBQVdILG1CQUFPQSxDQUFDO0FBRXZCOztDQUVDLEdBQ0QsU0FBU0ksNkJBQTZCQyxNQUFNO0lBQzFDLElBQUlBLE9BQU9DLFdBQVcsRUFBRTtRQUN0QkQsT0FBT0MsV0FBVyxDQUFDQyxnQkFBZ0I7SUFDckM7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0RDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxnQkFBZ0JMLE1BQU07SUFDOUNELDZCQUE2QkM7SUFFN0IsdUJBQXVCO0lBQ3ZCQSxPQUFPTSxPQUFPLEdBQUdOLE9BQU9NLE9BQU8sSUFBSSxDQUFDO0lBRXBDLHlCQUF5QjtJQUN6Qk4sT0FBT08sSUFBSSxHQUFHWCxjQUFjWSxJQUFJLENBQzlCUixRQUNBQSxPQUFPTyxJQUFJLEVBQ1hQLE9BQU9NLE9BQU8sRUFDZE4sT0FBT1MsZ0JBQWdCO0lBR3pCLGtCQUFrQjtJQUNsQlQsT0FBT00sT0FBTyxHQUFHWixNQUFNZ0IsS0FBSyxDQUMxQlYsT0FBT00sT0FBTyxDQUFDSyxNQUFNLElBQUksQ0FBQyxHQUMxQlgsT0FBT00sT0FBTyxDQUFDTixPQUFPWSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQ2xDWixPQUFPTSxPQUFPO0lBR2hCWixNQUFNbUIsT0FBTyxDQUNYO1FBQUM7UUFBVTtRQUFPO1FBQVE7UUFBUTtRQUFPO1FBQVM7S0FBUyxFQUMzRCxTQUFTQyxrQkFBa0JGLE1BQU07UUFDL0IsT0FBT1osT0FBT00sT0FBTyxDQUFDTSxPQUFPO0lBQy9CO0lBR0YsSUFBSUcsVUFBVWYsT0FBT2UsT0FBTyxJQUFJakIsU0FBU2lCLE9BQU87SUFFaEQsT0FBT0EsUUFBUWYsUUFBUWdCLElBQUksQ0FBQyxTQUFTQyxvQkFBb0JDLFFBQVE7UUFDL0RuQiw2QkFBNkJDO1FBRTdCLDBCQUEwQjtRQUMxQmtCLFNBQVNYLElBQUksR0FBR1gsY0FBY1ksSUFBSSxDQUNoQ1IsUUFDQWtCLFNBQVNYLElBQUksRUFDYlcsU0FBU1osT0FBTyxFQUNoQk4sT0FBT21CLGlCQUFpQjtRQUcxQixPQUFPRDtJQUNULEdBQUcsU0FBU0UsbUJBQW1CQyxNQUFNO1FBQ25DLElBQUksQ0FBQ3hCLFNBQVN3QixTQUFTO1lBQ3JCdEIsNkJBQTZCQztZQUU3QiwwQkFBMEI7WUFDMUIsSUFBSXFCLFVBQVVBLE9BQU9ILFFBQVEsRUFBRTtnQkFDN0JHLE9BQU9ILFFBQVEsQ0FBQ1gsSUFBSSxHQUFHWCxjQUFjWSxJQUFJLENBQ3ZDUixRQUNBcUIsT0FBT0gsUUFBUSxDQUFDWCxJQUFJLEVBQ3BCYyxPQUFPSCxRQUFRLENBQUNaLE9BQU8sRUFDdkJOLE9BQU9tQixpQkFBaUI7WUFFNUI7UUFDRjtRQUVBLE9BQU9HLFFBQVFDLE1BQU0sQ0FBQ0Y7SUFDeEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzPzRkYzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwidHJhbnNmb3JtRGF0YSIsImlzQ2FuY2VsIiwiZGVmYXVsdHMiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiY29uZmlnIiwiY2FuY2VsVG9rZW4iLCJ0aHJvd0lmUmVxdWVzdGVkIiwibW9kdWxlIiwiZXhwb3J0cyIsImRpc3BhdGNoUmVxdWVzdCIsImhlYWRlcnMiLCJkYXRhIiwiY2FsbCIsInRyYW5zZm9ybVJlcXVlc3QiLCJtZXJnZSIsImNvbW1vbiIsIm1ldGhvZCIsImZvckVhY2giLCJjbGVhbkhlYWRlckNvbmZpZyIsImFkYXB0ZXIiLCJ0aGVuIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsInJlc3BvbnNlIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJyZWFzb24iLCJQcm9taXNlIiwicmVqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */ module.exports = function enhanceError(error, config, code, request, response) {\n    error.config = config;\n    if (code) {\n        error.code = code;\n    }\n    error.request = request;\n    error.response = response;\n    error.isAxiosError = true;\n    error.toJSON = function toJSON() {\n        return {\n            // Standard\n            message: this.message,\n            name: this.name,\n            // Microsoft\n            description: this.description,\n            number: this.number,\n            // Mozilla\n            fileName: this.fileName,\n            lineNumber: this.lineNumber,\n            columnNumber: this.columnNumber,\n            stack: this.stack,\n            // Axios\n            config: this.config,\n            code: this.code\n        };\n    };\n    return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDREEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUMzRUosTUFBTUMsTUFBTSxHQUFHQTtJQUNmLElBQUlDLE1BQU07UUFDUkYsTUFBTUUsSUFBSSxHQUFHQTtJQUNmO0lBRUFGLE1BQU1HLE9BQU8sR0FBR0E7SUFDaEJILE1BQU1JLFFBQVEsR0FBR0E7SUFDakJKLE1BQU1LLFlBQVksR0FBRztJQUVyQkwsTUFBTU0sTUFBTSxHQUFHLFNBQVNBO1FBQ3RCLE9BQU87WUFDTCxXQUFXO1lBQ1hDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmLFlBQVk7WUFDWkMsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CLFVBQVU7WUFDVkMsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJDLFlBQVksSUFBSSxDQUFDQSxVQUFVO1lBQzNCQyxjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUMvQkMsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakIsUUFBUTtZQUNSYixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDakI7SUFDRjtJQUNBLE9BQU9GO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcz8wZGYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlbmhhbmNlRXJyb3IiLCJlcnJvciIsImNvbmZpZyIsImNvZGUiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJpc0F4aW9zRXJyb3IiLCJ0b0pTT04iLCJtZXNzYWdlIiwibmFtZSIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/enhanceError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */ module.exports = function mergeConfig(config1, config2) {\n    // eslint-disable-next-line no-param-reassign\n    config2 = config2 || {};\n    var config = {};\n    var valueFromConfig2Keys = [\n        \"url\",\n        \"method\",\n        \"data\"\n    ];\n    var mergeDeepPropertiesKeys = [\n        \"headers\",\n        \"auth\",\n        \"proxy\",\n        \"params\"\n    ];\n    var defaultToConfig2Keys = [\n        \"baseURL\",\n        \"transformRequest\",\n        \"transformResponse\",\n        \"paramsSerializer\",\n        \"timeout\",\n        \"timeoutMessage\",\n        \"withCredentials\",\n        \"adapter\",\n        \"responseType\",\n        \"xsrfCookieName\",\n        \"xsrfHeaderName\",\n        \"onUploadProgress\",\n        \"onDownloadProgress\",\n        \"decompress\",\n        \"maxContentLength\",\n        \"maxBodyLength\",\n        \"maxRedirects\",\n        \"transport\",\n        \"httpAgent\",\n        \"httpsAgent\",\n        \"cancelToken\",\n        \"socketPath\",\n        \"responseEncoding\"\n    ];\n    var directMergeKeys = [\n        \"validateStatus\"\n    ];\n    function getMergedValue(target, source) {\n        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n            return utils.merge(target, source);\n        } else if (utils.isPlainObject(source)) {\n            return utils.merge({}, source);\n        } else if (utils.isArray(source)) {\n            return source.slice();\n        }\n        return source;\n    }\n    function mergeDeepProperties(prop) {\n        if (!utils.isUndefined(config2[prop])) {\n            config[prop] = getMergedValue(config1[prop], config2[prop]);\n        } else if (!utils.isUndefined(config1[prop])) {\n            config[prop] = getMergedValue(undefined, config1[prop]);\n        }\n    }\n    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n        if (!utils.isUndefined(config2[prop])) {\n            config[prop] = getMergedValue(undefined, config2[prop]);\n        }\n    });\n    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n        if (!utils.isUndefined(config2[prop])) {\n            config[prop] = getMergedValue(undefined, config2[prop]);\n        } else if (!utils.isUndefined(config1[prop])) {\n            config[prop] = getMergedValue(undefined, config1[prop]);\n        }\n    });\n    utils.forEach(directMergeKeys, function merge(prop) {\n        if (prop in config2) {\n            config[prop] = getMergedValue(config1[prop], config2[prop]);\n        } else if (prop in config1) {\n            config[prop] = getMergedValue(undefined, config1[prop]);\n        }\n    });\n    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);\n    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {\n        return axiosKeys.indexOf(key) === -1;\n    });\n    utils.forEach(otherKeys, mergeDeepProperties);\n    return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCOzs7Ozs7O0NBT0MsR0FDREMsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTztJQUNwRCw2Q0FBNkM7SUFDN0NBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJQyxTQUFTLENBQUM7SUFFZCxJQUFJQyx1QkFBdUI7UUFBQztRQUFPO1FBQVU7S0FBTztJQUNwRCxJQUFJQywwQkFBMEI7UUFBQztRQUFXO1FBQVE7UUFBUztLQUFTO0lBQ3BFLElBQUlDLHVCQUF1QjtRQUN6QjtRQUFXO1FBQW9CO1FBQXFCO1FBQ3BEO1FBQVc7UUFBa0I7UUFBbUI7UUFBVztRQUFnQjtRQUMzRTtRQUFrQjtRQUFvQjtRQUFzQjtRQUM1RDtRQUFvQjtRQUFpQjtRQUFnQjtRQUFhO1FBQ2xFO1FBQWM7UUFBZTtRQUFjO0tBQzVDO0lBQ0QsSUFBSUMsa0JBQWtCO1FBQUM7S0FBaUI7SUFFeEMsU0FBU0MsZUFBZUMsTUFBTSxFQUFFQyxNQUFNO1FBQ3BDLElBQUlkLE1BQU1lLGFBQWEsQ0FBQ0YsV0FBV2IsTUFBTWUsYUFBYSxDQUFDRCxTQUFTO1lBQzlELE9BQU9kLE1BQU1nQixLQUFLLENBQUNILFFBQVFDO1FBQzdCLE9BQU8sSUFBSWQsTUFBTWUsYUFBYSxDQUFDRCxTQUFTO1lBQ3RDLE9BQU9kLE1BQU1nQixLQUFLLENBQUMsQ0FBQyxHQUFHRjtRQUN6QixPQUFPLElBQUlkLE1BQU1pQixPQUFPLENBQUNILFNBQVM7WUFDaEMsT0FBT0EsT0FBT0ksS0FBSztRQUNyQjtRQUNBLE9BQU9KO0lBQ1Q7SUFFQSxTQUFTSyxvQkFBb0JDLElBQUk7UUFDL0IsSUFBSSxDQUFDcEIsTUFBTXFCLFdBQVcsQ0FBQ2YsT0FBTyxDQUFDYyxLQUFLLEdBQUc7WUFDckNiLE1BQU0sQ0FBQ2EsS0FBSyxHQUFHUixlQUFlUCxPQUFPLENBQUNlLEtBQUssRUFBRWQsT0FBTyxDQUFDYyxLQUFLO1FBQzVELE9BQU8sSUFBSSxDQUFDcEIsTUFBTXFCLFdBQVcsQ0FBQ2hCLE9BQU8sQ0FBQ2UsS0FBSyxHQUFHO1lBQzVDYixNQUFNLENBQUNhLEtBQUssR0FBR1IsZUFBZVUsV0FBV2pCLE9BQU8sQ0FBQ2UsS0FBSztRQUN4RDtJQUNGO0lBRUFwQixNQUFNdUIsT0FBTyxDQUFDZixzQkFBc0IsU0FBU2dCLGlCQUFpQkosSUFBSTtRQUNoRSxJQUFJLENBQUNwQixNQUFNcUIsV0FBVyxDQUFDZixPQUFPLENBQUNjLEtBQUssR0FBRztZQUNyQ2IsTUFBTSxDQUFDYSxLQUFLLEdBQUdSLGVBQWVVLFdBQVdoQixPQUFPLENBQUNjLEtBQUs7UUFDeEQ7SUFDRjtJQUVBcEIsTUFBTXVCLE9BQU8sQ0FBQ2QseUJBQXlCVTtJQUV2Q25CLE1BQU11QixPQUFPLENBQUNiLHNCQUFzQixTQUFTZSxpQkFBaUJMLElBQUk7UUFDaEUsSUFBSSxDQUFDcEIsTUFBTXFCLFdBQVcsQ0FBQ2YsT0FBTyxDQUFDYyxLQUFLLEdBQUc7WUFDckNiLE1BQU0sQ0FBQ2EsS0FBSyxHQUFHUixlQUFlVSxXQUFXaEIsT0FBTyxDQUFDYyxLQUFLO1FBQ3hELE9BQU8sSUFBSSxDQUFDcEIsTUFBTXFCLFdBQVcsQ0FBQ2hCLE9BQU8sQ0FBQ2UsS0FBSyxHQUFHO1lBQzVDYixNQUFNLENBQUNhLEtBQUssR0FBR1IsZUFBZVUsV0FBV2pCLE9BQU8sQ0FBQ2UsS0FBSztRQUN4RDtJQUNGO0lBRUFwQixNQUFNdUIsT0FBTyxDQUFDWixpQkFBaUIsU0FBU0ssTUFBTUksSUFBSTtRQUNoRCxJQUFJQSxRQUFRZCxTQUFTO1lBQ25CQyxNQUFNLENBQUNhLEtBQUssR0FBR1IsZUFBZVAsT0FBTyxDQUFDZSxLQUFLLEVBQUVkLE9BQU8sQ0FBQ2MsS0FBSztRQUM1RCxPQUFPLElBQUlBLFFBQVFmLFNBQVM7WUFDMUJFLE1BQU0sQ0FBQ2EsS0FBSyxHQUFHUixlQUFlVSxXQUFXakIsT0FBTyxDQUFDZSxLQUFLO1FBQ3hEO0lBQ0Y7SUFFQSxJQUFJTSxZQUFZbEIscUJBQ2JtQixNQUFNLENBQUNsQix5QkFDUGtCLE1BQU0sQ0FBQ2pCLHNCQUNQaUIsTUFBTSxDQUFDaEI7SUFFVixJQUFJaUIsWUFBWUMsT0FDYkMsSUFBSSxDQUFDekIsU0FDTHNCLE1BQU0sQ0FBQ0UsT0FBT0MsSUFBSSxDQUFDeEIsVUFDbkJ5QixNQUFNLENBQUMsU0FBU0MsZ0JBQWdCQyxHQUFHO1FBQ2xDLE9BQU9QLFVBQVVRLE9BQU8sQ0FBQ0QsU0FBUyxDQUFDO0lBQ3JDO0lBRUZqQyxNQUFNdUIsT0FBTyxDQUFDSyxXQUFXVDtJQUV6QixPQUFPWjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcz9iZDEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibWVyZ2VDb25maWciLCJjb25maWcxIiwiY29uZmlnMiIsImNvbmZpZyIsInZhbHVlRnJvbUNvbmZpZzJLZXlzIiwibWVyZ2VEZWVwUHJvcGVydGllc0tleXMiLCJkZWZhdWx0VG9Db25maWcyS2V5cyIsImRpcmVjdE1lcmdlS2V5cyIsImdldE1lcmdlZFZhbHVlIiwidGFyZ2V0Iiwic291cmNlIiwiaXNQbGFpbk9iamVjdCIsIm1lcmdlIiwiaXNBcnJheSIsInNsaWNlIiwibWVyZ2VEZWVwUHJvcGVydGllcyIsInByb3AiLCJpc1VuZGVmaW5lZCIsInVuZGVmaW5lZCIsImZvckVhY2giLCJ2YWx1ZUZyb21Db25maWcyIiwiZGVmYXVsdFRvQ29uZmlnMiIsImF4aW9zS2V5cyIsImNvbmNhdCIsIm90aGVyS2V5cyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJmaWx0ZXJBeGlvc0tleXMiLCJrZXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar createError = __webpack_require__(/*! ./createError */ \"(app-pages-browser)/./node_modules/axios/lib/core/createError.js\");\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */ module.exports = function settle(resolve, reject, response) {\n    var validateStatus = response.config.validateStatus;\n    if (!response.status || !validateStatus || validateStatus(response.status)) {\n        resolve(response);\n    } else {\n        reject(createError(\"Request failed with status code \" + response.status, response.config, null, response.request, response));\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxjQUFjQyxtQkFBT0EsQ0FBQztBQUUxQjs7Ozs7O0NBTUMsR0FDREMsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLE9BQU9DLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxRQUFRO0lBQ3hELElBQUlDLGlCQUFpQkQsU0FBU0UsTUFBTSxDQUFDRCxjQUFjO0lBQ25ELElBQUksQ0FBQ0QsU0FBU0csTUFBTSxJQUFJLENBQUNGLGtCQUFrQkEsZUFBZUQsU0FBU0csTUFBTSxHQUFHO1FBQzFFTCxRQUFRRTtJQUNWLE9BQU87UUFDTEQsT0FBT04sWUFDTCxxQ0FBcUNPLFNBQVNHLE1BQU0sRUFDcERILFNBQVNFLE1BQU0sRUFDZixNQUNBRixTQUFTSSxPQUFPLEVBQ2hCSjtJQUVKO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcz84NzY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUVycm9yIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZXR0bGUiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJ2YWxpZGF0ZVN0YXR1cyIsImNvbmZpZyIsInN0YXR1cyIsInJlcXVlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/settle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"(app-pages-browser)/./node_modules/axios/lib/defaults.js\");\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */ module.exports = function transformData(data, headers, fns) {\n    var context = this || defaults;\n    /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) {\n        data = fn.call(context, data, headers);\n    });\n    return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFFdkI7Ozs7Ozs7Q0FPQyxHQUNERSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsY0FBY0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDeEQsSUFBSUMsVUFBVSxJQUFJLElBQUlQO0lBQ3RCLDRCQUE0QixHQUM1QkYsTUFBTVUsT0FBTyxDQUFDRixLQUFLLFNBQVNHLFVBQVVDLEVBQUU7UUFDdENOLE9BQU9NLEdBQUdDLElBQUksQ0FBQ0osU0FBU0gsTUFBTUM7SUFDaEM7SUFFQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzPzc2NjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJkZWZhdWx0cyIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0cmFuc2Zvcm1EYXRhIiwiZGF0YSIsImhlYWRlcnMiLCJmbnMiLCJjb250ZXh0IiwiZm9yRWFjaCIsInRyYW5zZm9ybSIsImZuIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/transformData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"(app-pages-browser)/./node_modules/axios/lib/core/enhanceError.js\");\nvar DEFAULT_CONTENT_TYPE = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n};\nfunction setContentTypeIfUnset(headers, value) {\n    if (!utils.isUndefined(headers) && utils.isUndefined(headers[\"Content-Type\"])) {\n        headers[\"Content-Type\"] = value;\n    }\n}\nfunction getDefaultAdapter() {\n    var adapter;\n    if (typeof XMLHttpRequest !== \"undefined\") {\n        // For browsers use XHR adapter\n        adapter = __webpack_require__(/*! ./adapters/xhr */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js\");\n    } else if (typeof process !== \"undefined\" && Object.prototype.toString.call(process) === \"[object process]\") {\n        // For node use HTTP adapter\n        adapter = __webpack_require__(/*! ./adapters/http */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js\");\n    }\n    return adapter;\n}\nfunction stringifySafely(rawValue, parser, encoder) {\n    if (utils.isString(rawValue)) {\n        try {\n            (parser || JSON.parse)(rawValue);\n            return utils.trim(rawValue);\n        } catch (e) {\n            if (e.name !== \"SyntaxError\") {\n                throw e;\n            }\n        }\n    }\n    return (encoder || JSON.stringify)(rawValue);\n}\nvar defaults = {\n    transitional: {\n        silentJSONParsing: true,\n        forcedJSONParsing: true,\n        clarifyTimeoutError: false\n    },\n    adapter: getDefaultAdapter(),\n    transformRequest: [\n        function transformRequest(data, headers) {\n            normalizeHeaderName(headers, \"Accept\");\n            normalizeHeaderName(headers, \"Content-Type\");\n            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n                return data;\n            }\n            if (utils.isArrayBufferView(data)) {\n                return data.buffer;\n            }\n            if (utils.isURLSearchParams(data)) {\n                setContentTypeIfUnset(headers, \"application/x-www-form-urlencoded;charset=utf-8\");\n                return data.toString();\n            }\n            if (utils.isObject(data) || headers && headers[\"Content-Type\"] === \"application/json\") {\n                setContentTypeIfUnset(headers, \"application/json\");\n                return stringifySafely(data);\n            }\n            return data;\n        }\n    ],\n    transformResponse: [\n        function transformResponse(data) {\n            var transitional = this.transitional;\n            var silentJSONParsing = transitional && transitional.silentJSONParsing;\n            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n            var strictJSONParsing = !silentJSONParsing && this.responseType === \"json\";\n            if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {\n                try {\n                    return JSON.parse(data);\n                } catch (e) {\n                    if (strictJSONParsing) {\n                        if (e.name === \"SyntaxError\") {\n                            throw enhanceError(e, this, \"E_JSON_PARSE\");\n                        }\n                        throw e;\n                    }\n                }\n            }\n            return data;\n        }\n    ],\n    /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */ timeout: 0,\n    xsrfCookieName: \"XSRF-TOKEN\",\n    xsrfHeaderName: \"X-XSRF-TOKEN\",\n    maxContentLength: -1,\n    maxBodyLength: -1,\n    validateStatus: function validateStatus(status) {\n        return status >= 200 && status < 300;\n    }\n};\ndefaults.headers = {\n    common: {\n        \"Accept\": \"application/json, text/plain, */*\"\n    }\n};\nutils.forEach([\n    \"delete\",\n    \"get\",\n    \"head\"\n], function forEachMethodNoData(method) {\n    defaults.headers[method] = {};\n});\nutils.forEach([\n    \"post\",\n    \"put\",\n    \"patch\"\n], function forEachMethodWithData(method) {\n    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsc0JBQXNCRCxtQkFBT0EsQ0FBQztBQUNsQyxJQUFJRSxlQUFlRixtQkFBT0EsQ0FBQztBQUUzQixJQUFJRyx1QkFBdUI7SUFDekIsZ0JBQWdCO0FBQ2xCO0FBRUEsU0FBU0Msc0JBQXNCQyxPQUFPLEVBQUVDLEtBQUs7SUFDM0MsSUFBSSxDQUFDUCxNQUFNUSxXQUFXLENBQUNGLFlBQVlOLE1BQU1RLFdBQVcsQ0FBQ0YsT0FBTyxDQUFDLGVBQWUsR0FBRztRQUM3RUEsT0FBTyxDQUFDLGVBQWUsR0FBR0M7SUFDNUI7QUFDRjtBQUVBLFNBQVNFO0lBQ1AsSUFBSUM7SUFDSixJQUFJLE9BQU9DLG1CQUFtQixhQUFhO1FBQ3pDLCtCQUErQjtRQUMvQkQsVUFBVVQsbUJBQU9BLENBQUM7SUFDcEIsT0FBTyxJQUFJLE9BQU9XLE9BQU9BLEtBQUssZUFBZUMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0osT0FBT0EsTUFBTSxvQkFBb0I7UUFDM0csNEJBQTRCO1FBQzVCRixVQUFVVCxtQkFBT0EsQ0FBQztJQUNwQjtJQUNBLE9BQU9TO0FBQ1Q7QUFFQSxTQUFTTyxnQkFBZ0JDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hELElBQUlwQixNQUFNcUIsUUFBUSxDQUFDSCxXQUFXO1FBQzVCLElBQUk7WUFDREMsQ0FBQUEsVUFBVUcsS0FBS0MsS0FBSyxFQUFFTDtZQUN2QixPQUFPbEIsTUFBTXdCLElBQUksQ0FBQ047UUFDcEIsRUFBRSxPQUFPTyxHQUFHO1lBQ1YsSUFBSUEsRUFBRUMsSUFBSSxLQUFLLGVBQWU7Z0JBQzVCLE1BQU1EO1lBQ1I7UUFDRjtJQUNGO0lBRUEsT0FBTyxDQUFDTCxXQUFXRSxLQUFLSyxTQUFTLEVBQUVUO0FBQ3JDO0FBRUEsSUFBSVUsV0FBVztJQUViQyxjQUFjO1FBQ1pDLG1CQUFtQjtRQUNuQkMsbUJBQW1CO1FBQ25CQyxxQkFBcUI7SUFDdkI7SUFFQXRCLFNBQVNEO0lBRVR3QixrQkFBa0I7UUFBQyxTQUFTQSxpQkFBaUJDLElBQUksRUFBRTVCLE9BQU87WUFDeERKLG9CQUFvQkksU0FBUztZQUM3Qkosb0JBQW9CSSxTQUFTO1lBRTdCLElBQUlOLE1BQU1tQyxVQUFVLENBQUNELFNBQ25CbEMsTUFBTW9DLGFBQWEsQ0FBQ0YsU0FDcEJsQyxNQUFNcUMsUUFBUSxDQUFDSCxTQUNmbEMsTUFBTXNDLFFBQVEsQ0FBQ0osU0FDZmxDLE1BQU11QyxNQUFNLENBQUNMLFNBQ2JsQyxNQUFNd0MsTUFBTSxDQUFDTixPQUNiO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQSxJQUFJbEMsTUFBTXlDLGlCQUFpQixDQUFDUCxPQUFPO2dCQUNqQyxPQUFPQSxLQUFLUSxNQUFNO1lBQ3BCO1lBQ0EsSUFBSTFDLE1BQU0yQyxpQkFBaUIsQ0FBQ1QsT0FBTztnQkFDakM3QixzQkFBc0JDLFNBQVM7Z0JBQy9CLE9BQU80QixLQUFLbkIsUUFBUTtZQUN0QjtZQUNBLElBQUlmLE1BQU00QyxRQUFRLENBQUNWLFNBQVU1QixXQUFXQSxPQUFPLENBQUMsZUFBZSxLQUFLLG9CQUFxQjtnQkFDdkZELHNCQUFzQkMsU0FBUztnQkFDL0IsT0FBT1csZ0JBQWdCaUI7WUFDekI7WUFDQSxPQUFPQTtRQUNUO0tBQUU7SUFFRlcsbUJBQW1CO1FBQUMsU0FBU0Esa0JBQWtCWCxJQUFJO1lBQ2pELElBQUlMLGVBQWUsSUFBSSxDQUFDQSxZQUFZO1lBQ3BDLElBQUlDLG9CQUFvQkQsZ0JBQWdCQSxhQUFhQyxpQkFBaUI7WUFDdEUsSUFBSUMsb0JBQW9CRixnQkFBZ0JBLGFBQWFFLGlCQUFpQjtZQUN0RSxJQUFJZSxvQkFBb0IsQ0FBQ2hCLHFCQUFxQixJQUFJLENBQUNpQixZQUFZLEtBQUs7WUFFcEUsSUFBSUQscUJBQXNCZixxQkFBcUIvQixNQUFNcUIsUUFBUSxDQUFDYSxTQUFTQSxLQUFLYyxNQUFNLEVBQUc7Z0JBQ25GLElBQUk7b0JBQ0YsT0FBTzFCLEtBQUtDLEtBQUssQ0FBQ1c7Z0JBQ3BCLEVBQUUsT0FBT1QsR0FBRztvQkFDVixJQUFJcUIsbUJBQW1CO3dCQUNyQixJQUFJckIsRUFBRUMsSUFBSSxLQUFLLGVBQWU7NEJBQzVCLE1BQU12QixhQUFhc0IsR0FBRyxJQUFJLEVBQUU7d0JBQzlCO3dCQUNBLE1BQU1BO29CQUNSO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPUztRQUNUO0tBQUU7SUFFRjs7O0dBR0MsR0FDRGUsU0FBUztJQUVUQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUVoQkMsa0JBQWtCLENBQUM7SUFDbkJDLGVBQWUsQ0FBQztJQUVoQkMsZ0JBQWdCLFNBQVNBLGVBQWVDLE1BQU07UUFDNUMsT0FBT0EsVUFBVSxPQUFPQSxTQUFTO0lBQ25DO0FBQ0Y7QUFFQTNCLFNBQVN0QixPQUFPLEdBQUc7SUFDakJrRCxRQUFRO1FBQ04sVUFBVTtJQUNaO0FBQ0Y7QUFFQXhELE1BQU15RCxPQUFPLENBQUM7SUFBQztJQUFVO0lBQU87Q0FBTyxFQUFFLFNBQVNDLG9CQUFvQkMsTUFBTTtJQUMxRS9CLFNBQVN0QixPQUFPLENBQUNxRCxPQUFPLEdBQUcsQ0FBQztBQUM5QjtBQUVBM0QsTUFBTXlELE9BQU8sQ0FBQztJQUFDO0lBQVE7SUFBTztDQUFRLEVBQUUsU0FBU0csc0JBQXNCRCxNQUFNO0lBQzNFL0IsU0FBU3RCLE9BQU8sQ0FBQ3FELE9BQU8sR0FBRzNELE1BQU02RCxLQUFLLENBQUN6RDtBQUN6QztBQUVBMEQsT0FBT0MsT0FBTyxHQUFHbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcz9lMjIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vY29yZS9lbmhhbmNlRXJyb3InKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDoge1xuICAgIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG4gIH0sXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsImVuaGFuY2VFcnJvciIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwiaGVhZGVycyIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJnZXREZWZhdWx0QWRhcHRlciIsImFkYXB0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsInByb2Nlc3MiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlciIsImVuY29kZXIiLCJpc1N0cmluZyIsIkpTT04iLCJwYXJzZSIsInRyaW0iLCJlIiwibmFtZSIsInN0cmluZ2lmeSIsImRlZmF1bHRzIiwidHJhbnNpdGlvbmFsIiwic2lsZW50SlNPTlBhcnNpbmciLCJmb3JjZWRKU09OUGFyc2luZyIsImNsYXJpZnlUaW1lb3V0RXJyb3IiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwiZGF0YSIsImlzRm9ybURhdGEiLCJpc0FycmF5QnVmZmVyIiwiaXNCdWZmZXIiLCJpc1N0cmVhbSIsImlzRmlsZSIsImlzQmxvYiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc09iamVjdCIsInRyYW5zZm9ybVJlc3BvbnNlIiwic3RyaWN0SlNPTlBhcnNpbmciLCJyZXNwb25zZVR5cGUiLCJsZW5ndGgiLCJ0aW1lb3V0IiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJtYXhCb2R5TGVuZ3RoIiwidmFsaWRhdGVTdGF0dXMiLCJzdGF0dXMiLCJjb21tb24iLCJmb3JFYWNoIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsIm1ldGhvZCIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsIm1lcmdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/defaults.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = function bind(fn, thisArg) {\n    return function wrap() {\n        var args = new Array(arguments.length);\n        for(var i = 0; i < args.length; i++){\n            args[i] = arguments[i];\n        }\n        return fn.apply(thisArg, args);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxLQUFLQyxFQUFFLEVBQUVDLE9BQU87SUFDeEMsT0FBTyxTQUFTQztRQUNkLElBQUlDLE9BQU8sSUFBSUMsTUFBTUMsVUFBVUMsTUFBTTtRQUNyQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosS0FBS0csTUFBTSxFQUFFQyxJQUFLO1lBQ3BDSixJQUFJLENBQUNJLEVBQUUsR0FBR0YsU0FBUyxDQUFDRSxFQUFFO1FBQ3hCO1FBQ0EsT0FBT1AsR0FBR1EsS0FBSyxDQUFDUCxTQUFTRTtJQUMzQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzRiZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwid3JhcCIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJhcHBseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nfunction encode(val) {\n    return encodeURIComponent(val).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */ module.exports = function buildURL(url, params, paramsSerializer) {\n    /*eslint no-param-reassign:0*/ if (!params) {\n        return url;\n    }\n    var serializedParams;\n    if (paramsSerializer) {\n        serializedParams = paramsSerializer(params);\n    } else if (utils.isURLSearchParams(params)) {\n        serializedParams = params.toString();\n    } else {\n        var parts = [];\n        utils.forEach(params, function serialize(val, key) {\n            if (val === null || typeof val === \"undefined\") {\n                return;\n            }\n            if (utils.isArray(val)) {\n                key = key + \"[]\";\n            } else {\n                val = [\n                    val\n                ];\n            }\n            utils.forEach(val, function parseValue(v) {\n                if (utils.isDate(v)) {\n                    v = v.toISOString();\n                } else if (utils.isObject(v)) {\n                    v = JSON.stringify(v);\n                }\n                parts.push(encode(key) + \"=\" + encode(v));\n            });\n        });\n        serializedParams = parts.join(\"&\");\n    }\n    if (serializedParams) {\n        var hashmarkIndex = url.indexOf(\"#\");\n        if (hashmarkIndex !== -1) {\n            url = url.slice(0, hashmarkIndex);\n        }\n        url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + serializedParams;\n    }\n    return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLFNBQVNDLE9BQU9DLEdBQUc7SUFDakIsT0FBT0MsbUJBQW1CRCxLQUN4QkUsT0FBTyxDQUFDLFNBQVMsS0FDakJBLE9BQU8sQ0FBQyxRQUFRLEtBQ2hCQSxPQUFPLENBQUMsU0FBUyxLQUNqQkEsT0FBTyxDQUFDLFFBQVEsS0FDaEJBLE9BQU8sQ0FBQyxTQUFTLEtBQ2pCQSxPQUFPLENBQUMsU0FBUztBQUNyQjtBQUVBOzs7Ozs7Q0FNQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsU0FBU0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLGdCQUFnQjtJQUM5RCw0QkFBNEIsR0FDNUIsSUFBSSxDQUFDRCxRQUFRO1FBQ1gsT0FBT0Q7SUFDVDtJQUVBLElBQUlHO0lBQ0osSUFBSUQsa0JBQWtCO1FBQ3BCQyxtQkFBbUJELGlCQUFpQkQ7SUFDdEMsT0FBTyxJQUFJVixNQUFNYSxpQkFBaUIsQ0FBQ0gsU0FBUztRQUMxQ0UsbUJBQW1CRixPQUFPSSxRQUFRO0lBQ3BDLE9BQU87UUFDTCxJQUFJQyxRQUFRLEVBQUU7UUFFZGYsTUFBTWdCLE9BQU8sQ0FBQ04sUUFBUSxTQUFTTyxVQUFVZCxHQUFHLEVBQUVlLEdBQUc7WUFDL0MsSUFBSWYsUUFBUSxRQUFRLE9BQU9BLFFBQVEsYUFBYTtnQkFDOUM7WUFDRjtZQUVBLElBQUlILE1BQU1tQixPQUFPLENBQUNoQixNQUFNO2dCQUN0QmUsTUFBTUEsTUFBTTtZQUNkLE9BQU87Z0JBQ0xmLE1BQU07b0JBQUNBO2lCQUFJO1lBQ2I7WUFFQUgsTUFBTWdCLE9BQU8sQ0FBQ2IsS0FBSyxTQUFTaUIsV0FBV0MsQ0FBQztnQkFDdEMsSUFBSXJCLE1BQU1zQixNQUFNLENBQUNELElBQUk7b0JBQ25CQSxJQUFJQSxFQUFFRSxXQUFXO2dCQUNuQixPQUFPLElBQUl2QixNQUFNd0IsUUFBUSxDQUFDSCxJQUFJO29CQUM1QkEsSUFBSUksS0FBS0MsU0FBUyxDQUFDTDtnQkFDckI7Z0JBQ0FOLE1BQU1ZLElBQUksQ0FBQ3pCLE9BQU9nQixPQUFPLE1BQU1oQixPQUFPbUI7WUFDeEM7UUFDRjtRQUVBVCxtQkFBbUJHLE1BQU1hLElBQUksQ0FBQztJQUNoQztJQUVBLElBQUloQixrQkFBa0I7UUFDcEIsSUFBSWlCLGdCQUFnQnBCLElBQUlxQixPQUFPLENBQUM7UUFDaEMsSUFBSUQsa0JBQWtCLENBQUMsR0FBRztZQUN4QnBCLE1BQU1BLElBQUlzQixLQUFLLENBQUMsR0FBR0Y7UUFDckI7UUFFQXBCLE9BQU8sQ0FBQ0EsSUFBSXFCLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLEdBQUUsSUFBS2xCO0lBQ2pEO0lBRUEsT0FBT0g7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/YzE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImVuY29kZSIsInZhbCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiYnVpbGRVUkwiLCJ1cmwiLCJwYXJhbXMiLCJwYXJhbXNTZXJpYWxpemVyIiwic2VyaWFsaXplZFBhcmFtcyIsImlzVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJwYXJ0cyIsImZvckVhY2giLCJzZXJpYWxpemUiLCJrZXkiLCJpc0FycmF5IiwicGFyc2VWYWx1ZSIsInYiLCJpc0RhdGUiLCJ0b0lTT1N0cmluZyIsImlzT2JqZWN0IiwiSlNPTiIsInN0cmluZ2lmeSIsInB1c2giLCJqb2luIiwiaGFzaG1hcmtJbmRleCIsImluZGV4T2YiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */ module.exports = function combineURLs(baseURL, relativeURL) {\n    return relativeURL ? baseURL.replace(/\\/+$/, \"\") + \"/\" + relativeURL.replace(/^\\/+/, \"\") : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Q0FNQyxHQUNEQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsWUFBWUMsT0FBTyxFQUFFQyxXQUFXO0lBQ3hELE9BQU9BLGNBQ0hELFFBQVFFLE9BQU8sQ0FBQyxRQUFRLE1BQU0sTUFBTUQsWUFBWUMsT0FBTyxDQUFDLFFBQVEsTUFDaEVGO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzPzZiYzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n    return {\n        write: function write(name, value, expires, path, domain, secure) {\n            var cookie = [];\n            cookie.push(name + \"=\" + encodeURIComponent(value));\n            if (utils.isNumber(expires)) {\n                cookie.push(\"expires=\" + new Date(expires).toGMTString());\n            }\n            if (utils.isString(path)) {\n                cookie.push(\"path=\" + path);\n            }\n            if (utils.isString(domain)) {\n                cookie.push(\"domain=\" + domain);\n            }\n            if (secure === true) {\n                cookie.push(\"secure\");\n            }\n            document.cookie = cookie.join(\"; \");\n        },\n        read: function read(name) {\n            var match = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + name + \")=([^;]*)\"));\n            return match ? decodeURIComponent(match[3]) : null;\n        },\n        remove: function remove(name) {\n            this.write(name, \"\", Date.now() - 86400000);\n        }\n    };\n}() : // Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n    return {\n        write: function write() {},\n        read: function read() {\n            return null;\n        },\n        remove: function remove() {}\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEJDLE9BQU9DLE9BQU8sR0FDWkgsTUFBTUksb0JBQW9CLEtBR3hCLGdEQUQ4QztBQUM3QyxTQUFTQztJQUNSLE9BQU87UUFDTEMsT0FBTyxTQUFTQSxNQUFNQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtZQUM5RCxJQUFJQyxTQUFTLEVBQUU7WUFDZkEsT0FBT0MsSUFBSSxDQUFDUCxPQUFPLE1BQU1RLG1CQUFtQlA7WUFFNUMsSUFBSVIsTUFBTWdCLFFBQVEsQ0FBQ1AsVUFBVTtnQkFDM0JJLE9BQU9DLElBQUksQ0FBQyxhQUFhLElBQUlHLEtBQUtSLFNBQVNTLFdBQVc7WUFDeEQ7WUFFQSxJQUFJbEIsTUFBTW1CLFFBQVEsQ0FBQ1QsT0FBTztnQkFDeEJHLE9BQU9DLElBQUksQ0FBQyxVQUFVSjtZQUN4QjtZQUVBLElBQUlWLE1BQU1tQixRQUFRLENBQUNSLFNBQVM7Z0JBQzFCRSxPQUFPQyxJQUFJLENBQUMsWUFBWUg7WUFDMUI7WUFFQSxJQUFJQyxXQUFXLE1BQU07Z0JBQ25CQyxPQUFPQyxJQUFJLENBQUM7WUFDZDtZQUVBTSxTQUFTUCxNQUFNLEdBQUdBLE9BQU9RLElBQUksQ0FBQztRQUNoQztRQUVBQyxNQUFNLFNBQVNBLEtBQUtmLElBQUk7WUFDdEIsSUFBSWdCLFFBQVFILFNBQVNQLE1BQU0sQ0FBQ1UsS0FBSyxDQUFDLElBQUlDLE9BQU8sZUFBZWpCLE9BQU87WUFDbkUsT0FBUWdCLFFBQVFFLG1CQUFtQkYsS0FBSyxDQUFDLEVBQUUsSUFBSTtRQUNqRDtRQUVBRyxRQUFRLFNBQVNBLE9BQU9uQixJQUFJO1lBQzFCLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxNQUFNLElBQUlVLEtBQUtVLEdBQUcsS0FBSztRQUNwQztJQUNGO0FBQ0YsTUFHQSw0RUFEMEU7QUFDekUsU0FBU0M7SUFDUixPQUFPO1FBQ0x0QixPQUFPLFNBQVNBLFNBQVM7UUFDekJnQixNQUFNLFNBQVNBO1lBQVMsT0FBTztRQUFNO1FBQ3JDSSxRQUFRLFNBQVNBLFVBQVU7SUFDN0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz8xZDNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsInN0YW5kYXJkQnJvd3NlckVudiIsIndyaXRlIiwibmFtZSIsInZhbHVlIiwiZXhwaXJlcyIsInBhdGgiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaXNOdW1iZXIiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJpc1N0cmluZyIsImRvY3VtZW50Iiwiam9pbiIsInJlYWQiLCJtYXRjaCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */ module.exports = function isAbsoluteURL(url) {\n    // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n    // by any combination of letters, digits, plus, period, or hyphen.\n    return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7O0NBS0MsR0FDREEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLEdBQUc7SUFDekMsZ0dBQWdHO0lBQ2hHLGdHQUFnRztJQUNoRyxrRUFBa0U7SUFDbEUsT0FBTyxnQ0FBZ0NDLElBQUksQ0FBQ0Q7QUFDOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanM/YTIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNBYnNvbHV0ZVVSTCIsInVybCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */ module.exports = function isAxiosError(payload) {\n    return typeof payload === \"object\" && payload.isAxiosError === true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Q0FLQyxHQUNEQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsYUFBYUMsT0FBTztJQUM1QyxPQUFPLE9BQVFBLFlBQVksWUFBY0EsUUFBUUQsWUFBWSxLQUFLO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/YmQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImlzQXhpb3NFcnJvciIsInBheWxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement(\"a\");\n    var originURL;\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */ function resolveURL(url) {\n        var href = url;\n        if (msie) {\n            // IE needs attribute set twice to normalize properties\n            urlParsingNode.setAttribute(\"href\", href);\n            href = urlParsingNode.href;\n        }\n        urlParsingNode.setAttribute(\"href\", href);\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n            href: urlParsingNode.href,\n            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, \"\") : \"\",\n            host: urlParsingNode.host,\n            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, \"\") : \"\",\n            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \"\") : \"\",\n            hostname: urlParsingNode.hostname,\n            port: urlParsingNode.port,\n            pathname: urlParsingNode.pathname.charAt(0) === \"/\" ? urlParsingNode.pathname : \"/\" + urlParsingNode.pathname\n        };\n    }\n    originURL = resolveURL(window.location.href);\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */ return function isURLSameOrigin(requestURL) {\n        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n    };\n}() : // Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n        return true;\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQkMsT0FBT0MsT0FBTyxHQUNaSCxNQUFNSSxvQkFBb0IsS0FJeEIscUVBRm1FO0FBQ3JFLHFFQUFxRTtBQUNsRSxTQUFTQztJQUNSLElBQUlDLE9BQU8sa0JBQWtCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7SUFDckQsSUFBSUMsaUJBQWlCQyxTQUFTQyxhQUFhLENBQUM7SUFDNUMsSUFBSUM7SUFFSjs7Ozs7SUFLRixHQUNFLFNBQVNDLFdBQVdDLEdBQUc7UUFDckIsSUFBSUMsT0FBT0Q7UUFFWCxJQUFJVCxNQUFNO1lBQ1YsdURBQXVEO1lBQ3JESSxlQUFlTyxZQUFZLENBQUMsUUFBUUQ7WUFDcENBLE9BQU9OLGVBQWVNLElBQUk7UUFDNUI7UUFFQU4sZUFBZU8sWUFBWSxDQUFDLFFBQVFEO1FBRXBDLHdGQUF3RjtRQUN4RixPQUFPO1lBQ0xBLE1BQU1OLGVBQWVNLElBQUk7WUFDekJFLFVBQVVSLGVBQWVRLFFBQVEsR0FBR1IsZUFBZVEsUUFBUSxDQUFDQyxPQUFPLENBQUMsTUFBTSxNQUFNO1lBQ2hGQyxNQUFNVixlQUFlVSxJQUFJO1lBQ3pCQyxRQUFRWCxlQUFlVyxNQUFNLEdBQUdYLGVBQWVXLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDLE9BQU8sTUFBTTtZQUMzRUcsTUFBTVosZUFBZVksSUFBSSxHQUFHWixlQUFlWSxJQUFJLENBQUNILE9BQU8sQ0FBQyxNQUFNLE1BQU07WUFDcEVJLFVBQVViLGVBQWVhLFFBQVE7WUFDakNDLE1BQU1kLGVBQWVjLElBQUk7WUFDekJDLFVBQVUsZUFBZ0JBLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDLE9BQU8sTUFDL0NoQixlQUFlZSxRQUFRLEdBQ3ZCLE1BQU1mLGVBQWVlLFFBQVE7UUFDakM7SUFDRjtJQUVBWixZQUFZQyxXQUFXYSxPQUFPQyxRQUFRLENBQUNaLElBQUk7SUFFM0M7Ozs7O0lBS0YsR0FDRSxPQUFPLFNBQVNhLGdCQUFnQkMsVUFBVTtRQUN4QyxJQUFJQyxTQUFTLE1BQU9DLFFBQVEsQ0FBQ0YsY0FBZWhCLFdBQVdnQixjQUFjQTtRQUNyRSxPQUFRQyxPQUFPYixRQUFRLEtBQUtMLFVBQVVLLFFBQVEsSUFDMUNhLE9BQU9YLElBQUksS0FBS1AsVUFBVU8sSUFBSTtJQUNwQztBQUNGLE1BR0EsNkVBRDJFO0FBQzFFLFNBQVNhO0lBQ1IsT0FBTyxTQUFTSjtRQUNkLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/ODc5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsInN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGFyc2luZ05vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwidXJsIiwiaHJlZiIsInNldEF0dHJpYnV0ZSIsInByb3RvY29sIiwicmVwbGFjZSIsImhvc3QiLCJzZWFyY2giLCJoYXNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJjaGFyQXQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImlzVVJMU2FtZU9yaWdpbiIsInJlcXVlc3RVUkwiLCJwYXJzZWQiLCJpc1N0cmluZyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n    utils.forEach(headers, function processHeader(value, name) {\n        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n            headers[normalizedName] = value;\n            delete headers[name];\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEJDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxvQkFBb0JDLE9BQU8sRUFBRUMsY0FBYztJQUNuRU4sTUFBTU8sT0FBTyxDQUFDRixTQUFTLFNBQVNHLGNBQWNDLEtBQUssRUFBRUMsSUFBSTtRQUN2RCxJQUFJQSxTQUFTSixrQkFBa0JJLEtBQUtDLFdBQVcsT0FBT0wsZUFBZUssV0FBVyxJQUFJO1lBQ2xGTixPQUFPLENBQUNDLGVBQWUsR0FBR0c7WUFDMUIsT0FBT0osT0FBTyxDQUFDSyxLQUFLO1FBQ3RCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz82YjE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsImhlYWRlcnMiLCJub3JtYWxpemVkTmFtZSIsImZvckVhY2giLCJwcm9jZXNzSGVhZGVyIiwidmFsdWUiLCJuYW1lIiwidG9VcHBlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/normalizeHeaderName.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar utils = __webpack_require__(/*! ./../utils */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n    \"age\",\n    \"authorization\",\n    \"content-length\",\n    \"content-type\",\n    \"etag\",\n    \"expires\",\n    \"from\",\n    \"host\",\n    \"if-modified-since\",\n    \"if-unmodified-since\",\n    \"last-modified\",\n    \"location\",\n    \"max-forwards\",\n    \"proxy-authorization\",\n    \"referer\",\n    \"retry-after\",\n    \"user-agent\"\n];\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */ module.exports = function parseHeaders(headers) {\n    var parsed = {};\n    var key;\n    var val;\n    var i;\n    if (!headers) {\n        return parsed;\n    }\n    utils.forEach(headers.split(\"\\n\"), function parser(line) {\n        i = line.indexOf(\":\");\n        key = utils.trim(line.substr(0, i)).toLowerCase();\n        val = utils.trim(line.substr(i + 1));\n        if (key) {\n            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n                return;\n            }\n            if (key === \"set-cookie\") {\n                parsed[key] = (parsed[key] ? parsed[key] : []).concat([\n                    val\n                ]);\n            } else {\n                parsed[key] = parsed[key] ? parsed[key] + \", \" + val : val;\n            }\n        }\n    });\n    return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQiwrQ0FBK0M7QUFDL0MsNkRBQTZEO0FBQzdELElBQUlDLG9CQUFvQjtJQUN0QjtJQUFPO0lBQWlCO0lBQWtCO0lBQWdCO0lBQzFEO0lBQVc7SUFBUTtJQUFRO0lBQXFCO0lBQ2hEO0lBQWlCO0lBQVk7SUFBZ0I7SUFDN0M7SUFBVztJQUFlO0NBQzNCO0FBRUQ7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0RDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxhQUFhQyxPQUFPO0lBQzVDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUVKLElBQUksQ0FBQ0osU0FBUztRQUFFLE9BQU9DO0lBQVE7SUFFL0JQLE1BQU1XLE9BQU8sQ0FBQ0wsUUFBUU0sS0FBSyxDQUFDLE9BQU8sU0FBU0MsT0FBT0MsSUFBSTtRQUNyREosSUFBSUksS0FBS0MsT0FBTyxDQUFDO1FBQ2pCUCxNQUFNUixNQUFNZ0IsSUFBSSxDQUFDRixLQUFLRyxNQUFNLENBQUMsR0FBR1AsSUFBSVEsV0FBVztRQUMvQ1QsTUFBTVQsTUFBTWdCLElBQUksQ0FBQ0YsS0FBS0csTUFBTSxDQUFDUCxJQUFJO1FBRWpDLElBQUlGLEtBQUs7WUFDUCxJQUFJRCxNQUFNLENBQUNDLElBQUksSUFBSU4sa0JBQWtCYSxPQUFPLENBQUNQLFFBQVEsR0FBRztnQkFDdEQ7WUFDRjtZQUNBLElBQUlBLFFBQVEsY0FBYztnQkFDeEJELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHLENBQUNELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUksR0FBRyxFQUFFLEVBQUVXLE1BQU0sQ0FBQztvQkFBQ1Y7aUJBQUk7WUFDN0QsT0FBTztnQkFDTEYsTUFBTSxDQUFDQyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUksR0FBRyxPQUFPQyxNQUFNQTtZQUN6RDtRQUNGO0lBQ0Y7SUFFQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/NTRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImlnbm9yZUR1cGxpY2F0ZU9mIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlSGVhZGVycyIsImhlYWRlcnMiLCJwYXJzZWQiLCJrZXkiLCJ2YWwiLCJpIiwiZm9yRWFjaCIsInNwbGl0IiwicGFyc2VyIiwibGluZSIsImluZGV4T2YiLCJ0cmltIiwic3Vic3RyIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */ module.exports = function spread(callback) {\n    return function wrap(arr) {\n        return callback.apply(null, arr);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNEQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsT0FBT0MsUUFBUTtJQUN2QyxPQUFPLFNBQVNDLEtBQUtDLEdBQUc7UUFDdEIsT0FBT0YsU0FBU0csS0FBSyxDQUFDLE1BQU1EO0lBQzlCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcz8yNzI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwic3ByZWFkIiwiY2FsbGJhY2siLCJ3cmFwIiwiYXJyIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar pkg = __webpack_require__(/*! ./../../package.json */ \"(app-pages-browser)/./node_modules/axios/package.json\");\nvar validators = {};\n// eslint-disable-next-line func-names\n[\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"function\",\n    \"string\",\n    \"symbol\"\n].forEach(function(type, i) {\n    validators[type] = function validator(thing) {\n        return typeof thing === type || \"a\" + (i < 1 ? \"n \" : \" \") + type;\n    };\n});\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split(\".\");\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */ function isOlderVersion(version, thanVersion) {\n    var pkgVersionArr = thanVersion ? thanVersion.split(\".\") : currentVerArr;\n    var destVer = version.split(\".\");\n    for(var i = 0; i < 3; i++){\n        if (pkgVersionArr[i] > destVer[i]) {\n            return true;\n        } else if (pkgVersionArr[i] < destVer[i]) {\n            return false;\n        }\n    }\n    return false;\n}\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */ validators.transitional = function transitional(validator, version, message) {\n    var isDeprecated = version && isOlderVersion(version);\n    function formatMessage(opt, desc) {\n        return \"[Axios v\" + pkg.version + \"] Transitional option '\" + opt + \"'\" + desc + (message ? \". \" + message : \"\");\n    }\n    // eslint-disable-next-line func-names\n    return function(value, opt, opts) {\n        if (validator === false) {\n            throw new Error(formatMessage(opt, \" has been removed in \" + version));\n        }\n        if (isDeprecated && !deprecatedWarnings[opt]) {\n            deprecatedWarnings[opt] = true;\n            // eslint-disable-next-line no-console\n            console.warn(formatMessage(opt, \" has been deprecated since v\" + version + \" and will be removed in the near future\"));\n        }\n        return validator ? validator(value, opt, opts) : true;\n    };\n};\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */ function assertOptions(options, schema, allowUnknown) {\n    if (typeof options !== \"object\") {\n        throw new TypeError(\"options must be an object\");\n    }\n    var keys = Object.keys(options);\n    var i = keys.length;\n    while(i-- > 0){\n        var opt = keys[i];\n        var validator = schema[opt];\n        if (validator) {\n            var value = options[opt];\n            var result = value === undefined || validator(value, opt, options);\n            if (result !== true) {\n                throw new TypeError(\"option \" + opt + \" must be \" + result);\n            }\n            continue;\n        }\n        if (allowUnknown !== true) {\n            throw Error(\"Unknown option \" + opt);\n        }\n    }\n}\nmodule.exports = {\n    isOlderVersion: isOlderVersion,\n    assertOptions: assertOptions,\n    validators: validators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUVsQixJQUFJQyxhQUFhLENBQUM7QUFFbEIsc0NBQXNDO0FBQ3RDO0lBQUM7SUFBVTtJQUFXO0lBQVU7SUFBWTtJQUFVO0NBQVMsQ0FBQ0MsT0FBTyxDQUFDLFNBQVNDLElBQUksRUFBRUMsQ0FBQztJQUN0RkgsVUFBVSxDQUFDRSxLQUFLLEdBQUcsU0FBU0UsVUFBVUMsS0FBSztRQUN6QyxPQUFPLE9BQU9BLFVBQVVILFFBQVEsTUFBT0MsQ0FBQUEsSUFBSSxJQUFJLE9BQU8sR0FBRSxJQUFLRDtJQUMvRDtBQUNGO0FBRUEsSUFBSUkscUJBQXFCLENBQUM7QUFDMUIsSUFBSUMsZ0JBQWdCVCxJQUFJVSxPQUFPLENBQUNDLEtBQUssQ0FBQztBQUV0Qzs7Ozs7Q0FLQyxHQUNELFNBQVNDLGVBQWVGLE9BQU8sRUFBRUcsV0FBVztJQUMxQyxJQUFJQyxnQkFBZ0JELGNBQWNBLFlBQVlGLEtBQUssQ0FBQyxPQUFPRjtJQUMzRCxJQUFJTSxVQUFVTCxRQUFRQyxLQUFLLENBQUM7SUFDNUIsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUMxQixJQUFJUyxhQUFhLENBQUNULEVBQUUsR0FBR1UsT0FBTyxDQUFDVixFQUFFLEVBQUU7WUFDakMsT0FBTztRQUNULE9BQU8sSUFBSVMsYUFBYSxDQUFDVCxFQUFFLEdBQUdVLE9BQU8sQ0FBQ1YsRUFBRSxFQUFFO1lBQ3hDLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0RILFdBQVdjLFlBQVksR0FBRyxTQUFTQSxhQUFhVixTQUFTLEVBQUVJLE9BQU8sRUFBRU8sT0FBTztJQUN6RSxJQUFJQyxlQUFlUixXQUFXRSxlQUFlRjtJQUU3QyxTQUFTUyxjQUFjQyxHQUFHLEVBQUVDLElBQUk7UUFDOUIsT0FBTyxhQUFhckIsSUFBSVUsT0FBTyxHQUFHLDRCQUE2QlUsTUFBTSxNQUFPQyxPQUFRSixDQUFBQSxVQUFVLE9BQU9BLFVBQVUsRUFBQztJQUNsSDtJQUVBLHNDQUFzQztJQUN0QyxPQUFPLFNBQVNLLEtBQUssRUFBRUYsR0FBRyxFQUFFRyxJQUFJO1FBQzlCLElBQUlqQixjQUFjLE9BQU87WUFDdkIsTUFBTSxJQUFJa0IsTUFBTUwsY0FBY0MsS0FBSywwQkFBMEJWO1FBQy9EO1FBRUEsSUFBSVEsZ0JBQWdCLENBQUNWLGtCQUFrQixDQUFDWSxJQUFJLEVBQUU7WUFDNUNaLGtCQUFrQixDQUFDWSxJQUFJLEdBQUc7WUFDMUIsc0NBQXNDO1lBQ3RDSyxRQUFRQyxJQUFJLENBQ1ZQLGNBQ0VDLEtBQ0EsaUNBQWlDVixVQUFVO1FBR2pEO1FBRUEsT0FBT0osWUFBWUEsVUFBVWdCLE9BQU9GLEtBQUtHLFFBQVE7SUFDbkQ7QUFDRjtBQUVBOzs7OztDQUtDLEdBRUQsU0FBU0ksY0FBY0MsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDbEQsSUFBSSxPQUFPRixZQUFZLFVBQVU7UUFDL0IsTUFBTSxJQUFJRyxVQUFVO0lBQ3RCO0lBQ0EsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDSjtJQUN2QixJQUFJdkIsSUFBSTJCLEtBQUtFLE1BQU07SUFDbkIsTUFBTzdCLE1BQU0sRUFBRztRQUNkLElBQUllLE1BQU1ZLElBQUksQ0FBQzNCLEVBQUU7UUFDakIsSUFBSUMsWUFBWXVCLE1BQU0sQ0FBQ1QsSUFBSTtRQUMzQixJQUFJZCxXQUFXO1lBQ2IsSUFBSWdCLFFBQVFNLE9BQU8sQ0FBQ1IsSUFBSTtZQUN4QixJQUFJZSxTQUFTYixVQUFVYyxhQUFhOUIsVUFBVWdCLE9BQU9GLEtBQUtRO1lBQzFELElBQUlPLFdBQVcsTUFBTTtnQkFDbkIsTUFBTSxJQUFJSixVQUFVLFlBQVlYLE1BQU0sY0FBY2U7WUFDdEQ7WUFDQTtRQUNGO1FBQ0EsSUFBSUwsaUJBQWlCLE1BQU07WUFDekIsTUFBTU4sTUFBTSxvQkFBb0JKO1FBQ2xDO0lBQ0Y7QUFDRjtBQUVBaUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2YxQixnQkFBZ0JBO0lBQ2hCZSxlQUFlQTtJQUNmekIsWUFBWUE7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzPzAxMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGtnID0gcmVxdWlyZSgnLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcbnZhciBjdXJyZW50VmVyQXJyID0gcGtnLnZlcnNpb24uc3BsaXQoJy4nKTtcblxuLyoqXG4gKiBDb21wYXJlIHBhY2thZ2UgdmVyc2lvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IHRoYW5WZXJzaW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPbGRlclZlcnNpb24odmVyc2lvbiwgdGhhblZlcnNpb24pIHtcbiAgdmFyIHBrZ1ZlcnNpb25BcnIgPSB0aGFuVmVyc2lvbiA/IHRoYW5WZXJzaW9uLnNwbGl0KCcuJykgOiBjdXJyZW50VmVyQXJyO1xuICB2YXIgZGVzdFZlciA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAocGtnVmVyc2lvbkFycltpXSA+IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGtnVmVyc2lvbkFycltpXSA8IGRlc3RWZXJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIHZhciBpc0RlcHJlY2F0ZWQgPSB2ZXJzaW9uICYmIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBwa2cudmVyc2lvbiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCBpbiAnICsgdmVyc2lvbikpO1xuICAgIH1cblxuICAgIGlmIChpc0RlcHJlY2F0ZWQgJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2xkZXJWZXJzaW9uOiBpc09sZGVyVmVyc2lvbixcbiAgYXNzZXJ0T3B0aW9uczogYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xufTtcbiJdLCJuYW1lcyI6WyJwa2ciLCJyZXF1aXJlIiwidmFsaWRhdG9ycyIsImZvckVhY2giLCJ0eXBlIiwiaSIsInZhbGlkYXRvciIsInRoaW5nIiwiZGVwcmVjYXRlZFdhcm5pbmdzIiwiY3VycmVudFZlckFyciIsInZlcnNpb24iLCJzcGxpdCIsImlzT2xkZXJWZXJzaW9uIiwidGhhblZlcnNpb24iLCJwa2dWZXJzaW9uQXJyIiwiZGVzdFZlciIsInRyYW5zaXRpb25hbCIsIm1lc3NhZ2UiLCJpc0RlcHJlY2F0ZWQiLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsInZhbHVlIiwib3B0cyIsIkVycm9yIiwiY29uc29sZSIsIndhcm4iLCJhc3NlcnRPcHRpb25zIiwib3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIlR5cGVFcnJvciIsImtleXMiLCJPYmplY3QiLCJsZW5ndGgiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\");\n// utils is a library of generic helper functions non-specific to axios\nvar toString = Object.prototype.toString;\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */ function isArray(val) {\n    return toString.call(val) === \"[object Array]\";\n}\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */ function isUndefined(val) {\n    return typeof val === \"undefined\";\n}\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */ function isBuffer(val) {\n    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === \"function\" && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */ function isArrayBuffer(val) {\n    return toString.call(val) === \"[object ArrayBuffer]\";\n}\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */ function isFormData(val) {\n    return typeof FormData !== \"undefined\" && val instanceof FormData;\n}\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */ function isArrayBufferView(val) {\n    var result;\n    if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n        result = ArrayBuffer.isView(val);\n    } else {\n        result = val && val.buffer && val.buffer instanceof ArrayBuffer;\n    }\n    return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */ function isString(val) {\n    return typeof val === \"string\";\n}\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */ function isNumber(val) {\n    return typeof val === \"number\";\n}\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */ function isObject(val) {\n    return val !== null && typeof val === \"object\";\n}\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */ function isPlainObject(val) {\n    if (toString.call(val) !== \"[object Object]\") {\n        return false;\n    }\n    var prototype = Object.getPrototypeOf(val);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */ function isDate(val) {\n    return toString.call(val) === \"[object Date]\";\n}\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */ function isFile(val) {\n    return toString.call(val) === \"[object File]\";\n}\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */ function isBlob(val) {\n    return toString.call(val) === \"[object Blob]\";\n}\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */ function isFunction(val) {\n    return toString.call(val) === \"[object Function]\";\n}\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */ function isStream(val) {\n    return isObject(val) && isFunction(val.pipe);\n}\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */ function isURLSearchParams(val) {\n    return typeof URLSearchParams !== \"undefined\" && val instanceof URLSearchParams;\n}\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */ function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, \"\");\n}\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */ function isStandardBrowserEnv() {\n    if (typeof navigator !== \"undefined\" && (navigator.product === \"ReactNative\" || navigator.product === \"NativeScript\" || navigator.product === \"NS\")) {\n        return false;\n    }\n    return  true && typeof document !== \"undefined\";\n}\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */ function forEach(obj, fn) {\n    // Don't bother if no value provided\n    if (obj === null || typeof obj === \"undefined\") {\n        return;\n    }\n    // Force an array if not already something iterable\n    if (typeof obj !== \"object\") {\n        /*eslint no-param-reassign:0*/ obj = [\n            obj\n        ];\n    }\n    if (isArray(obj)) {\n        // Iterate over array values\n        for(var i = 0, l = obj.length; i < l; i++){\n            fn.call(null, obj[i], i, obj);\n        }\n    } else {\n        // Iterate over object keys\n        for(var key in obj){\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                fn.call(null, obj[key], key, obj);\n            }\n        }\n    }\n}\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */ function merge() {\n    var result = {};\n    function assignValue(val, key) {\n        if (isPlainObject(result[key]) && isPlainObject(val)) {\n            result[key] = merge(result[key], val);\n        } else if (isPlainObject(val)) {\n            result[key] = merge({}, val);\n        } else if (isArray(val)) {\n            result[key] = val.slice();\n        } else {\n            result[key] = val;\n        }\n    }\n    for(var i = 0, l = arguments.length; i < l; i++){\n        forEach(arguments[i], assignValue);\n    }\n    return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */ function extend(a, b, thisArg) {\n    forEach(b, function assignValue(val, key) {\n        if (thisArg && typeof val === \"function\") {\n            a[key] = bind(val, thisArg);\n        } else {\n            a[key] = val;\n        }\n    });\n    return a;\n}\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */ function stripBOM(content) {\n    if (content.charCodeAt(0) === 0xFEFF) {\n        content = content.slice(1);\n    }\n    return content;\n}\nmodule.exports = {\n    isArray: isArray,\n    isArrayBuffer: isArrayBuffer,\n    isBuffer: isBuffer,\n    isFormData: isFormData,\n    isArrayBufferView: isArrayBufferView,\n    isString: isString,\n    isNumber: isNumber,\n    isObject: isObject,\n    isPlainObject: isPlainObject,\n    isUndefined: isUndefined,\n    isDate: isDate,\n    isFile: isFile,\n    isBlob: isBlob,\n    isFunction: isFunction,\n    isStream: isStream,\n    isURLSearchParams: isURLSearchParams,\n    isStandardBrowserEnv: isStandardBrowserEnv,\n    forEach: forEach,\n    merge: merge,\n    extend: extend,\n    trim: trim,\n    stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVuQix1RUFBdUU7QUFFdkUsSUFBSUMsV0FBV0MsT0FBT0MsU0FBUyxDQUFDRixRQUFRO0FBRXhDOzs7OztDQUtDLEdBQ0QsU0FBU0csUUFBUUMsR0FBRztJQUNsQixPQUFPSixTQUFTSyxJQUFJLENBQUNELFNBQVM7QUFDaEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNFLFlBQVlGLEdBQUc7SUFDdEIsT0FBTyxPQUFPQSxRQUFRO0FBQ3hCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTRyxTQUFTSCxHQUFHO0lBQ25CLE9BQU9BLFFBQVEsUUFBUSxDQUFDRSxZQUFZRixRQUFRQSxJQUFJSSxXQUFXLEtBQUssUUFBUSxDQUFDRixZQUFZRixJQUFJSSxXQUFXLEtBQy9GLE9BQU9KLElBQUlJLFdBQVcsQ0FBQ0QsUUFBUSxLQUFLLGNBQWNILElBQUlJLFdBQVcsQ0FBQ0QsUUFBUSxDQUFDSDtBQUNsRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0ssY0FBY0wsR0FBRztJQUN4QixPQUFPSixTQUFTSyxJQUFJLENBQUNELFNBQVM7QUFDaEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNNLFdBQVdOLEdBQUc7SUFDckIsT0FBTyxPQUFRTyxhQUFhLGVBQWlCUCxlQUFlTztBQUM5RDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0Msa0JBQWtCUixHQUFHO0lBQzVCLElBQUlTO0lBQ0osSUFBSSxPQUFRQyxnQkFBZ0IsZUFBaUJBLFlBQVlDLE1BQU0sRUFBRztRQUNoRUYsU0FBU0MsWUFBWUMsTUFBTSxDQUFDWDtJQUM5QixPQUFPO1FBQ0xTLFNBQVMsT0FBVVQsSUFBSVksTUFBTSxJQUFNWixJQUFJWSxNQUFNLFlBQVlGO0lBQzNEO0lBQ0EsT0FBT0Q7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FB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WkUsbUJBQW1CQTtJQUNuQkssVUFBVUE7SUFDVkMsVUFBVUE7SUFDVkMsVUFBVUE7SUFDVkMsZUFBZUE7SUFDZmQsYUFBYUE7SUFDYmdCLFFBQVFBO0lBQ1JDLFFBQVFBO0lBQ1JDLFFBQVFBO0lBQ1JDLFlBQVlBO0lBQ1pDLFVBQVVBO0lBQ1ZFLG1CQUFtQkE7SUFDbkJLLHNCQUFzQkE7SUFDdEJJLFNBQVNBO0lBQ1RRLE9BQU9BO0lBQ1BJLFFBQVFBO0lBQ1JuQixNQUFNQTtJQUNOdUIsVUFBVUE7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzP2M5ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIl0sIm5hbWVzIjpbImJpbmQiLCJyZXF1aXJlIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJpc0FycmF5IiwidmFsIiwiY2FsbCIsImlzVW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXlCdWZmZXIiLCJpc0Zvcm1EYXRhIiwiRm9ybURhdGEiLCJpc0FycmF5QnVmZmVyVmlldyIsInJlc3VsdCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGdW5jdGlvbiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJkb2N1bWVudCIsImZvckVhY2giLCJvYmoiLCJmbiIsImkiLCJsIiwibGVuZ3RoIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwic2xpY2UiLCJhcmd1bWVudHMiLCJleHRlbmQiLCJhIiwiYiIsInRoaXNBcmciLCJzdHJpcEJPTSIsImNvbnRlbnQiLCJjaGFyQ29kZUF0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js":
/*!***************************************************!*\
  !*** ./node_modules/enquire.js/src/MediaQuery.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar QueryHandler = __webpack_require__(/*! ./QueryHandler */ \"(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js\");\nvar each = (__webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/enquire.js/src/Util.js\").each);\n/**\n * Represents a single media query, manages it's state and registered handlers for this query\n *\n * @constructor\n * @param {string} query the media query string\n * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design\n */ function MediaQuery(query, isUnconditional) {\n    this.query = query;\n    this.isUnconditional = isUnconditional;\n    this.handlers = [];\n    this.mql = window.matchMedia(query);\n    var self = this;\n    this.listener = function(mql) {\n        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly\n        self.mql = mql.currentTarget || mql;\n        self.assess();\n    };\n    this.mql.addListener(this.listener);\n}\n_c = MediaQuery;\nMediaQuery.prototype = {\n    constuctor: MediaQuery,\n    /**\n     * add a handler for this query, triggering if already active\n     *\n     * @param {object} handler\n     * @param {function} handler.match callback for when query is activated\n     * @param {function} [handler.unmatch] callback for when query is deactivated\n     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\n     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\n     */ addHandler: function(handler) {\n        var qh = new QueryHandler(handler);\n        this.handlers.push(qh);\n        this.matches() && qh.on();\n    },\n    /**\n     * removes the given handler from the collection, and calls it's destroy methods\n     *\n     * @param {object || function} handler the handler to remove\n     */ removeHandler: function(handler) {\n        var handlers = this.handlers;\n        each(handlers, function(h, i) {\n            if (h.equals(handler)) {\n                h.destroy();\n                return !handlers.splice(i, 1); //remove from array and exit each early\n            }\n        });\n    },\n    /**\n     * Determine whether the media query should be considered a match\n     *\n     * @return {Boolean} true if media query can be considered a match, false otherwise\n     */ matches: function() {\n        return this.mql.matches || this.isUnconditional;\n    },\n    /**\n     * Clears all handlers and unbinds events\n     */ clear: function() {\n        each(this.handlers, function(handler) {\n            handler.destroy();\n        });\n        this.mql.removeListener(this.listener);\n        this.handlers.length = 0; //clear array\n    },\n    /*\n        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\n        */ assess: function() {\n        var action = this.matches() ? \"on\" : \"off\";\n        each(this.handlers, function(handler) {\n            handler[action]();\n        });\n    }\n};\nmodule.exports = MediaQuery;\nvar _c;\n$RefreshReg$(_c, \"MediaQuery\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9NZWRpYVF1ZXJ5LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxPQUFPRCxxR0FBc0I7QUFFakM7Ozs7OztDQU1DLEdBQ0QsU0FBU0UsV0FBV0MsS0FBSyxFQUFFQyxlQUFlO0lBQ3RDLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtJQUNiLElBQUksQ0FBQ0MsZUFBZSxHQUFHQTtJQUN2QixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO0lBQ2xCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxPQUFPQyxVQUFVLENBQUNMO0lBRTdCLElBQUlNLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHLFNBQVNKLEdBQUc7UUFDeEIsaUdBQWlHO1FBQ2pHRyxLQUFLSCxHQUFHLEdBQUdBLElBQUlLLGFBQWEsSUFBSUw7UUFDaENHLEtBQUtHLE1BQU07SUFDZjtJQUNBLElBQUksQ0FBQ04sR0FBRyxDQUFDTyxXQUFXLENBQUMsSUFBSSxDQUFDSCxRQUFRO0FBQ3RDO0tBYlNSO0FBZVRBLFdBQVdZLFNBQVMsR0FBRztJQUVuQkMsWUFBYWI7SUFFYjs7Ozs7Ozs7S0FRQyxHQUNEYyxZQUFhLFNBQVNDLE9BQU87UUFDekIsSUFBSUMsS0FBSyxJQUFJbkIsYUFBYWtCO1FBQzFCLElBQUksQ0FBQ1osUUFBUSxDQUFDYyxJQUFJLENBQUNEO1FBRW5CLElBQUksQ0FBQ0UsT0FBTyxNQUFNRixHQUFHRyxFQUFFO0lBQzNCO0lBRUE7Ozs7S0FJQyxHQUNEQyxlQUFnQixTQUFTTCxPQUFPO1FBQzVCLElBQUlaLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzVCSixLQUFLSSxVQUFVLFNBQVNrQixDQUFDLEVBQUVDLENBQUM7WUFDeEIsSUFBR0QsRUFBRUUsTUFBTSxDQUFDUixVQUFVO2dCQUNsQk0sRUFBRUcsT0FBTztnQkFDVCxPQUFPLENBQUNyQixTQUFTc0IsTUFBTSxDQUFDSCxHQUFFLElBQUksdUNBQXVDO1lBQ3pFO1FBQ0o7SUFDSjtJQUVBOzs7O0tBSUMsR0FDREosU0FBVTtRQUNOLE9BQU8sSUFBSSxDQUFDZCxHQUFHLENBQUNjLE9BQU8sSUFBSSxJQUFJLENBQUNoQixlQUFlO0lBQ25EO0lBRUE7O0tBRUMsR0FDRHdCLE9BQVE7UUFDSjNCLEtBQUssSUFBSSxDQUFDSSxRQUFRLEVBQUUsU0FBU1ksT0FBTztZQUNoQ0EsUUFBUVMsT0FBTztRQUNuQjtRQUNBLElBQUksQ0FBQ3BCLEdBQUcsQ0FBQ3VCLGNBQWMsQ0FBQyxJQUFJLENBQUNuQixRQUFRO1FBQ3JDLElBQUksQ0FBQ0wsUUFBUSxDQUFDeUIsTUFBTSxHQUFHLEdBQUcsYUFBYTtJQUMzQztJQUVBOztRQUVJLEdBQ0psQixRQUFTO1FBQ0wsSUFBSW1CLFNBQVMsSUFBSSxDQUFDWCxPQUFPLEtBQUssT0FBTztRQUVyQ25CLEtBQUssSUFBSSxDQUFDSSxRQUFRLEVBQUUsU0FBU1ksT0FBTztZQUNoQ0EsT0FBTyxDQUFDYyxPQUFPO1FBQ25CO0lBQ0o7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUcvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZW5xdWlyZS5qcy9zcmMvTWVkaWFRdWVyeS5qcz8zNzc0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBRdWVyeUhhbmRsZXIgPSByZXF1aXJlKCcuL1F1ZXJ5SGFuZGxlcicpO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL1V0aWwnKS5lYWNoO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgbWVkaWEgcXVlcnksIG1hbmFnZXMgaXQncyBzdGF0ZSBhbmQgcmVnaXN0ZXJlZCBoYW5kbGVycyBmb3IgdGhpcyBxdWVyeVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBtZWRpYSBxdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVW5jb25kaXRpb25hbD1mYWxzZV0gd2hldGhlciB0aGUgbWVkaWEgcXVlcnkgc2hvdWxkIHJ1biByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNvbmRpdGlvbnMgYXJlIG1ldC4gUHJpbWFyaWx5IGZvciBoZWxwaW5nIG9sZGVyIGJyb3dzZXJzIGRlYWwgd2l0aCBtb2JpbGUtZmlyc3QgZGVzaWduXG4gKi9cbmZ1bmN0aW9uIE1lZGlhUXVlcnkocXVlcnksIGlzVW5jb25kaXRpb25hbCkge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICB0aGlzLmlzVW5jb25kaXRpb25hbCA9IGlzVW5jb25kaXRpb25hbDtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5tcWwgPSB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKG1xbCkge1xuICAgICAgICAvLyBDaHJvbWUgcGFzc2VzIGFuIE1lZGlhUXVlcnlMaXN0RXZlbnQgb2JqZWN0LCB3aGlsZSBvdGhlciBicm93c2VycyBwYXNzIE1lZGlhUXVlcnlMaXN0IGRpcmVjdGx5XG4gICAgICAgIHNlbGYubXFsID0gbXFsLmN1cnJlbnRUYXJnZXQgfHwgbXFsO1xuICAgICAgICBzZWxmLmFzc2VzcygpO1xuICAgIH07XG4gICAgdGhpcy5tcWwuYWRkTGlzdGVuZXIodGhpcy5saXN0ZW5lcik7XG59XG5cbk1lZGlhUXVlcnkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3R1Y3RvciA6IE1lZGlhUXVlcnksXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBoYW5kbGVyIGZvciB0aGlzIHF1ZXJ5LCB0cmlnZ2VyaW5nIGlmIGFscmVhZHkgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIubWF0Y2ggY2FsbGJhY2sgZm9yIHdoZW4gcXVlcnkgaXMgYWN0aXZhdGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXIudW5tYXRjaF0gY2FsbGJhY2sgZm9yIHdoZW4gcXVlcnkgaXMgZGVhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlci5zZXR1cF0gY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSBleGVjdXRpb24gd2hlbiBhIHF1ZXJ5IGhhbmRsZXIgaXMgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhbmRsZXIuZGVmZXJTZXR1cD1mYWxzZV0gc2hvdWxkIHRoZSBzZXR1cCBjYWxsYmFjayBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZmlyc3QgdGltZSB0aGUgaGFuZGxlciBpcyBtYXRjaGVkP1xuICAgICAqL1xuICAgIGFkZEhhbmRsZXIgOiBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIHZhciBxaCA9IG5ldyBRdWVyeUhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChxaCk7XG5cbiAgICAgICAgdGhpcy5tYXRjaGVzKCkgJiYgcWgub24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyB0aGUgZ2l2ZW4gaGFuZGxlciBmcm9tIHRoZSBjb2xsZWN0aW9uLCBhbmQgY2FsbHMgaXQncyBkZXN0cm95IG1ldGhvZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHx8IGZ1bmN0aW9ufSBoYW5kbGVyIHRoZSBoYW5kbGVyIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZUhhbmRsZXIgOiBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGgsIGkpIHtcbiAgICAgICAgICAgIGlmKGguZXF1YWxzKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFoYW5kbGVycy5zcGxpY2UoaSwxKTsgLy9yZW1vdmUgZnJvbSBhcnJheSBhbmQgZXhpdCBlYWNoIGVhcmx5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgbWVkaWEgcXVlcnkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBtYXRjaFxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBtZWRpYSBxdWVyeSBjYW4gYmUgY29uc2lkZXJlZCBhIG1hdGNoLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtYXRjaGVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1xbC5tYXRjaGVzIHx8IHRoaXMuaXNVbmNvbmRpdGlvbmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGhhbmRsZXJzIGFuZCB1bmJpbmRzIGV2ZW50c1xuICAgICAqL1xuICAgIGNsZWFyIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1xbC5yZW1vdmVMaXN0ZW5lcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5sZW5ndGggPSAwOyAvL2NsZWFyIGFycmF5XG4gICAgfSxcblxuICAgIC8qXG4gICAgICAgICogQXNzZXNzZXMgdGhlIHF1ZXJ5LCB0dXJuaW5nIG9uIGFsbCBoYW5kbGVycyBpZiBpdCBtYXRjaGVzLCB0dXJuaW5nIHRoZW0gb2ZmIGlmIGl0IGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgKi9cbiAgICBhc3Nlc3MgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMubWF0Y2hlcygpID8gJ29uJyA6ICdvZmYnO1xuXG4gICAgICAgIGVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlclthY3Rpb25dKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVkaWFRdWVyeTtcbiJdLCJuYW1lcyI6WyJRdWVyeUhhbmRsZXIiLCJyZXF1aXJlIiwiZWFjaCIsIk1lZGlhUXVlcnkiLCJxdWVyeSIsImlzVW5jb25kaXRpb25hbCIsImhhbmRsZXJzIiwibXFsIiwid2luZG93IiwibWF0Y2hNZWRpYSIsInNlbGYiLCJsaXN0ZW5lciIsImN1cnJlbnRUYXJnZXQiLCJhc3Nlc3MiLCJhZGRMaXN0ZW5lciIsInByb3RvdHlwZSIsImNvbnN0dWN0b3IiLCJhZGRIYW5kbGVyIiwiaGFuZGxlciIsInFoIiwicHVzaCIsIm1hdGNoZXMiLCJvbiIsInJlbW92ZUhhbmRsZXIiLCJoIiwiaSIsImVxdWFscyIsImRlc3Ryb3kiLCJzcGxpY2UiLCJjbGVhciIsInJlbW92ZUxpc3RlbmVyIiwibGVuZ3RoIiwiYWN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js":
/*!***********************************************************!*\
  !*** ./node_modules/enquire.js/src/MediaQueryDispatch.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar MediaQuery = __webpack_require__(/*! ./MediaQuery */ \"(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js\");\nvar Util = __webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/enquire.js/src/Util.js\");\nvar each = Util.each;\nvar isFunction = Util.isFunction;\nvar isArray = Util.isArray;\n/**\n * Allows for registration of query handlers.\n * Manages the query handler's state and is responsible for wiring up browser events\n *\n * @constructor\n */ function MediaQueryDispatch() {\n    if (!window.matchMedia) {\n        throw new Error(\"matchMedia not present, legacy browsers require a polyfill\");\n    }\n    this.queries = {};\n    this.browserIsIncapable = !window.matchMedia(\"only all\").matches;\n}\n_c = MediaQueryDispatch;\nMediaQueryDispatch.prototype = {\n    constructor: MediaQueryDispatch,\n    /**\n     * Registers a handler for the given media query\n     *\n     * @param {string} q the media query\n     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\n     * @param {function} options.match fired when query matched\n     * @param {function} [options.unmatch] fired when a query is no longer matched\n     * @param {function} [options.setup] fired when handler first triggered\n     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\n     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\n     */ register: function(q, options, shouldDegrade) {\n        var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;\n        if (!queries[q]) {\n            queries[q] = new MediaQuery(q, isUnconditional);\n        }\n        //normalise to object in an array\n        if (isFunction(options)) {\n            options = {\n                match: options\n            };\n        }\n        if (!isArray(options)) {\n            options = [\n                options\n            ];\n        }\n        each(options, function(handler) {\n            if (isFunction(handler)) {\n                handler = {\n                    match: handler\n                };\n            }\n            queries[q].addHandler(handler);\n        });\n        return this;\n    },\n    /**\n     * unregisters a query and all it's handlers, or a specific handler for a query\n     *\n     * @param {string} q the media query to target\n     * @param {object || function} [handler] specific handler to unregister\n     */ unregister: function(q, handler) {\n        var query = this.queries[q];\n        if (query) {\n            if (handler) {\n                query.removeHandler(handler);\n            } else {\n                query.clear();\n                delete this.queries[q];\n            }\n        }\n        return this;\n    }\n};\nmodule.exports = MediaQueryDispatch;\nvar _c;\n$RefreshReg$(_c, \"MediaQueryDispatch\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9NZWRpYVF1ZXJ5RGlzcGF0Y2guanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLE9BQU9ELEtBQUtDLElBQUk7QUFDcEIsSUFBSUMsYUFBYUYsS0FBS0UsVUFBVTtBQUNoQyxJQUFJQyxVQUFVSCxLQUFLRyxPQUFPO0FBRTFCOzs7OztDQUtDLEdBQ0QsU0FBU0M7SUFDTCxJQUFHLENBQUNDLE9BQU9DLFVBQVUsRUFBRTtRQUNuQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO0lBQ2hCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsQ0FBQ0osT0FBT0MsVUFBVSxDQUFDLFlBQVlJLE9BQU87QUFDcEU7S0FQU047QUFTVEEsbUJBQW1CTyxTQUFTLEdBQUc7SUFFM0JDLGFBQWNSO0lBRWQ7Ozs7Ozs7Ozs7S0FVQyxHQUNEUyxVQUFXLFNBQVNDLENBQUMsRUFBRUMsT0FBTyxFQUFFQyxhQUFhO1FBQ3pDLElBQUlSLFVBQWtCLElBQUksQ0FBQ0EsT0FBTyxFQUM5QlMsa0JBQWtCRCxpQkFBaUIsSUFBSSxDQUFDUCxrQkFBa0I7UUFFOUQsSUFBRyxDQUFDRCxPQUFPLENBQUNNLEVBQUUsRUFBRTtZQUNaTixPQUFPLENBQUNNLEVBQUUsR0FBRyxJQUFJaEIsV0FBV2dCLEdBQUdHO1FBQ25DO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUdmLFdBQVdhLFVBQVU7WUFDcEJBLFVBQVU7Z0JBQUVHLE9BQVFIO1lBQVE7UUFDaEM7UUFDQSxJQUFHLENBQUNaLFFBQVFZLFVBQVU7WUFDbEJBLFVBQVU7Z0JBQUNBO2FBQVE7UUFDdkI7UUFDQWQsS0FBS2MsU0FBUyxTQUFTSSxPQUFPO1lBQzFCLElBQUlqQixXQUFXaUIsVUFBVTtnQkFDckJBLFVBQVU7b0JBQUVELE9BQVFDO2dCQUFRO1lBQ2hDO1lBQ0FYLE9BQU8sQ0FBQ00sRUFBRSxDQUFDTSxVQUFVLENBQUNEO1FBQzFCO1FBRUEsT0FBTyxJQUFJO0lBQ2Y7SUFFQTs7Ozs7S0FLQyxHQUNERSxZQUFhLFNBQVNQLENBQUMsRUFBRUssT0FBTztRQUM1QixJQUFJRyxRQUFRLElBQUksQ0FBQ2QsT0FBTyxDQUFDTSxFQUFFO1FBRTNCLElBQUdRLE9BQU87WUFDTixJQUFHSCxTQUFTO2dCQUNSRyxNQUFNQyxhQUFhLENBQUNKO1lBQ3hCLE9BQ0s7Z0JBQ0RHLE1BQU1FLEtBQUs7Z0JBQ1gsT0FBTyxJQUFJLENBQUNoQixPQUFPLENBQUNNLEVBQUU7WUFDMUI7UUFDSjtRQUVBLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFFQVcsT0FBT0MsT0FBTyxHQUFHdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VucXVpcmUuanMvc3JjL01lZGlhUXVlcnlEaXNwYXRjaC5qcz80MTk5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBNZWRpYVF1ZXJ5ID0gcmVxdWlyZSgnLi9NZWRpYVF1ZXJ5Jyk7XG52YXIgVXRpbCA9IHJlcXVpcmUoJy4vVXRpbCcpO1xudmFyIGVhY2ggPSBVdGlsLmVhY2g7XG52YXIgaXNGdW5jdGlvbiA9IFV0aWwuaXNGdW5jdGlvbjtcbnZhciBpc0FycmF5ID0gVXRpbC5pc0FycmF5O1xuXG4vKipcbiAqIEFsbG93cyBmb3IgcmVnaXN0cmF0aW9uIG9mIHF1ZXJ5IGhhbmRsZXJzLlxuICogTWFuYWdlcyB0aGUgcXVlcnkgaGFuZGxlcidzIHN0YXRlIGFuZCBpcyByZXNwb25zaWJsZSBmb3Igd2lyaW5nIHVwIGJyb3dzZXIgZXZlbnRzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1lZGlhUXVlcnlEaXNwYXRjaCAoKSB7XG4gICAgaWYoIXdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWF0Y2hNZWRpYSBub3QgcHJlc2VudCwgbGVnYWN5IGJyb3dzZXJzIHJlcXVpcmUgYSBwb2x5ZmlsbCcpO1xuICAgIH1cblxuICAgIHRoaXMucXVlcmllcyA9IHt9O1xuICAgIHRoaXMuYnJvd3NlcklzSW5jYXBhYmxlID0gIXdpbmRvdy5tYXRjaE1lZGlhKCdvbmx5IGFsbCcpLm1hdGNoZXM7XG59XG5cbk1lZGlhUXVlcnlEaXNwYXRjaC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IE1lZGlhUXVlcnlEaXNwYXRjaCxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBtZWRpYSBxdWVyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHEgdGhlIG1lZGlhIHF1ZXJ5XG4gICAgICogQHBhcmFtIHtvYmplY3QgfHwgQXJyYXkgfHwgRnVuY3Rpb259IG9wdGlvbnMgZWl0aGVyIGEgc2luZ2xlIHF1ZXJ5IGhhbmRsZXIgb2JqZWN0LCBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheSBvZiBxdWVyeSBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMubWF0Y2ggZmlyZWQgd2hlbiBxdWVyeSBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudW5tYXRjaF0gZmlyZWQgd2hlbiBhIHF1ZXJ5IGlzIG5vIGxvbmdlciBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuc2V0dXBdIGZpcmVkIHdoZW4gaGFuZGxlciBmaXJzdCB0cmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmVyU2V0dXA9ZmFsc2VdIHdoZXRoZXIgc2V0dXAgc2hvdWxkIGJlIHJ1biBpbW1lZGlhdGVseSBvciBkZWZlcnJlZCB1bnRpbCBxdWVyeSBpcyBmaXJzdCBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkRGVncmFkZT1mYWxzZV0gd2hldGhlciB0aGlzIHBhcnRpY3VsYXIgbWVkaWEgcXVlcnkgc2hvdWxkIGFsd2F5cyBydW4gb24gaW5jYXBhYmxlIGJyb3dzZXJzXG4gICAgICovXG4gICAgcmVnaXN0ZXIgOiBmdW5jdGlvbihxLCBvcHRpb25zLCBzaG91bGREZWdyYWRlKSB7XG4gICAgICAgIHZhciBxdWVyaWVzICAgICAgICAgPSB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICBpc1VuY29uZGl0aW9uYWwgPSBzaG91bGREZWdyYWRlICYmIHRoaXMuYnJvd3NlcklzSW5jYXBhYmxlO1xuXG4gICAgICAgIGlmKCFxdWVyaWVzW3FdKSB7XG4gICAgICAgICAgICBxdWVyaWVzW3FdID0gbmV3IE1lZGlhUXVlcnkocSwgaXNVbmNvbmRpdGlvbmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9ybWFsaXNlIHRvIG9iamVjdCBpbiBhbiBhcnJheVxuICAgICAgICBpZihpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBtYXRjaCA6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZighaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHsgbWF0Y2ggOiBoYW5kbGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyaWVzW3FdLmFkZEhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bnJlZ2lzdGVycyBhIHF1ZXJ5IGFuZCBhbGwgaXQncyBoYW5kbGVycywgb3IgYSBzcGVjaWZpYyBoYW5kbGVyIGZvciBhIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcSB0aGUgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3QgfHwgZnVuY3Rpb259IFtoYW5kbGVyXSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyIDogZnVuY3Rpb24ocSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbcV07XG5cbiAgICAgICAgaWYocXVlcnkpIHtcbiAgICAgICAgICAgIGlmKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBxdWVyeS5yZW1vdmVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyaWVzW3FdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVF1ZXJ5RGlzcGF0Y2g7XG4iXSwibmFtZXMiOlsiTWVkaWFRdWVyeSIsInJlcXVpcmUiLCJVdGlsIiwiZWFjaCIsImlzRnVuY3Rpb24iLCJpc0FycmF5IiwiTWVkaWFRdWVyeURpc3BhdGNoIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIkVycm9yIiwicXVlcmllcyIsImJyb3dzZXJJc0luY2FwYWJsZSIsIm1hdGNoZXMiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsInJlZ2lzdGVyIiwicSIsIm9wdGlvbnMiLCJzaG91bGREZWdyYWRlIiwiaXNVbmNvbmRpdGlvbmFsIiwibWF0Y2giLCJoYW5kbGVyIiwiYWRkSGFuZGxlciIsInVucmVnaXN0ZXIiLCJxdWVyeSIsInJlbW92ZUhhbmRsZXIiLCJjbGVhciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/enquire.js/src/QueryHandler.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Delegate to handle a media query being matched and unmatched.\n *\n * @param {object} options\n * @param {function} options.match callback for when the media query is matched\n * @param {function} [options.unmatch] callback for when the media query is unmatched\n * @param {function} [options.setup] one-time callback triggered the first time a query is matched\n * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?\n * @constructor\n */ \nfunction QueryHandler(options) {\n    this.options = options;\n    !options.deferSetup && this.setup();\n}\n_c = QueryHandler;\nQueryHandler.prototype = {\n    constructor: QueryHandler,\n    /**\n     * coordinates setup of the handler\n     *\n     * @function\n     */ setup: function() {\n        if (this.options.setup) {\n            this.options.setup();\n        }\n        this.initialised = true;\n    },\n    /**\n     * coordinates setup and triggering of the handler\n     *\n     * @function\n     */ on: function() {\n        !this.initialised && this.setup();\n        this.options.match && this.options.match();\n    },\n    /**\n     * coordinates the unmatch event for the handler\n     *\n     * @function\n     */ off: function() {\n        this.options.unmatch && this.options.unmatch();\n    },\n    /**\n     * called when a handler is to be destroyed.\n     * delegates to the destroy or unmatch callbacks, depending on availability.\n     *\n     * @function\n     */ destroy: function() {\n        this.options.destroy ? this.options.destroy() : this.off();\n    },\n    /**\n     * determines equality by reference.\n     * if object is supplied compare options, if function, compare match callback\n     *\n     * @function\n     * @param {object || function} [target] the target for comparison\n     */ equals: function(target) {\n        return this.options === target || this.options.match === target;\n    }\n};\nmodule.exports = QueryHandler;\nvar _c;\n$RefreshReg$(_c, \"QueryHandler\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9RdWVyeUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDO0FBQ0QsU0FBU0EsYUFBYUMsT0FBTztJQUN6QixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDZixDQUFDQSxRQUFRQyxVQUFVLElBQUksSUFBSSxDQUFDQyxLQUFLO0FBQ3JDO0tBSFNIO0FBS1RBLGFBQWFJLFNBQVMsR0FBRztJQUVyQkMsYUFBY0w7SUFFZDs7OztLQUlDLEdBQ0RHLE9BQVE7UUFDSixJQUFHLElBQUksQ0FBQ0YsT0FBTyxDQUFDRSxLQUFLLEVBQUU7WUFDbkIsSUFBSSxDQUFDRixPQUFPLENBQUNFLEtBQUs7UUFDdEI7UUFDQSxJQUFJLENBQUNHLFdBQVcsR0FBRztJQUN2QjtJQUVBOzs7O0tBSUMsR0FDREMsSUFBSztRQUNELENBQUMsSUFBSSxDQUFDRCxXQUFXLElBQUksSUFBSSxDQUFDSCxLQUFLO1FBQy9CLElBQUksQ0FBQ0YsT0FBTyxDQUFDTyxLQUFLLElBQUksSUFBSSxDQUFDUCxPQUFPLENBQUNPLEtBQUs7SUFDNUM7SUFFQTs7OztLQUlDLEdBQ0RDLEtBQU07UUFDRixJQUFJLENBQUNSLE9BQU8sQ0FBQ1MsT0FBTyxJQUFJLElBQUksQ0FBQ1QsT0FBTyxDQUFDUyxPQUFPO0lBQ2hEO0lBRUE7Ozs7O0tBS0MsR0FDREMsU0FBVTtRQUNOLElBQUksQ0FBQ1YsT0FBTyxDQUFDVSxPQUFPLEdBQUcsSUFBSSxDQUFDVixPQUFPLENBQUNVLE9BQU8sS0FBSyxJQUFJLENBQUNGLEdBQUc7SUFDNUQ7SUFFQTs7Ozs7O0tBTUMsR0FDREcsUUFBUyxTQUFTQyxNQUFNO1FBQ3BCLE9BQU8sSUFBSSxDQUFDWixPQUFPLEtBQUtZLFVBQVUsSUFBSSxDQUFDWixPQUFPLENBQUNPLEtBQUssS0FBS0s7SUFDN0Q7QUFFSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9RdWVyeUhhbmRsZXIuanM/NjQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlbGVnYXRlIHRvIGhhbmRsZSBhIG1lZGlhIHF1ZXJ5IGJlaW5nIG1hdGNoZWQgYW5kIHVubWF0Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5tYXRjaCBjYWxsYmFjayBmb3Igd2hlbiB0aGUgbWVkaWEgcXVlcnkgaXMgbWF0Y2hlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudW5tYXRjaF0gY2FsbGJhY2sgZm9yIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IGlzIHVubWF0Y2hlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuc2V0dXBdIG9uZS10aW1lIGNhbGxiYWNrIHRyaWdnZXJlZCB0aGUgZmlyc3QgdGltZSBhIHF1ZXJ5IGlzIG1hdGNoZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmZXJTZXR1cD1mYWxzZV0gc2hvdWxkIHRoZSBzZXR1cCBjYWxsYmFjayBiZSBydW4gaW1tZWRpYXRlbHksIHJhdGhlciB0aGFuIGZpcnN0IHRpbWUgcXVlcnkgaXMgbWF0Y2hlZD9cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBRdWVyeUhhbmRsZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgIW9wdGlvbnMuZGVmZXJTZXR1cCAmJiB0aGlzLnNldHVwKCk7XG59XG5cblF1ZXJ5SGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IFF1ZXJ5SGFuZGxlcixcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHNldHVwIG9mIHRoZSBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXR1cCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2V0dXApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZXR1cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb29yZGluYXRlcyBzZXR1cCBhbmQgdHJpZ2dlcmluZyBvZiB0aGUgaGFuZGxlclxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgIXRoaXMuaW5pdGlhbGlzZWQgJiYgdGhpcy5zZXR1cCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWF0Y2ggJiYgdGhpcy5vcHRpb25zLm1hdGNoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHRoZSB1bm1hdGNoIGV2ZW50IGZvciB0aGUgaGFuZGxlclxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgb2ZmIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy51bm1hdGNoICYmIHRoaXMub3B0aW9ucy51bm1hdGNoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIGEgaGFuZGxlciBpcyB0byBiZSBkZXN0cm95ZWQuXG4gICAgICogZGVsZWdhdGVzIHRvIHRoZSBkZXN0cm95IG9yIHVubWF0Y2ggY2FsbGJhY2tzLCBkZXBlbmRpbmcgb24gYXZhaWxhYmlsaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZGVzdHJveSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZGVzdHJveSA/IHRoaXMub3B0aW9ucy5kZXN0cm95KCkgOiB0aGlzLm9mZigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmVzIGVxdWFsaXR5IGJ5IHJlZmVyZW5jZS5cbiAgICAgKiBpZiBvYmplY3QgaXMgc3VwcGxpZWQgY29tcGFyZSBvcHRpb25zLCBpZiBmdW5jdGlvbiwgY29tcGFyZSBtYXRjaCBjYWxsYmFja1xuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3QgfHwgZnVuY3Rpb259IFt0YXJnZXRdIHRoZSB0YXJnZXQgZm9yIGNvbXBhcmlzb25cbiAgICAgKi9cbiAgICBlcXVhbHMgOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucyA9PT0gdGFyZ2V0IHx8IHRoaXMub3B0aW9ucy5tYXRjaCA9PT0gdGFyZ2V0O1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUhhbmRsZXI7XG4iXSwibmFtZXMiOlsiUXVlcnlIYW5kbGVyIiwib3B0aW9ucyIsImRlZmVyU2V0dXAiLCJzZXR1cCIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbGlzZWQiLCJvbiIsIm1hdGNoIiwib2ZmIiwidW5tYXRjaCIsImRlc3Ryb3kiLCJlcXVhbHMiLCJ0YXJnZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/Util.js":
/*!*********************************************!*\
  !*** ./node_modules/enquire.js/src/Util.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Helper function for iterating over a collection\n *\n * @param collection\n * @param fn\n */ \nfunction each(collection, fn) {\n    var i = 0, length = collection.length, cont;\n    for(i; i < length; i++){\n        cont = fn(collection[i], i);\n        if (cont === false) {\n            break; //allow early exit\n        }\n    }\n}\n/**\n * Helper function for determining whether target object is an array\n *\n * @param target the object under test\n * @return {Boolean} true if array, false otherwise\n */ function isArray(target) {\n    return Object.prototype.toString.apply(target) === \"[object Array]\";\n}\n/**\n * Helper function for determining whether target object is a function\n *\n * @param target the object under test\n * @return {Boolean} true if function, false otherwise\n */ function isFunction(target) {\n    return typeof target === \"function\";\n}\nmodule.exports = {\n    isFunction: isFunction,\n    isArray: isArray,\n    each: each\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9VdGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDO0FBQ0QsU0FBU0EsS0FBS0MsVUFBVSxFQUFFQyxFQUFFO0lBQ3hCLElBQUlDLElBQVMsR0FDVEMsU0FBU0gsV0FBV0csTUFBTSxFQUMxQkM7SUFFSixJQUFJRixHQUFHQSxJQUFJQyxRQUFRRCxJQUFLO1FBQ3BCRSxPQUFPSCxHQUFHRCxVQUFVLENBQUNFLEVBQUUsRUFBRUE7UUFDekIsSUFBR0UsU0FBUyxPQUFPO1lBQ2YsT0FBTyxrQkFBa0I7UUFDN0I7SUFDSjtBQUNKO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyxRQUFRQyxNQUFNO0lBQ25CLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxLQUFLLENBQUNKLFlBQVk7QUFDdkQ7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNLLFdBQVdMLE1BQU07SUFDdEIsT0FBTyxPQUFPQSxXQUFXO0FBQzdCO0FBRUFNLE9BQU9DLE9BQU8sR0FBRztJQUNiRixZQUFhQTtJQUNiTixTQUFVQTtJQUNWTixNQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9VdGlsLmpzPzAxMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGl0ZXJhdGluZyBvdmVyIGEgY29sbGVjdGlvblxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gZm5cbiAqL1xuZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBmbikge1xuICAgIHZhciBpICAgICAgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgY29udDtcblxuICAgIGZvcihpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udCA9IGZuKGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgICBpZihjb250ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7IC8vYWxsb3cgZWFybHkgZXhpdFxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0YXJnZXQgb2JqZWN0IGlzIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgb2JqZWN0IHVuZGVyIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYXJyYXksIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHRhcmdldCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRhcmdldCBvYmplY3QgaXMgYSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0YXJnZXQgdGhlIG9iamVjdCB1bmRlciB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNGdW5jdGlvbiA6IGlzRnVuY3Rpb24sXG4gICAgaXNBcnJheSA6IGlzQXJyYXksXG4gICAgZWFjaCA6IGVhY2hcbn07XG4iXSwibmFtZXMiOlsiZWFjaCIsImNvbGxlY3Rpb24iLCJmbiIsImkiLCJsZW5ndGgiLCJjb250IiwiaXNBcnJheSIsInRhcmdldCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYXBwbHkiLCJpc0Z1bmN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/Util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/enquire.js/src/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar MediaQueryDispatch = __webpack_require__(/*! ./MediaQueryDispatch */ \"(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js\");\nmodule.exports = new MediaQueryDispatch();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEscUJBQXFCQyxtQkFBT0EsQ0FBQztBQUNqQ0MsT0FBT0MsT0FBTyxHQUFHLElBQUlIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9pbmRleC5qcz83YjFiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBNZWRpYVF1ZXJ5RGlzcGF0Y2ggPSByZXF1aXJlKCcuL01lZGlhUXVlcnlEaXNwYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgTWVkaWFRdWVyeURpc3BhdGNoKCk7XG4iXSwibmFtZXMiOlsiTWVkaWFRdWVyeURpc3BhdGNoIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/json2mq/index.js":
/*!***************************************!*\
  !*** ./node_modules/json2mq/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar camel2hyphen = __webpack_require__(/*! string-convert/camel2hyphen */ \"(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js\");\nvar isDimension = function(feature) {\n    var re = /[height|width]$/;\n    return re.test(feature);\n};\nvar obj2mq = function(obj) {\n    var mq = \"\";\n    var features = Object.keys(obj);\n    features.forEach(function(feature, index) {\n        var value = obj[feature];\n        feature = camel2hyphen(feature);\n        // Add px to dimension features\n        if (isDimension(feature) && typeof value === \"number\") {\n            value = value + \"px\";\n        }\n        if (value === true) {\n            mq += feature;\n        } else if (value === false) {\n            mq += \"not \" + feature;\n        } else {\n            mq += \"(\" + feature + \": \" + value + \")\";\n        }\n        if (index < features.length - 1) {\n            mq += \" and \";\n        }\n    });\n    return mq;\n};\nvar json2mq = function(query) {\n    var mq = \"\";\n    if (typeof query === \"string\") {\n        return query;\n    }\n    // Handling array of media queries\n    if (query instanceof Array) {\n        query.forEach(function(q, index) {\n            mq += obj2mq(q);\n            if (index < query.length - 1) {\n                mq += \", \";\n            }\n        });\n        return mq;\n    }\n    // Handling single media query\n    return obj2mq(query);\n};\nmodule.exports = json2mq;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc29uMm1xL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUUzQixJQUFJQyxjQUFjLFNBQVVDLE9BQU87SUFDakMsSUFBSUMsS0FBSztJQUNULE9BQU9BLEdBQUdDLElBQUksQ0FBQ0Y7QUFDakI7QUFFQSxJQUFJRyxTQUFTLFNBQVVDLEdBQUc7SUFDeEIsSUFBSUMsS0FBSztJQUNULElBQUlDLFdBQVdDLE9BQU9DLElBQUksQ0FBQ0o7SUFDM0JFLFNBQVNHLE9BQU8sQ0FBQyxTQUFVVCxPQUFPLEVBQUVVLEtBQUs7UUFDdkMsSUFBSUMsUUFBUVAsR0FBRyxDQUFDSixRQUFRO1FBQ3hCQSxVQUFVSCxhQUFhRztRQUN2QiwrQkFBK0I7UUFDL0IsSUFBSUQsWUFBWUMsWUFBWSxPQUFPVyxVQUFVLFVBQVU7WUFDckRBLFFBQVFBLFFBQVE7UUFDbEI7UUFDQSxJQUFJQSxVQUFVLE1BQU07WUFDbEJOLE1BQU1MO1FBQ1IsT0FBTyxJQUFJVyxVQUFVLE9BQU87WUFDMUJOLE1BQU0sU0FBU0w7UUFDakIsT0FBTztZQUNMSyxNQUFNLE1BQU1MLFVBQVUsT0FBT1csUUFBUTtRQUN2QztRQUNBLElBQUlELFFBQVFKLFNBQVNNLE1BQU0sR0FBQyxHQUFHO1lBQzdCUCxNQUFNO1FBQ1I7SUFDRjtJQUNBLE9BQU9BO0FBQ1Q7QUFFQSxJQUFJUSxVQUFVLFNBQVVDLEtBQUs7SUFDM0IsSUFBSVQsS0FBSztJQUNULElBQUksT0FBT1MsVUFBVSxVQUFVO1FBQzdCLE9BQU9BO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUEsaUJBQWlCQyxPQUFPO1FBQzFCRCxNQUFNTCxPQUFPLENBQUMsU0FBVU8sQ0FBQyxFQUFFTixLQUFLO1lBQzlCTCxNQUFNRixPQUFPYTtZQUNiLElBQUlOLFFBQVFJLE1BQU1GLE1BQU0sR0FBQyxHQUFHO2dCQUMxQlAsTUFBTTtZQUNSO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsOEJBQThCO0lBQzlCLE9BQU9GLE9BQU9XO0FBQ2hCO0FBRUFHLE9BQU9DLE9BQU8sR0FBR0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pzb24ybXEvaW5kZXguanM/YTRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2FtZWwyaHlwaGVuID0gcmVxdWlyZSgnc3RyaW5nLWNvbnZlcnQvY2FtZWwyaHlwaGVuJyk7XG5cbnZhciBpc0RpbWVuc2lvbiA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gIHZhciByZSA9IC9baGVpZ2h0fHdpZHRoXSQvO1xuICByZXR1cm4gcmUudGVzdChmZWF0dXJlKTtcbn07XG5cbnZhciBvYmoybXEgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBtcSA9ICcnO1xuICB2YXIgZmVhdHVyZXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtmZWF0dXJlXTtcbiAgICBmZWF0dXJlID0gY2FtZWwyaHlwaGVuKGZlYXR1cmUpO1xuICAgIC8vIEFkZCBweCB0byBkaW1lbnNpb24gZmVhdHVyZXNcbiAgICBpZiAoaXNEaW1lbnNpb24oZmVhdHVyZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgbXEgKz0gZmVhdHVyZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgbXEgKz0gJ25vdCAnICsgZmVhdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXEgKz0gJygnICsgZmVhdHVyZSArICc6ICcgKyB2YWx1ZSArICcpJztcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgZmVhdHVyZXMubGVuZ3RoLTEpIHtcbiAgICAgIG1xICs9ICcgYW5kICdcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbXE7XG59O1xuXG52YXIganNvbjJtcSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICB2YXIgbXEgPSAnJztcbiAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgLy8gSGFuZGxpbmcgYXJyYXkgb2YgbWVkaWEgcXVlcmllc1xuICBpZiAocXVlcnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKHEsIGluZGV4KSB7XG4gICAgICBtcSArPSBvYmoybXEocSk7XG4gICAgICBpZiAoaW5kZXggPCBxdWVyeS5sZW5ndGgtMSkge1xuICAgICAgICBtcSArPSAnLCAnXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1xO1xuICB9XG4gIC8vIEhhbmRsaW5nIHNpbmdsZSBtZWRpYSBxdWVyeVxuICByZXR1cm4gb2JqMm1xKHF1ZXJ5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbjJtcTsiXSwibmFtZXMiOlsiY2FtZWwyaHlwaGVuIiwicmVxdWlyZSIsImlzRGltZW5zaW9uIiwiZmVhdHVyZSIsInJlIiwidGVzdCIsIm9iajJtcSIsIm9iaiIsIm1xIiwiZmVhdHVyZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImluZGV4IiwidmFsdWUiLCJsZW5ndGgiLCJqc29uMm1xIiwicXVlcnkiLCJBcnJheSIsInEiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/json2mq/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */ /** Used as the `TypeError` message for \"Functions\" methods. */ \nvar FUNC_ERROR_TEXT = \"Expected a function\";\n/** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n/** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n/** Used to match leading and trailing whitespace. */ var reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof __webpack_require__.g == \"object\" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n/** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function(\"return this\")();\n/** Used for built-in method references. */ var objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */ var now = function() {\n    return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */ function debounce(func, wait, options) {\n    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n    if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    wait = toNumber(wait) || 0;\n    if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n    }\n    function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n    }\n    function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function isObject(value) {\n    var type = typeof value;\n    return !!value && (type == \"object\" || type == \"function\");\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function isObjectLike(value) {\n    return !!value && typeof value == \"object\";\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol(value) {\n    return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */ function toNumber(value) {\n    if (typeof value == \"number\") {\n        return value;\n    }\n    if (isSymbol(value)) {\n        return NAN;\n    }\n    if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n    }\n    if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n    }\n    value = value.replace(reTrim, \"\");\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQyxHQUVELDZEQUE2RDtBQUM3RCxJQUFJQSxrQkFBa0I7QUFFdEIsdURBQXVELEdBQ3ZELElBQUlDLE1BQU0sSUFBSTtBQUVkLHlDQUF5QyxHQUN6QyxJQUFJQyxZQUFZO0FBRWhCLG1EQUFtRCxHQUNuRCxJQUFJQyxTQUFTO0FBRWIseURBQXlELEdBQ3pELElBQUlDLGFBQWE7QUFFakIseUNBQXlDLEdBQ3pDLElBQUlDLGFBQWE7QUFFakIsd0NBQXdDLEdBQ3hDLElBQUlDLFlBQVk7QUFFaEIsK0RBQStELEdBQy9ELElBQUlDLGVBQWVDO0FBRW5CLGdEQUFnRCxHQUNoRCxJQUFJQyxhQUFhLE9BQU9DLHFCQUFNQSxJQUFJLFlBQVlBLHFCQUFNQSxJQUFJQSxxQkFBTUEsQ0FBQ0MsTUFBTSxLQUFLQSxVQUFVRCxxQkFBTUE7QUFFMUYsaUNBQWlDLEdBQ2pDLElBQUlFLFdBQVcsT0FBT0MsUUFBUSxZQUFZQSxRQUFRQSxLQUFLRixNQUFNLEtBQUtBLFVBQVVFO0FBRTVFLDhDQUE4QyxHQUM5QyxJQUFJQyxPQUFPTCxjQUFjRyxZQUFZRyxTQUFTO0FBRTlDLHlDQUF5QyxHQUN6QyxJQUFJQyxjQUFjTCxPQUFPTSxTQUFTO0FBRWxDOzs7O0NBSUMsR0FDRCxJQUFJQyxpQkFBaUJGLFlBQVlHLFFBQVE7QUFFekMsc0ZBQXNGLEdBQ3RGLElBQUlDLFlBQVlDLEtBQUtDLEdBQUcsRUFDcEJDLFlBQVlGLEtBQUtHLEdBQUc7QUFFeEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsSUFBSUMsTUFBTTtJQUNSLE9BQU9YLEtBQUtZLElBQUksQ0FBQ0QsR0FBRztBQUN0QjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFEQyxHQUNELFNBQVNFLFNBQVNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPO0lBQ25DLElBQUlDLFVBQ0FDLFVBQ0FDLFNBQ0FDLFFBQ0FDLFNBQ0FDLGNBQ0FDLGlCQUFpQixHQUNqQkMsVUFBVSxPQUNWQyxTQUFTLE9BQ1RDLFdBQVc7SUFFZixJQUFJLE9BQU9aLFFBQVEsWUFBWTtRQUM3QixNQUFNLElBQUlhLFVBQVV6QztJQUN0QjtJQUNBNkIsT0FBT2EsU0FBU2IsU0FBUztJQUN6QixJQUFJYyxTQUFTYixVQUFVO1FBQ3JCUSxVQUFVLENBQUMsQ0FBQ1IsUUFBUVEsT0FBTztRQUMzQkMsU0FBUyxhQUFhVDtRQUN0QkcsVUFBVU0sU0FBU25CLFVBQVVzQixTQUFTWixRQUFRRyxPQUFPLEtBQUssR0FBR0osUUFBUUk7UUFDckVPLFdBQVcsY0FBY1YsVUFBVSxDQUFDLENBQUNBLFFBQVFVLFFBQVEsR0FBR0E7SUFDMUQ7SUFFQSxTQUFTSSxXQUFXQyxJQUFJO1FBQ3RCLElBQUlDLE9BQU9mLFVBQ1BnQixVQUFVZjtRQUVkRCxXQUFXQyxXQUFXZ0I7UUFDdEJYLGlCQUFpQlE7UUFDakJYLFNBQVNOLEtBQUtxQixLQUFLLENBQUNGLFNBQVNEO1FBQzdCLE9BQU9aO0lBQ1Q7SUFFQSxTQUFTZ0IsWUFBWUwsSUFBSTtRQUN2Qiw2QkFBNkI7UUFDN0JSLGlCQUFpQlE7UUFDakIseUNBQXlDO1FBQ3pDVixVQUFVZ0IsV0FBV0MsY0FBY3ZCO1FBQ25DLDJCQUEyQjtRQUMzQixPQUFPUyxVQUFVTSxXQUFXQyxRQUFRWDtJQUN0QztJQUVBLFNBQVNtQixjQUFjUixJQUFJO1FBQ3pCLElBQUlTLG9CQUFvQlQsT0FBT1QsY0FDM0JtQixzQkFBc0JWLE9BQU9SLGdCQUM3QkgsU0FBU0wsT0FBT3lCO1FBRXBCLE9BQU9mLFNBQVNoQixVQUFVVyxRQUFRRCxVQUFVc0IsdUJBQXVCckI7SUFDckU7SUFFQSxTQUFTc0IsYUFBYVgsSUFBSTtRQUN4QixJQUFJUyxvQkFBb0JULE9BQU9ULGNBQzNCbUIsc0JBQXNCVixPQUFPUjtRQUVqQyx1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLDZEQUE2RDtRQUM3RCxPQUFRRCxpQkFBaUJZLGFBQWNNLHFCQUFxQnpCLFFBQ3pEeUIsb0JBQW9CLEtBQU9mLFVBQVVnQix1QkFBdUJ0QjtJQUNqRTtJQUVBLFNBQVNtQjtRQUNQLElBQUlQLE9BQU9wQjtRQUNYLElBQUkrQixhQUFhWCxPQUFPO1lBQ3RCLE9BQU9ZLGFBQWFaO1FBQ3RCO1FBQ0EscUJBQXFCO1FBQ3JCVixVQUFVZ0IsV0FBV0MsY0FBY0MsY0FBY1I7SUFDbkQ7SUFFQSxTQUFTWSxhQUFhWixJQUFJO1FBQ3hCVixVQUFVYTtRQUVWLGdFQUFnRTtRQUNoRSwyQkFBMkI7UUFDM0IsSUFBSVIsWUFBWVQsVUFBVTtZQUN4QixPQUFPYSxXQUFXQztRQUNwQjtRQUNBZCxXQUFXQyxXQUFXZ0I7UUFDdEIsT0FBT2Q7SUFDVDtJQUVBLFNBQVN3QjtRQUNQLElBQUl2QixZQUFZYSxXQUFXO1lBQ3pCVyxhQUFheEI7UUFDZjtRQUNBRSxpQkFBaUI7UUFDakJOLFdBQVdLLGVBQWVKLFdBQVdHLFVBQVVhO0lBQ2pEO0lBRUEsU0FBU1k7UUFDUCxPQUFPekIsWUFBWWEsWUFBWWQsU0FBU3VCLGFBQWFoQztJQUN2RDtJQUVBLFNBQVNvQztRQUNQLElBQUloQixPQUFPcEIsT0FDUHFDLGFBQWFOLGFBQWFYO1FBRTlCZCxXQUFXZ0M7UUFDWC9CLFdBQVcsSUFBSTtRQUNmSSxlQUFlUztRQUVmLElBQUlpQixZQUFZO1lBQ2QsSUFBSTNCLFlBQVlhLFdBQVc7Z0JBQ3pCLE9BQU9FLFlBQVlkO1lBQ3JCO1lBQ0EsSUFBSUcsUUFBUTtnQkFDVixzQ0FBc0M7Z0JBQ3RDSixVQUFVZ0IsV0FBV0MsY0FBY3ZCO2dCQUNuQyxPQUFPZSxXQUFXUjtZQUNwQjtRQUNGO1FBQ0EsSUFBSUQsWUFBWWEsV0FBVztZQUN6QmIsVUFBVWdCLFdBQVdDLGNBQWN2QjtRQUNyQztRQUNBLE9BQU9LO0lBQ1Q7SUFDQTJCLFVBQVVILE1BQU0sR0FBR0E7SUFDbkJHLFVBQVVELEtBQUssR0FBR0E7SUFDbEIsT0FBT0M7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDRCxTQUFTbEIsU0FBU3FCLEtBQUs7SUFDckIsSUFBSUMsT0FBTyxPQUFPRDtJQUNsQixPQUFPLENBQUMsQ0FBQ0EsU0FBVUMsQ0FBQUEsUUFBUSxZQUFZQSxRQUFRLFVBQVM7QUFDMUQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTQyxhQUFhRixLQUFLO0lBQ3pCLE9BQU8sQ0FBQyxDQUFDQSxTQUFTLE9BQU9BLFNBQVM7QUFDcEM7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELFNBQVNHLFNBQVNILEtBQUs7SUFDckIsT0FBTyxPQUFPQSxTQUFTLFlBQ3BCRSxhQUFhRixVQUFVOUMsZUFBZWtELElBQUksQ0FBQ0osVUFBVTlEO0FBQzFEO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTd0MsU0FBU3NCLEtBQUs7SUFDckIsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsT0FBT0E7SUFDVDtJQUNBLElBQUlHLFNBQVNILFFBQVE7UUFDbkIsT0FBTy9EO0lBQ1Q7SUFDQSxJQUFJMEMsU0FBU3FCLFFBQVE7UUFDbkIsSUFBSUssUUFBUSxPQUFPTCxNQUFNTSxPQUFPLElBQUksYUFBYU4sTUFBTU0sT0FBTyxLQUFLTjtRQUNuRUEsUUFBUXJCLFNBQVMwQixTQUFVQSxRQUFRLEtBQU1BO0lBQzNDO0lBQ0EsSUFBSSxPQUFPTCxTQUFTLFVBQVU7UUFDNUIsT0FBT0EsVUFBVSxJQUFJQSxRQUFRLENBQUNBO0lBQ2hDO0lBQ0FBLFFBQVFBLE1BQU1PLE9BQU8sQ0FBQ3BFLFFBQVE7SUFDOUIsSUFBSXFFLFdBQVduRSxXQUFXb0UsSUFBSSxDQUFDVDtJQUMvQixPQUFPLFlBQWExRCxVQUFVbUUsSUFBSSxDQUFDVCxTQUMvQnpELGFBQWF5RCxNQUFNVSxLQUFLLENBQUMsSUFBSUYsV0FBVyxJQUFJLEtBQzNDcEUsV0FBV3FFLElBQUksQ0FBQ1QsU0FBUy9ELE1BQU0sQ0FBQytEO0FBQ3ZDO0FBRUFXLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanM/ODlhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibmFtZXMiOlsiRlVOQ19FUlJPUl9URVhUIiwiTkFOIiwic3ltYm9sVGFnIiwicmVUcmltIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJmcmVlUGFyc2VJbnQiLCJwYXJzZUludCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJPYmplY3QiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsIm9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJuYXRpdmVNYXgiLCJNYXRoIiwibWF4IiwibmF0aXZlTWluIiwibWluIiwibm93IiwiRGF0ZSIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJvcHRpb25zIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJyZXN1bHQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJUeXBlRXJyb3IiLCJ0b051bWJlciIsImlzT2JqZWN0IiwiaW52b2tlRnVuYyIsInRpbWUiLCJhcmdzIiwidGhpc0FyZyIsInVuZGVmaW5lZCIsImFwcGx5IiwibGVhZGluZ0VkZ2UiLCJzZXRUaW1lb3V0IiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImNsZWFyVGltZW91dCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImFyZ3VtZW50cyIsInZhbHVlIiwidHlwZSIsImlzT2JqZWN0TGlrZSIsImlzU3ltYm9sIiwiY2FsbCIsIm90aGVyIiwidmFsdWVPZiIsInJlcGxhY2UiLCJpc0JpbmFyeSIsInRlc3QiLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lodash.debounce/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/*!********************************************!*\
  !*** ./node_modules/next/dist/api/link.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=link.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1YsQ0FFL0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/MTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n //# sourceMappingURL=navigation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdELENBRWhELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzFkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pusher-js/dist/web/pusher.js":
/*!***************************************************!*\
  !*** ./node_modules/pusher-js/dist/web/pusher.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*!\n * Pusher JavaScript Library v8.4.0-rc2\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(window, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_704__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_704__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_704__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_704__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_704__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_704__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_704__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_704__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_704__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_704__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_704__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_704__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_704__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_704__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_704__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_704__(__nested_webpack_require_704__.s = 2);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Copyright (C) 2016 Dmitry Chestnykh\n            // MIT License. See LICENSE file for details.\n            var __extends = this && this.__extends || function() {\n                var extendStatics = function(d, b) {\n                    extendStatics = Object.setPrototypeOf || ({\n                        __proto__: []\n                    }) instanceof Array && function(d, b) {\n                        d.__proto__ = b;\n                    } || function(d, b) {\n                        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                    };\n                    return extendStatics(d, b);\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            /**\n * Package base64 implements Base64 encoding and decoding.\n */ // Invalid character used in decoding to indicate\n            // that the character to decode is out of range of\n            // alphabet and cannot be decoded.\n            var INVALID_BYTE = 256;\n            /**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */ var Coder = /** @class */ function() {\n                // TODO(dchest): methods to encode chunk-by-chunk.\n                function Coder(_paddingCharacter) {\n                    if (_paddingCharacter === void 0) {\n                        _paddingCharacter = \"=\";\n                    }\n                    this._paddingCharacter = _paddingCharacter;\n                }\n                Coder.prototype.encodedLength = function(length) {\n                    if (!this._paddingCharacter) {\n                        return (length * 8 + 5) / 6 | 0;\n                    }\n                    return (length + 2) / 3 * 4 | 0;\n                };\n                Coder.prototype.encode = function(data) {\n                    var out = \"\";\n                    var i = 0;\n                    for(; i < data.length - 2; i += 3){\n                        var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];\n                        out += this._encodeByte(c >>> 3 * 6 & 63);\n                        out += this._encodeByte(c >>> 2 * 6 & 63);\n                        out += this._encodeByte(c >>> 1 * 6 & 63);\n                        out += this._encodeByte(c >>> 0 * 6 & 63);\n                    }\n                    var left = data.length - i;\n                    if (left > 0) {\n                        var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);\n                        out += this._encodeByte(c >>> 3 * 6 & 63);\n                        out += this._encodeByte(c >>> 2 * 6 & 63);\n                        if (left === 2) {\n                            out += this._encodeByte(c >>> 1 * 6 & 63);\n                        } else {\n                            out += this._paddingCharacter || \"\";\n                        }\n                        out += this._paddingCharacter || \"\";\n                    }\n                    return out;\n                };\n                Coder.prototype.maxDecodedLength = function(length) {\n                    if (!this._paddingCharacter) {\n                        return (length * 6 + 7) / 8 | 0;\n                    }\n                    return length / 4 * 3 | 0;\n                };\n                Coder.prototype.decodedLength = function(s) {\n                    return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n                };\n                Coder.prototype.decode = function(s) {\n                    if (s.length === 0) {\n                        return new Uint8Array(0);\n                    }\n                    var paddingLength = this._getPaddingLength(s);\n                    var length = s.length - paddingLength;\n                    var out = new Uint8Array(this.maxDecodedLength(length));\n                    var op = 0;\n                    var i = 0;\n                    var haveBad = 0;\n                    var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n                    for(; i < length - 4; i += 4){\n                        v0 = this._decodeChar(s.charCodeAt(i + 0));\n                        v1 = this._decodeChar(s.charCodeAt(i + 1));\n                        v2 = this._decodeChar(s.charCodeAt(i + 2));\n                        v3 = this._decodeChar(s.charCodeAt(i + 3));\n                        out[op++] = v0 << 2 | v1 >>> 4;\n                        out[op++] = v1 << 4 | v2 >>> 2;\n                        out[op++] = v2 << 6 | v3;\n                        haveBad |= v0 & INVALID_BYTE;\n                        haveBad |= v1 & INVALID_BYTE;\n                        haveBad |= v2 & INVALID_BYTE;\n                        haveBad |= v3 & INVALID_BYTE;\n                    }\n                    if (i < length - 1) {\n                        v0 = this._decodeChar(s.charCodeAt(i));\n                        v1 = this._decodeChar(s.charCodeAt(i + 1));\n                        out[op++] = v0 << 2 | v1 >>> 4;\n                        haveBad |= v0 & INVALID_BYTE;\n                        haveBad |= v1 & INVALID_BYTE;\n                    }\n                    if (i < length - 2) {\n                        v2 = this._decodeChar(s.charCodeAt(i + 2));\n                        out[op++] = v1 << 4 | v2 >>> 2;\n                        haveBad |= v2 & INVALID_BYTE;\n                    }\n                    if (i < length - 3) {\n                        v3 = this._decodeChar(s.charCodeAt(i + 3));\n                        out[op++] = v2 << 6 | v3;\n                        haveBad |= v3 & INVALID_BYTE;\n                    }\n                    if (haveBad !== 0) {\n                        throw new Error(\"Base64Coder: incorrect characters for decoding\");\n                    }\n                    return out;\n                };\n                // Standard encoding have the following encoded/decoded ranges,\n                // which we need to convert between.\n                //\n                // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n                // Index:   0 - 25                    26 - 51              52 - 61   62  63\n                // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n                //\n                // Encode 6 bits in b into a new character.\n                Coder.prototype._encodeByte = function(b) {\n                    // Encoding uses constant time operations as follows:\n                    //\n                    // 1. Define comparison of A with B using (A - B) >>> 8:\n                    //          if A > B, then result is positive integer\n                    //          if A <= B, then result is 0\n                    //\n                    // 2. Define selection of C or 0 using bitwise AND: X & C:\n                    //          if X == 0, then result is 0\n                    //          if X != 0, then result is C\n                    //\n                    // 3. Start with the smallest comparison (b >= 0), which is always\n                    //    true, so set the result to the starting ASCII value (65).\n                    //\n                    // 4. Continue comparing b to higher ASCII values, and selecting\n                    //    zero if comparison isn't true, otherwise selecting a value\n                    //    to add to result, which:\n                    //\n                    //          a) undoes the previous addition\n                    //          b) provides new value to add\n                    //\n                    var result = b;\n                    // b >= 0\n                    result += 65;\n                    // b > 25\n                    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                    // b > 51\n                    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                    // b > 61\n                    result += 61 - b >>> 8 & 52 - 48 - 62 + 43;\n                    // b > 62\n                    result += 62 - b >>> 8 & 62 - 43 - 63 + 47;\n                    return String.fromCharCode(result);\n                };\n                // Decode a character code into a byte.\n                // Must return 256 if character is out of alphabet range.\n                Coder.prototype._decodeChar = function(c) {\n                    // Decoding works similar to encoding: using the same comparison\n                    // function, but now it works on ranges: result is always incremented\n                    // by value, but this value becomes zero if the range is not\n                    // satisfied.\n                    //\n                    // Decoding starts with invalid value, 256, which is then\n                    // subtracted when the range is satisfied. If none of the ranges\n                    // apply, the function returns 256, which is then checked by\n                    // the caller to throw error.\n                    var result = INVALID_BYTE; // start with invalid character\n                    // c == 43 (c > 42 and c < 44)\n                    result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;\n                    // c == 47 (c > 46 and c < 48)\n                    result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;\n                    // c > 47 and c < 58\n                    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                    // c > 64 and c < 91\n                    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                    // c > 96 and c < 123\n                    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                    return result;\n                };\n                Coder.prototype._getPaddingLength = function(s) {\n                    var paddingLength = 0;\n                    if (this._paddingCharacter) {\n                        for(var i = s.length - 1; i >= 0; i--){\n                            if (s[i] !== this._paddingCharacter) {\n                                break;\n                            }\n                            paddingLength++;\n                        }\n                        if (s.length < 4 || paddingLength > 2) {\n                            throw new Error(\"Base64Coder: incorrect padding\");\n                        }\n                    }\n                    return paddingLength;\n                };\n                return Coder;\n            }();\n            exports1.Coder = Coder;\n            var stdCoder = new Coder();\n            function encode(data) {\n                return stdCoder.encode(data);\n            }\n            exports1.encode = encode;\n            function decode(s) {\n                return stdCoder.decode(s);\n            }\n            exports1.decode = decode;\n            /**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */ var URLSafeCoder = /** @class */ function(_super) {\n                __extends(URLSafeCoder, _super);\n                function URLSafeCoder() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                // URL-safe encoding have the following encoded/decoded ranges:\n                //\n                // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n                // Index:   0 - 25                    26 - 51              52 - 61   62  63\n                // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n                //\n                URLSafeCoder.prototype._encodeByte = function(b) {\n                    var result = b;\n                    // b >= 0\n                    result += 65;\n                    // b > 25\n                    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                    // b > 51\n                    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                    // b > 61\n                    result += 61 - b >>> 8 & 52 - 48 - 62 + 45;\n                    // b > 62\n                    result += 62 - b >>> 8 & 62 - 45 - 63 + 95;\n                    return String.fromCharCode(result);\n                };\n                URLSafeCoder.prototype._decodeChar = function(c) {\n                    var result = INVALID_BYTE;\n                    // c == 45 (c > 44 and c < 46)\n                    result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;\n                    // c == 95 (c > 94 and c < 96)\n                    result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;\n                    // c > 47 and c < 58\n                    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                    // c > 64 and c < 91\n                    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                    // c > 96 and c < 123\n                    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                    return result;\n                };\n                return URLSafeCoder;\n            }(Coder);\n            exports1.URLSafeCoder = URLSafeCoder;\n            var urlSafeCoder = new URLSafeCoder();\n            function encodeURLSafe(data) {\n                return urlSafeCoder.encode(data);\n            }\n            exports1.encodeURLSafe = encodeURLSafe;\n            function decodeURLSafe(s) {\n                return urlSafeCoder.decode(s);\n            }\n            exports1.decodeURLSafe = decodeURLSafe;\n            exports1.encodedLength = function(length) {\n                return stdCoder.encodedLength(length);\n            };\n            exports1.maxDecodedLength = function(length) {\n                return stdCoder.maxDecodedLength(length);\n            };\n            exports1.decodedLength = function(s) {\n                return stdCoder.decodedLength(s);\n            };\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Copyright (C) 2016 Dmitry Chestnykh\n            // MIT License. See LICENSE file for details.\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            /**\n * Package utf8 implements UTF-8 encoding and decoding.\n */ var INVALID_UTF16 = \"utf8: invalid string\";\n            var INVALID_UTF8 = \"utf8: invalid source encoding\";\n            /**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encode(s) {\n                // Calculate result length and allocate output array.\n                // encodedLength() also validates string and throws errors,\n                // so we don't need repeat validation here.\n                var arr = new Uint8Array(encodedLength(s));\n                var pos = 0;\n                for(var i = 0; i < s.length; i++){\n                    var c = s.charCodeAt(i);\n                    if (c < 0x80) {\n                        arr[pos++] = c;\n                    } else if (c < 0x800) {\n                        arr[pos++] = 0xc0 | c >> 6;\n                        arr[pos++] = 0x80 | c & 0x3f;\n                    } else if (c < 0xd800) {\n                        arr[pos++] = 0xe0 | c >> 12;\n                        arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                        arr[pos++] = 0x80 | c & 0x3f;\n                    } else {\n                        i++; // get one more character\n                        c = (c & 0x3ff) << 10;\n                        c |= s.charCodeAt(i) & 0x3ff;\n                        c += 0x10000;\n                        arr[pos++] = 0xf0 | c >> 18;\n                        arr[pos++] = 0x80 | c >> 12 & 0x3f;\n                        arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                        arr[pos++] = 0x80 | c & 0x3f;\n                    }\n                }\n                return arr;\n            }\n            exports1.encode = encode;\n            /**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encodedLength(s) {\n                var result = 0;\n                for(var i = 0; i < s.length; i++){\n                    var c = s.charCodeAt(i);\n                    if (c < 0x80) {\n                        result += 1;\n                    } else if (c < 0x800) {\n                        result += 2;\n                    } else if (c < 0xd800) {\n                        result += 3;\n                    } else if (c <= 0xdfff) {\n                        if (i >= s.length - 1) {\n                            throw new Error(INVALID_UTF16);\n                        }\n                        i++; // \"eat\" next character\n                        result += 4;\n                    } else {\n                        throw new Error(INVALID_UTF16);\n                    }\n                }\n                return result;\n            }\n            exports1.encodedLength = encodedLength;\n            /**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */ function decode(arr) {\n                var chars = [];\n                for(var i = 0; i < arr.length; i++){\n                    var b = arr[i];\n                    if (b & 0x80) {\n                        var min = void 0;\n                        if (b < 0xe0) {\n                            // Need 1 more byte.\n                            if (i >= arr.length) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            var n1 = arr[++i];\n                            if ((n1 & 0xc0) !== 0x80) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            b = (b & 0x1f) << 6 | n1 & 0x3f;\n                            min = 0x80;\n                        } else if (b < 0xf0) {\n                            // Need 2 more bytes.\n                            if (i >= arr.length - 1) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            var n1 = arr[++i];\n                            var n2 = arr[++i];\n                            if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | n2 & 0x3f;\n                            min = 0x800;\n                        } else if (b < 0xf8) {\n                            // Need 3 more bytes.\n                            if (i >= arr.length - 2) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            var n1 = arr[++i];\n                            var n2 = arr[++i];\n                            var n3 = arr[++i];\n                            if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | n3 & 0x3f;\n                            min = 0x10000;\n                        } else {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        if (b < min || b >= 0xd800 && b <= 0xdfff) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        if (b >= 0x10000) {\n                            // Surrogate pair.\n                            if (b > 0x10ffff) {\n                                throw new Error(INVALID_UTF8);\n                            }\n                            b -= 0x10000;\n                            chars.push(String.fromCharCode(0xd800 | b >> 10));\n                            b = 0xdc00 | b & 0x3ff;\n                        }\n                    }\n                    chars.push(String.fromCharCode(b));\n                }\n                return chars.join(\"\");\n            }\n            exports1.decode = decode;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_25270__) {\n            // required so we don't have to do require('pusher').default etc.\n            module1.exports = __nested_webpack_require_25270__(3).default;\n        /***/ },\n        /* 3 */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_25511__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_25511__.r(__nested_webpack_exports__);\n            // CONCATENATED MODULE: ./src/runtimes/web/dom/script_receiver_factory.ts\n            class ScriptReceiverFactory {\n                create(callback) {\n                    this.lastId++;\n                    var number = this.lastId;\n                    var id = this.prefix + number;\n                    var name = this.name + \"[\" + number + \"]\";\n                    var called = false;\n                    var callbackWrapper = function() {\n                        if (!called) {\n                            callback.apply(null, arguments);\n                            called = true;\n                        }\n                    };\n                    this[number] = callbackWrapper;\n                    return {\n                        number: number,\n                        id: id,\n                        name: name,\n                        callback: callbackWrapper\n                    };\n                }\n                remove(receiver) {\n                    delete this[receiver.number];\n                }\n                constructor(prefix, name){\n                    this.lastId = 0;\n                    this.prefix = prefix;\n                    this.name = name;\n                }\n            }\n            var ScriptReceivers = new ScriptReceiverFactory(\"_pusher_script_\", \"Pusher.ScriptReceivers\");\n            // CONCATENATED MODULE: ./src/core/defaults.ts\n            var Defaults = {\n                VERSION: \"8.4.0-rc2\",\n                PROTOCOL: 7,\n                wsPort: 80,\n                wssPort: 443,\n                wsPath: \"\",\n                httpHost: \"sockjs.pusher.com\",\n                httpPort: 80,\n                httpsPort: 443,\n                httpPath: \"/pusher\",\n                stats_host: \"stats.pusher.com\",\n                authEndpoint: \"/pusher/auth\",\n                authTransport: \"ajax\",\n                activityTimeout: 120000,\n                pongTimeout: 30000,\n                unavailableTimeout: 10000,\n                userAuthentication: {\n                    endpoint: \"/pusher/user-auth\",\n                    transport: \"ajax\"\n                },\n                channelAuthorization: {\n                    endpoint: \"/pusher/auth\",\n                    transport: \"ajax\"\n                },\n                cdn_http: \"http://js.pusher.com\",\n                cdn_https: \"https://js.pusher.com\",\n                dependency_suffix: \"\"\n            };\n            /* harmony default export */ var defaults = Defaults;\n            // CONCATENATED MODULE: ./src/runtimes/web/dom/dependency_loader.ts\n            class dependency_loader_DependencyLoader {\n                load(name, options, callback) {\n                    var self = this;\n                    if (self.loading[name] && self.loading[name].length > 0) {\n                        self.loading[name].push(callback);\n                    } else {\n                        self.loading[name] = [\n                            callback\n                        ];\n                        var request = runtime.createScriptRequest(self.getPath(name, options));\n                        var receiver = self.receivers.create(function(error) {\n                            self.receivers.remove(receiver);\n                            if (self.loading[name]) {\n                                var callbacks = self.loading[name];\n                                delete self.loading[name];\n                                var successCallback = function(wasSuccessful) {\n                                    if (!wasSuccessful) {\n                                        request.cleanup();\n                                    }\n                                };\n                                for(var i = 0; i < callbacks.length; i++){\n                                    callbacks[i](error, successCallback);\n                                }\n                            }\n                        });\n                        request.send(receiver);\n                    }\n                }\n                getRoot(options) {\n                    var cdn;\n                    var protocol = runtime.getDocument().location.protocol;\n                    if (options && options.useTLS || protocol === \"https:\") {\n                        cdn = this.options.cdn_https;\n                    } else {\n                        cdn = this.options.cdn_http;\n                    }\n                    return cdn.replace(/\\/*$/, \"\") + \"/\" + this.options.version;\n                }\n                getPath(name, options) {\n                    return this.getRoot(options) + \"/\" + name + this.options.suffix + \".js\";\n                }\n                constructor(options){\n                    this.options = options;\n                    this.receivers = options.receivers || ScriptReceivers;\n                    this.loading = {};\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/web/dom/dependencies.ts\n            var DependenciesReceivers = new ScriptReceiverFactory(\"_pusher_dependencies\", \"Pusher.DependenciesReceivers\");\n            var Dependencies = new dependency_loader_DependencyLoader({\n                cdn_http: defaults.cdn_http,\n                cdn_https: defaults.cdn_https,\n                version: defaults.VERSION,\n                suffix: defaults.dependency_suffix,\n                receivers: DependenciesReceivers\n            });\n            // CONCATENATED MODULE: ./src/core/utils/url_store.ts\n            const urlStore = {\n                baseUrl: \"https://pusher.com\",\n                urls: {\n                    authenticationEndpoint: {\n                        path: \"/docs/channels/server_api/authenticating_users\"\n                    },\n                    authorizationEndpoint: {\n                        path: \"/docs/channels/server_api/authorizing-users/\"\n                    },\n                    javascriptQuickStart: {\n                        path: \"/docs/javascript_quick_start\"\n                    },\n                    triggeringClientEvents: {\n                        path: \"/docs/client_api_guide/client_events#trigger-events\"\n                    },\n                    encryptedChannelSupport: {\n                        fullUrl: \"https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support\"\n                    }\n                }\n            };\n            const buildLogSuffix = function(key) {\n                const urlPrefix = \"See:\";\n                const urlObj = urlStore.urls[key];\n                if (!urlObj) return \"\";\n                let url;\n                if (urlObj.fullUrl) {\n                    url = urlObj.fullUrl;\n                } else if (urlObj.path) {\n                    url = urlStore.baseUrl + urlObj.path;\n                }\n                if (!url) return \"\";\n                return \"\".concat(urlPrefix, \" \").concat(url);\n            };\n            /* harmony default export */ var url_store = {\n                buildLogSuffix\n            };\n            // CONCATENATED MODULE: ./src/core/auth/options.ts\n            var AuthRequestType;\n            (function(AuthRequestType) {\n                AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n                AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n            })(AuthRequestType || (AuthRequestType = {}));\n            // CONCATENATED MODULE: ./src/core/errors.ts\n            class BadEventName extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class BadChannelName extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class RequestTimedOut extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class TransportPriorityTooLow extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class TransportClosed extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class UnsupportedFeature extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class UnsupportedTransport extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class UnsupportedStrategy extends Error {\n                constructor(msg){\n                    super(msg);\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            class HTTPAuthError extends Error {\n                constructor(status, msg){\n                    super(msg);\n                    this.status = status;\n                    Object.setPrototypeOf(this, new.target.prototype);\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n            const ajax = function(context, query, authOptions, authRequestType, callback) {\n                const xhr = runtime.createXHR();\n                xhr.open(\"POST\", authOptions.endpoint, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                for(var headerName in authOptions.headers){\n                    xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n                }\n                if (authOptions.headersProvider != null) {\n                    let dynamicHeaders = authOptions.headersProvider();\n                    for(var headerName in dynamicHeaders){\n                        xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n                    }\n                }\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        if (xhr.status === 200) {\n                            let data;\n                            let parsed = false;\n                            try {\n                                data = JSON.parse(xhr.responseText);\n                                parsed = true;\n                            } catch (e) {\n                                callback(new HTTPAuthError(200, \"JSON returned from \".concat(authRequestType.toString(), \" endpoint was invalid, yet status code was 200. Data was: \").concat(xhr.responseText)), null);\n                            }\n                            if (parsed) {\n                                callback(null, data);\n                            }\n                        } else {\n                            let suffix = \"\";\n                            switch(authRequestType){\n                                case AuthRequestType.UserAuthentication:\n                                    suffix = url_store.buildLogSuffix(\"authenticationEndpoint\");\n                                    break;\n                                case AuthRequestType.ChannelAuthorization:\n                                    suffix = \"Clients must be authorized to join private or presence channels. \".concat(url_store.buildLogSuffix(\"authorizationEndpoint\"));\n                                    break;\n                            }\n                            callback(new HTTPAuthError(xhr.status, \"Unable to retrieve auth string from \".concat(authRequestType.toString(), \" endpoint - \") + \"received status: \".concat(xhr.status, \" from \").concat(authOptions.endpoint, \". \").concat(suffix)), null);\n                        }\n                    }\n                };\n                xhr.send(query);\n                return xhr;\n            };\n            /* harmony default export */ var xhr_auth = ajax;\n            // CONCATENATED MODULE: ./src/core/base64.ts\n            function encode(s) {\n                return btoa(utob(s));\n            }\n            var fromCharCode = String.fromCharCode;\n            var b64chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var b64tab = {};\n            for(var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++){\n                b64tab[b64chars.charAt(base64_i)] = base64_i;\n            }\n            var cb_utob = function(c) {\n                var cc = c.charCodeAt(0);\n                return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n            };\n            var utob = function(u) {\n                return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n            };\n            var cb_encode = function(ccc) {\n                var padlen = [\n                    0,\n                    2,\n                    1\n                ][ccc.length % 3];\n                var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n                var chars = [\n                    b64chars.charAt(ord >>> 18),\n                    b64chars.charAt(ord >>> 12 & 63),\n                    padlen >= 2 ? \"=\" : b64chars.charAt(ord >>> 6 & 63),\n                    padlen >= 1 ? \"=\" : b64chars.charAt(ord & 63)\n                ];\n                return chars.join(\"\");\n            };\n            var btoa = window.btoa || function(b) {\n                return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n            };\n            // CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\n            class Timer {\n                isRunning() {\n                    return this.timer !== null;\n                }\n                ensureAborted() {\n                    if (this.timer) {\n                        this.clear(this.timer);\n                        this.timer = null;\n                    }\n                }\n                constructor(set, clear, delay, callback){\n                    this.clear = clear;\n                    this.timer = set(()=>{\n                        if (this.timer) {\n                            this.timer = callback(this.timer);\n                        }\n                    }, delay);\n                }\n            }\n            /* harmony default export */ var abstract_timer = Timer;\n            // CONCATENATED MODULE: ./src/core/utils/timers/index.ts\n            function timers_clearTimeout(timer) {\n                window.clearTimeout(timer);\n            }\n            function timers_clearInterval(timer) {\n                window.clearInterval(timer);\n            }\n            class timers_OneOffTimer extends abstract_timer {\n                constructor(delay, callback){\n                    super(setTimeout, timers_clearTimeout, delay, function(timer) {\n                        callback();\n                        return null;\n                    });\n                }\n            }\n            class timers_PeriodicTimer extends abstract_timer {\n                constructor(delay, callback){\n                    super(setInterval, timers_clearInterval, delay, function(timer) {\n                        callback();\n                        return timer;\n                    });\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/util.ts\n            var Util = {\n                now () {\n                    if (Date.now) {\n                        return Date.now();\n                    } else {\n                        return new Date().valueOf();\n                    }\n                },\n                defer (callback) {\n                    return new timers_OneOffTimer(0, callback);\n                },\n                method (name) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var boundArguments = Array.prototype.slice.call(arguments, 1);\n                    return function(object) {\n                        return object[name].apply(object, boundArguments.concat(arguments));\n                    };\n                }\n            };\n            /* harmony default export */ var util = Util;\n            // CONCATENATED MODULE: ./src/core/utils/collections.ts\n            function extend(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                for(var i = 0; i < sources.length; i++){\n                    var extensions = sources[i];\n                    for(var property in extensions){\n                        if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {\n                            target[property] = extend(target[property] || {}, extensions[property]);\n                        } else {\n                            target[property] = extensions[property];\n                        }\n                    }\n                }\n                return target;\n            }\n            function stringify() {\n                var m = [\n                    \"Pusher\"\n                ];\n                for(var i = 0; i < arguments.length; i++){\n                    if (typeof arguments[i] === \"string\") {\n                        m.push(arguments[i]);\n                    } else {\n                        m.push(safeJSONStringify(arguments[i]));\n                    }\n                }\n                return m.join(\" : \");\n            }\n            function arrayIndexOf(array, item) {\n                var nativeIndexOf = Array.prototype.indexOf;\n                if (array === null) {\n                    return -1;\n                }\n                if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n                    return array.indexOf(item);\n                }\n                for(var i = 0, l = array.length; i < l; i++){\n                    if (array[i] === item) {\n                        return i;\n                    }\n                }\n                return -1;\n            }\n            function objectApply(object, f) {\n                for(var key in object){\n                    if (Object.prototype.hasOwnProperty.call(object, key)) {\n                        f(object[key], key, object);\n                    }\n                }\n            }\n            function keys(object) {\n                var keys = [];\n                objectApply(object, function(_, key) {\n                    keys.push(key);\n                });\n                return keys;\n            }\n            function values(object) {\n                var values = [];\n                objectApply(object, function(value) {\n                    values.push(value);\n                });\n                return values;\n            }\n            function apply(array, f, context) {\n                for(var i = 0; i < array.length; i++){\n                    f.call(context || window, array[i], i, array);\n                }\n            }\n            function map(array, f) {\n                var result = [];\n                for(var i = 0; i < array.length; i++){\n                    result.push(f(array[i], i, array, result));\n                }\n                return result;\n            }\n            function mapObject(object, f) {\n                var result = {};\n                objectApply(object, function(value, key) {\n                    result[key] = f(value);\n                });\n                return result;\n            }\n            function filter(array, test) {\n                test = test || function(value) {\n                    return !!value;\n                };\n                var result = [];\n                for(var i = 0; i < array.length; i++){\n                    if (test(array[i], i, array, result)) {\n                        result.push(array[i]);\n                    }\n                }\n                return result;\n            }\n            function filterObject(object, test) {\n                var result = {};\n                objectApply(object, function(value, key) {\n                    if (test && test(value, key, object, result) || Boolean(value)) {\n                        result[key] = value;\n                    }\n                });\n                return result;\n            }\n            function flatten(object) {\n                var result = [];\n                objectApply(object, function(value, key) {\n                    result.push([\n                        key,\n                        value\n                    ]);\n                });\n                return result;\n            }\n            function any(array, test) {\n                for(var i = 0; i < array.length; i++){\n                    if (test(array[i], i, array)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function collections_all(array, test) {\n                for(var i = 0; i < array.length; i++){\n                    if (!test(array[i], i, array)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function encodeParamsObject(data) {\n                return mapObject(data, function(value) {\n                    if (typeof value === \"object\") {\n                        value = safeJSONStringify(value);\n                    }\n                    return encodeURIComponent(encode(value.toString()));\n                });\n            }\n            function buildQueryString(data) {\n                var params = filterObject(data, function(value) {\n                    return value !== undefined;\n                });\n                var query = map(flatten(encodeParamsObject(params)), util.method(\"join\", \"=\")).join(\"&\");\n                return query;\n            }\n            function decycleObject(object) {\n                var objects = [], paths = [];\n                return function derez(value, path) {\n                    var i, name, nu;\n                    switch(typeof value){\n                        case \"object\":\n                            if (!value) {\n                                return null;\n                            }\n                            for(i = 0; i < objects.length; i += 1){\n                                if (objects[i] === value) {\n                                    return {\n                                        $ref: paths[i]\n                                    };\n                                }\n                            }\n                            objects.push(value);\n                            paths.push(path);\n                            if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                                nu = [];\n                                for(i = 0; i < value.length; i += 1){\n                                    nu[i] = derez(value[i], path + \"[\" + i + \"]\");\n                                }\n                            } else {\n                                nu = {};\n                                for(name in value){\n                                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                                        nu[name] = derez(value[name], path + \"[\" + JSON.stringify(name) + \"]\");\n                                    }\n                                }\n                            }\n                            return nu;\n                        case \"number\":\n                        case \"string\":\n                        case \"boolean\":\n                            return value;\n                    }\n                }(object, \"$\");\n            }\n            function safeJSONStringify(source) {\n                try {\n                    return JSON.stringify(source);\n                } catch (e) {\n                    return JSON.stringify(decycleObject(source));\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/logger.ts\n            class logger_Logger {\n                debug() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    this.log(this.globalLog, args);\n                }\n                warn() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    this.log(this.globalLogWarn, args);\n                }\n                error() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    this.log(this.globalLogError, args);\n                }\n                globalLogWarn(message) {\n                    if (window.console && window.console.warn) {\n                        window.console.warn(message);\n                    } else {\n                        this.globalLog(message);\n                    }\n                }\n                globalLogError(message) {\n                    if (window.console && window.console.error) {\n                        window.console.error(message);\n                    } else {\n                        this.globalLogWarn(message);\n                    }\n                }\n                log(defaultLoggingFunction) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var message = stringify.apply(this, arguments);\n                    if (core_pusher.log) {\n                        core_pusher.log(message);\n                    } else if (core_pusher.logToConsole) {\n                        const log = defaultLoggingFunction.bind(this);\n                        log(message);\n                    }\n                }\n                constructor(){\n                    this.globalLog = (message)=>{\n                        if (window.console && window.console.log) {\n                            window.console.log(message);\n                        }\n                    };\n                }\n            }\n            /* harmony default export */ var logger = new logger_Logger();\n            // CONCATENATED MODULE: ./src/runtimes/web/auth/jsonp_auth.ts\n            var jsonp = function(context, query, authOptions, authRequestType, callback) {\n                if (authOptions.headers !== undefined || authOptions.headersProvider != null) {\n                    logger.warn(\"To send headers with the \".concat(authRequestType.toString(), \" request, you must use AJAX, rather than JSONP.\"));\n                }\n                var callbackName = context.nextAuthCallbackID.toString();\n                context.nextAuthCallbackID++;\n                var document1 = context.getDocument();\n                var script = document1.createElement(\"script\");\n                context.auth_callbacks[callbackName] = function(data) {\n                    callback(null, data);\n                };\n                var callback_name = \"Pusher.auth_callbacks['\" + callbackName + \"']\";\n                script.src = authOptions.endpoint + \"?callback=\" + encodeURIComponent(callback_name) + \"&\" + query;\n                var head = document1.getElementsByTagName(\"head\")[0] || document1.documentElement;\n                head.insertBefore(script, head.firstChild);\n            };\n            /* harmony default export */ var jsonp_auth = jsonp;\n            // CONCATENATED MODULE: ./src/runtimes/web/dom/script_request.ts\n            class ScriptRequest {\n                send(receiver) {\n                    var self = this;\n                    var errorString = \"Error loading \" + self.src;\n                    self.script = document.createElement(\"script\");\n                    self.script.id = receiver.id;\n                    self.script.src = self.src;\n                    self.script.type = \"text/javascript\";\n                    self.script.charset = \"UTF-8\";\n                    if (self.script.addEventListener) {\n                        self.script.onerror = function() {\n                            receiver.callback(errorString);\n                        };\n                        self.script.onload = function() {\n                            receiver.callback(null);\n                        };\n                    } else {\n                        self.script.onreadystatechange = function() {\n                            if (self.script.readyState === \"loaded\" || self.script.readyState === \"complete\") {\n                                receiver.callback(null);\n                            }\n                        };\n                    }\n                    if (self.script.async === undefined && document.attachEvent && /opera/i.test(navigator.userAgent)) {\n                        self.errorScript = document.createElement(\"script\");\n                        self.errorScript.id = receiver.id + \"_error\";\n                        self.errorScript.text = receiver.name + \"('\" + errorString + \"');\";\n                        self.script.async = self.errorScript.async = false;\n                    } else {\n                        self.script.async = true;\n                    }\n                    var head = document.getElementsByTagName(\"head\")[0];\n                    head.insertBefore(self.script, head.firstChild);\n                    if (self.errorScript) {\n                        head.insertBefore(self.errorScript, self.script.nextSibling);\n                    }\n                }\n                cleanup() {\n                    if (this.script) {\n                        this.script.onload = this.script.onerror = null;\n                        this.script.onreadystatechange = null;\n                    }\n                    if (this.script && this.script.parentNode) {\n                        this.script.parentNode.removeChild(this.script);\n                    }\n                    if (this.errorScript && this.errorScript.parentNode) {\n                        this.errorScript.parentNode.removeChild(this.errorScript);\n                    }\n                    this.script = null;\n                    this.errorScript = null;\n                }\n                constructor(src){\n                    this.src = src;\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/web/dom/jsonp_request.ts\n            class jsonp_request_JSONPRequest {\n                send(receiver) {\n                    if (this.request) {\n                        return;\n                    }\n                    var query = buildQueryString(this.data);\n                    var url = this.url + \"/\" + receiver.number + \"?\" + query;\n                    this.request = runtime.createScriptRequest(url);\n                    this.request.send(receiver);\n                }\n                cleanup() {\n                    if (this.request) {\n                        this.request.cleanup();\n                    }\n                }\n                constructor(url, data){\n                    this.url = url;\n                    this.data = data;\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/web/timeline/jsonp_timeline.ts\n            var getAgent = function(sender, useTLS) {\n                return function(data, callback) {\n                    var scheme = \"http\" + (useTLS ? \"s\" : \"\") + \"://\";\n                    var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n                    var request = runtime.createJSONPRequest(url, data);\n                    var receiver = runtime.ScriptReceivers.create(function(error, result) {\n                        ScriptReceivers.remove(receiver);\n                        request.cleanup();\n                        if (result && result.host) {\n                            sender.host = result.host;\n                        }\n                        if (callback) {\n                            callback(error, result);\n                        }\n                    });\n                    request.send(receiver);\n                };\n            };\n            var jsonp_timeline_jsonp = {\n                name: \"jsonp\",\n                getAgent\n            };\n            /* harmony default export */ var jsonp_timeline = jsonp_timeline_jsonp;\n            // CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n            function getGenericURL(baseScheme, params, path) {\n                var scheme = baseScheme + (params.useTLS ? \"s\" : \"\");\n                var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n                return scheme + \"://\" + host + path;\n            }\n            function getGenericPath(key, queryString) {\n                var path = \"/app/\" + key;\n                var query = \"?protocol=\" + defaults.PROTOCOL + \"&client=js\" + \"&version=\" + defaults.VERSION + (queryString ? \"&\" + queryString : \"\");\n                return path + query;\n            }\n            var ws = {\n                getInitial: function(key, params) {\n                    var path = (params.httpPath || \"\") + getGenericPath(key, \"flash=false\");\n                    return getGenericURL(\"ws\", params, path);\n                }\n            };\n            var http = {\n                getInitial: function(key, params) {\n                    var path = (params.httpPath || \"/pusher\") + getGenericPath(key);\n                    return getGenericURL(\"http\", params, path);\n                }\n            };\n            var sockjs = {\n                getInitial: function(key, params) {\n                    return getGenericURL(\"http\", params, params.httpPath || \"/pusher\");\n                },\n                getPath: function(key, params) {\n                    return getGenericPath(key);\n                }\n            };\n            // CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n            class callback_registry_CallbackRegistry {\n                get(name) {\n                    return this._callbacks[prefix(name)];\n                }\n                add(name, callback, context) {\n                    var prefixedEventName = prefix(name);\n                    this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];\n                    this._callbacks[prefixedEventName].push({\n                        fn: callback,\n                        context: context\n                    });\n                }\n                remove(name, callback, context) {\n                    if (!name && !callback && !context) {\n                        this._callbacks = {};\n                        return;\n                    }\n                    var names = name ? [\n                        prefix(name)\n                    ] : keys(this._callbacks);\n                    if (callback || context) {\n                        this.removeCallback(names, callback, context);\n                    } else {\n                        this.removeAllCallbacks(names);\n                    }\n                }\n                removeCallback(names, callback, context) {\n                    apply(names, function(name) {\n                        this._callbacks[name] = filter(this._callbacks[name] || [], function(binding) {\n                            return callback && callback !== binding.fn || context && context !== binding.context;\n                        });\n                        if (this._callbacks[name].length === 0) {\n                            delete this._callbacks[name];\n                        }\n                    }, this);\n                }\n                removeAllCallbacks(names) {\n                    apply(names, function(name) {\n                        delete this._callbacks[name];\n                    }, this);\n                }\n                constructor(){\n                    this._callbacks = {};\n                }\n            }\n            function prefix(name) {\n                return \"_\" + name;\n            }\n            // CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n            class dispatcher_Dispatcher {\n                bind(eventName, callback, context) {\n                    this.callbacks.add(eventName, callback, context);\n                    return this;\n                }\n                bind_global(callback) {\n                    this.global_callbacks.push(callback);\n                    return this;\n                }\n                unbind(eventName, callback, context) {\n                    this.callbacks.remove(eventName, callback, context);\n                    return this;\n                }\n                unbind_global(callback) {\n                    if (!callback) {\n                        this.global_callbacks = [];\n                        return this;\n                    }\n                    this.global_callbacks = filter(this.global_callbacks || [], (c)=>c !== callback);\n                    return this;\n                }\n                unbind_all() {\n                    this.unbind();\n                    this.unbind_global();\n                    return this;\n                }\n                emit(eventName, data, metadata) {\n                    for(var i = 0; i < this.global_callbacks.length; i++){\n                        this.global_callbacks[i](eventName, data);\n                    }\n                    var callbacks = this.callbacks.get(eventName);\n                    var args = [];\n                    if (metadata) {\n                        args.push(data, metadata);\n                    } else if (data) {\n                        args.push(data);\n                    }\n                    if (callbacks && callbacks.length > 0) {\n                        for(var i = 0; i < callbacks.length; i++){\n                            callbacks[i].fn.apply(callbacks[i].context || window, args);\n                        }\n                    } else if (this.failThrough) {\n                        this.failThrough(eventName, data);\n                    }\n                    return this;\n                }\n                constructor(failThrough){\n                    this.callbacks = new callback_registry_CallbackRegistry();\n                    this.global_callbacks = [];\n                    this.failThrough = failThrough;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\n            class transport_connection_TransportConnection extends dispatcher_Dispatcher {\n                handlesActivityChecks() {\n                    return Boolean(this.hooks.handlesActivityChecks);\n                }\n                supportsPing() {\n                    return Boolean(this.hooks.supportsPing);\n                }\n                connect() {\n                    if (this.socket || this.state !== \"initialized\") {\n                        return false;\n                    }\n                    var url = this.hooks.urls.getInitial(this.key, this.options);\n                    try {\n                        this.socket = this.hooks.getSocket(url, this.options);\n                    } catch (e) {\n                        util.defer(()=>{\n                            this.onError(e);\n                            this.changeState(\"closed\");\n                        });\n                        return false;\n                    }\n                    this.bindListeners();\n                    logger.debug(\"Connecting\", {\n                        transport: this.name,\n                        url\n                    });\n                    this.changeState(\"connecting\");\n                    return true;\n                }\n                close() {\n                    if (this.socket) {\n                        this.socket.close();\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n                send(data) {\n                    if (this.state === \"open\") {\n                        util.defer(()=>{\n                            if (this.socket) {\n                                this.socket.send(data);\n                            }\n                        });\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n                ping() {\n                    if (this.state === \"open\" && this.supportsPing()) {\n                        this.socket.ping();\n                    }\n                }\n                onOpen() {\n                    if (this.hooks.beforeOpen) {\n                        this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n                    }\n                    this.changeState(\"open\");\n                    this.socket.onopen = undefined;\n                }\n                onError(error) {\n                    this.emit(\"error\", {\n                        type: \"WebSocketError\",\n                        error: error\n                    });\n                    this.timeline.error(this.buildTimelineMessage({\n                        error: error.toString()\n                    }));\n                }\n                onClose(closeEvent) {\n                    if (closeEvent) {\n                        this.changeState(\"closed\", {\n                            code: closeEvent.code,\n                            reason: closeEvent.reason,\n                            wasClean: closeEvent.wasClean\n                        });\n                    } else {\n                        this.changeState(\"closed\");\n                    }\n                    this.unbindListeners();\n                    this.socket = undefined;\n                }\n                onMessage(message) {\n                    this.emit(\"message\", message);\n                }\n                onActivity() {\n                    this.emit(\"activity\");\n                }\n                bindListeners() {\n                    this.socket.onopen = ()=>{\n                        this.onOpen();\n                    };\n                    this.socket.onerror = (error)=>{\n                        this.onError(error);\n                    };\n                    this.socket.onclose = (closeEvent)=>{\n                        this.onClose(closeEvent);\n                    };\n                    this.socket.onmessage = (message)=>{\n                        this.onMessage(message);\n                    };\n                    if (this.supportsPing()) {\n                        this.socket.onactivity = ()=>{\n                            this.onActivity();\n                        };\n                    }\n                }\n                unbindListeners() {\n                    if (this.socket) {\n                        this.socket.onopen = undefined;\n                        this.socket.onerror = undefined;\n                        this.socket.onclose = undefined;\n                        this.socket.onmessage = undefined;\n                        if (this.supportsPing()) {\n                            this.socket.onactivity = undefined;\n                        }\n                    }\n                }\n                changeState(state, params) {\n                    this.state = state;\n                    this.timeline.info(this.buildTimelineMessage({\n                        state: state,\n                        params: params\n                    }));\n                    this.emit(state, params);\n                }\n                buildTimelineMessage(message) {\n                    return extend({\n                        cid: this.id\n                    }, message);\n                }\n                constructor(hooks, name, priority, key, options){\n                    super();\n                    this.initialize = runtime.transportConnectionInitializer;\n                    this.hooks = hooks;\n                    this.name = name;\n                    this.priority = priority;\n                    this.key = key;\n                    this.options = options;\n                    this.state = \"new\";\n                    this.timeline = options.timeline;\n                    this.activityTimeout = options.activityTimeout;\n                    this.id = this.timeline.generateUniqueID();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/transports/transport.ts\n            class transport_Transport {\n                isSupported(environment) {\n                    return this.hooks.isSupported(environment);\n                }\n                createConnection(name, priority, key, options) {\n                    return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);\n                }\n                constructor(hooks){\n                    this.hooks = hooks;\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n            var WSTransport = new transport_Transport({\n                urls: ws,\n                handlesActivityChecks: false,\n                supportsPing: false,\n                isInitialized: function() {\n                    return Boolean(runtime.getWebSocketAPI());\n                },\n                isSupported: function() {\n                    return Boolean(runtime.getWebSocketAPI());\n                },\n                getSocket: function(url) {\n                    return runtime.createWebSocket(url);\n                }\n            });\n            var httpConfiguration = {\n                urls: http,\n                handlesActivityChecks: false,\n                supportsPing: true,\n                isInitialized: function() {\n                    return true;\n                }\n            };\n            var streamingConfiguration = extend({\n                getSocket: function(url) {\n                    return runtime.HTTPFactory.createStreamingSocket(url);\n                }\n            }, httpConfiguration);\n            var pollingConfiguration = extend({\n                getSocket: function(url) {\n                    return runtime.HTTPFactory.createPollingSocket(url);\n                }\n            }, httpConfiguration);\n            var xhrConfiguration = {\n                isSupported: function() {\n                    return runtime.isXHRSupported();\n                }\n            };\n            var XHRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xhrConfiguration));\n            var XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));\n            var Transports = {\n                ws: WSTransport,\n                xhr_streaming: XHRStreamingTransport,\n                xhr_polling: XHRPollingTransport\n            };\n            /* harmony default export */ var transports = Transports;\n            // CONCATENATED MODULE: ./src/runtimes/web/transports/transports.ts\n            var SockJSTransport = new transport_Transport({\n                file: \"sockjs\",\n                urls: sockjs,\n                handlesActivityChecks: true,\n                supportsPing: false,\n                isSupported: function() {\n                    return true;\n                },\n                isInitialized: function() {\n                    return window.SockJS !== undefined;\n                },\n                getSocket: function(url, options) {\n                    return new window.SockJS(url, null, {\n                        js_path: Dependencies.getPath(\"sockjs\", {\n                            useTLS: options.useTLS\n                        }),\n                        ignore_null_origin: options.ignoreNullOrigin\n                    });\n                },\n                beforeOpen: function(socket, path) {\n                    socket.send(JSON.stringify({\n                        path: path\n                    }));\n                }\n            });\n            var xdrConfiguration = {\n                isSupported: function(environment) {\n                    var yes = runtime.isXDRSupported(environment.useTLS);\n                    return yes;\n                }\n            };\n            var XDRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xdrConfiguration));\n            var XDRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xdrConfiguration));\n            transports.xdr_streaming = XDRStreamingTransport;\n            transports.xdr_polling = XDRPollingTransport;\n            transports.sockjs = SockJSTransport;\n            /* harmony default export */ var transports_transports = transports;\n            // CONCATENATED MODULE: ./src/runtimes/web/net_info.ts\n            class net_info_NetInfo extends dispatcher_Dispatcher {\n                isOnline() {\n                    if (window.navigator.onLine === undefined) {\n                        return true;\n                    } else {\n                        return window.navigator.onLine;\n                    }\n                }\n                constructor(){\n                    super();\n                    var self = this;\n                    if (window.addEventListener !== undefined) {\n                        window.addEventListener(\"online\", function() {\n                            self.emit(\"online\");\n                        }, false);\n                        window.addEventListener(\"offline\", function() {\n                            self.emit(\"offline\");\n                        }, false);\n                    }\n                }\n            }\n            var net_info_Network = new net_info_NetInfo();\n            // CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n            class assistant_to_the_transport_manager_AssistantToTheTransportManager {\n                createConnection(name, priority, key, options) {\n                    options = extend({}, options, {\n                        activityTimeout: this.pingDelay\n                    });\n                    var connection = this.transport.createConnection(name, priority, key, options);\n                    var openTimestamp = null;\n                    var onOpen = function() {\n                        connection.unbind(\"open\", onOpen);\n                        connection.bind(\"closed\", onClosed);\n                        openTimestamp = util.now();\n                    };\n                    var onClosed = (closeEvent)=>{\n                        connection.unbind(\"closed\", onClosed);\n                        if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                            this.manager.reportDeath();\n                        } else if (!closeEvent.wasClean && openTimestamp) {\n                            var lifespan = util.now() - openTimestamp;\n                            if (lifespan < 2 * this.maxPingDelay) {\n                                this.manager.reportDeath();\n                                this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);\n                            }\n                        }\n                    };\n                    connection.bind(\"open\", onOpen);\n                    return connection;\n                }\n                isSupported(environment) {\n                    return this.manager.isAlive() && this.transport.isSupported(environment);\n                }\n                constructor(manager, transport, options){\n                    this.manager = manager;\n                    this.transport = transport;\n                    this.minPingDelay = options.minPingDelay;\n                    this.maxPingDelay = options.maxPingDelay;\n                    this.pingDelay = undefined;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\n            const Protocol = {\n                decodeMessage: function(messageEvent) {\n                    try {\n                        var messageData = JSON.parse(messageEvent.data);\n                        var pusherEventData = messageData.data;\n                        if (typeof pusherEventData === \"string\") {\n                            try {\n                                pusherEventData = JSON.parse(messageData.data);\n                            } catch (e) {}\n                        }\n                        var pusherEvent = {\n                            event: messageData.event,\n                            channel: messageData.channel,\n                            data: pusherEventData\n                        };\n                        if (messageData.user_id) {\n                            pusherEvent.user_id = messageData.user_id;\n                        }\n                        return pusherEvent;\n                    } catch (e) {\n                        throw {\n                            type: \"MessageParseError\",\n                            error: e,\n                            data: messageEvent.data\n                        };\n                    }\n                },\n                encodeMessage: function(event) {\n                    return JSON.stringify(event);\n                },\n                processHandshake: function(messageEvent) {\n                    var message = Protocol.decodeMessage(messageEvent);\n                    if (message.event === \"pusher:connection_established\") {\n                        if (!message.data.activity_timeout) {\n                            throw \"No activity timeout specified in handshake\";\n                        }\n                        return {\n                            action: \"connected\",\n                            id: message.data.socket_id,\n                            activityTimeout: message.data.activity_timeout * 1000\n                        };\n                    } else if (message.event === \"pusher:error\") {\n                        return {\n                            action: this.getCloseAction(message.data),\n                            error: this.getCloseError(message.data)\n                        };\n                    } else {\n                        throw \"Invalid handshake\";\n                    }\n                },\n                getCloseAction: function(closeEvent) {\n                    if (closeEvent.code < 4000) {\n                        if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                            return \"backoff\";\n                        } else {\n                            return null;\n                        }\n                    } else if (closeEvent.code === 4000) {\n                        return \"tls_only\";\n                    } else if (closeEvent.code < 4100) {\n                        return \"refused\";\n                    } else if (closeEvent.code < 4200) {\n                        return \"backoff\";\n                    } else if (closeEvent.code < 4300) {\n                        return \"retry\";\n                    } else {\n                        return \"refused\";\n                    }\n                },\n                getCloseError: function(closeEvent) {\n                    if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n                        return {\n                            type: \"PusherError\",\n                            data: {\n                                code: closeEvent.code,\n                                message: closeEvent.reason || closeEvent.message\n                            }\n                        };\n                    } else {\n                        return null;\n                    }\n                }\n            };\n            /* harmony default export */ var protocol_protocol = Protocol;\n            // CONCATENATED MODULE: ./src/core/connection/connection.ts\n            class connection_Connection extends dispatcher_Dispatcher {\n                handlesActivityChecks() {\n                    return this.transport.handlesActivityChecks();\n                }\n                send(data) {\n                    return this.transport.send(data);\n                }\n                send_event(name, data, channel) {\n                    var event = {\n                        event: name,\n                        data: data\n                    };\n                    if (channel) {\n                        event.channel = channel;\n                    }\n                    logger.debug(\"Event sent\", event);\n                    return this.send(protocol_protocol.encodeMessage(event));\n                }\n                ping() {\n                    if (this.transport.supportsPing()) {\n                        this.transport.ping();\n                    } else {\n                        this.send_event(\"pusher:ping\", {});\n                    }\n                }\n                close() {\n                    this.transport.close();\n                }\n                bindListeners() {\n                    var listeners = {\n                        message: (messageEvent)=>{\n                            var pusherEvent;\n                            try {\n                                pusherEvent = protocol_protocol.decodeMessage(messageEvent);\n                            } catch (e) {\n                                this.emit(\"error\", {\n                                    type: \"MessageParseError\",\n                                    error: e,\n                                    data: messageEvent.data\n                                });\n                            }\n                            if (pusherEvent !== undefined) {\n                                logger.debug(\"Event recd\", pusherEvent);\n                                switch(pusherEvent.event){\n                                    case \"pusher:error\":\n                                        this.emit(\"error\", {\n                                            type: \"PusherError\",\n                                            data: pusherEvent.data\n                                        });\n                                        break;\n                                    case \"pusher:ping\":\n                                        this.emit(\"ping\");\n                                        break;\n                                    case \"pusher:pong\":\n                                        this.emit(\"pong\");\n                                        break;\n                                }\n                                this.emit(\"message\", pusherEvent);\n                            }\n                        },\n                        activity: ()=>{\n                            this.emit(\"activity\");\n                        },\n                        error: (error)=>{\n                            this.emit(\"error\", error);\n                        },\n                        closed: (closeEvent)=>{\n                            unbindListeners();\n                            if (closeEvent && closeEvent.code) {\n                                this.handleCloseEvent(closeEvent);\n                            }\n                            this.transport = null;\n                            this.emit(\"closed\");\n                        }\n                    };\n                    var unbindListeners = ()=>{\n                        objectApply(listeners, (listener, event)=>{\n                            this.transport.unbind(event, listener);\n                        });\n                    };\n                    objectApply(listeners, (listener, event)=>{\n                        this.transport.bind(event, listener);\n                    });\n                }\n                handleCloseEvent(closeEvent) {\n                    var action = protocol_protocol.getCloseAction(closeEvent);\n                    var error = protocol_protocol.getCloseError(closeEvent);\n                    if (error) {\n                        this.emit(\"error\", error);\n                    }\n                    if (action) {\n                        this.emit(action, {\n                            action: action,\n                            error: error\n                        });\n                    }\n                }\n                constructor(id, transport){\n                    super();\n                    this.id = id;\n                    this.transport = transport;\n                    this.activityTimeout = transport.activityTimeout;\n                    this.bindListeners();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n            class handshake_Handshake {\n                close() {\n                    this.unbindListeners();\n                    this.transport.close();\n                }\n                bindListeners() {\n                    this.onMessage = (m)=>{\n                        this.unbindListeners();\n                        var result;\n                        try {\n                            result = protocol_protocol.processHandshake(m);\n                        } catch (e) {\n                            this.finish(\"error\", {\n                                error: e\n                            });\n                            this.transport.close();\n                            return;\n                        }\n                        if (result.action === \"connected\") {\n                            this.finish(\"connected\", {\n                                connection: new connection_Connection(result.id, this.transport),\n                                activityTimeout: result.activityTimeout\n                            });\n                        } else {\n                            this.finish(result.action, {\n                                error: result.error\n                            });\n                            this.transport.close();\n                        }\n                    };\n                    this.onClosed = (closeEvent)=>{\n                        this.unbindListeners();\n                        var action = protocol_protocol.getCloseAction(closeEvent) || \"backoff\";\n                        var error = protocol_protocol.getCloseError(closeEvent);\n                        this.finish(action, {\n                            error: error\n                        });\n                    };\n                    this.transport.bind(\"message\", this.onMessage);\n                    this.transport.bind(\"closed\", this.onClosed);\n                }\n                unbindListeners() {\n                    this.transport.unbind(\"message\", this.onMessage);\n                    this.transport.unbind(\"closed\", this.onClosed);\n                }\n                finish(action, params) {\n                    this.callback(extend({\n                        transport: this.transport,\n                        action: action\n                    }, params));\n                }\n                constructor(transport, callback){\n                    this.transport = transport;\n                    this.callback = callback;\n                    this.bindListeners();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n            class timeline_sender_TimelineSender {\n                send(useTLS, callback) {\n                    if (this.timeline.isEmpty()) {\n                        return;\n                    }\n                    this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);\n                }\n                constructor(timeline, options){\n                    this.timeline = timeline;\n                    this.options = options || {};\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/channels/channel.ts\n            class channel_Channel extends dispatcher_Dispatcher {\n                authorize(socketId, callback) {\n                    return callback(null, {\n                        auth: \"\"\n                    });\n                }\n                trigger(event, data) {\n                    if (event.indexOf(\"client-\") !== 0) {\n                        throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n                    }\n                    if (!this.subscribed) {\n                        var suffix = url_store.buildLogSuffix(\"triggeringClientEvents\");\n                        logger.warn(\"Client event triggered before channel 'subscription_succeeded' event . \".concat(suffix));\n                    }\n                    return this.pusher.send_event(event, data, this.name);\n                }\n                disconnect() {\n                    this.subscribed = false;\n                    this.subscriptionPending = false;\n                }\n                handleEvent(event) {\n                    var eventName = event.event;\n                    var data = event.data;\n                    if (eventName === \"pusher_internal:subscription_succeeded\") {\n                        this.handleSubscriptionSucceededEvent(event);\n                    } else if (eventName === \"pusher_internal:subscription_count\") {\n                        this.handleSubscriptionCountEvent(event);\n                    } else if (eventName.indexOf(\"pusher_internal:\") !== 0) {\n                        var metadata = {};\n                        this.emit(eventName, data, metadata);\n                    }\n                }\n                handleSubscriptionSucceededEvent(event) {\n                    this.subscriptionPending = false;\n                    this.subscribed = true;\n                    if (this.subscriptionCancelled) {\n                        this.pusher.unsubscribe(this.name);\n                    } else {\n                        this.emit(\"pusher:subscription_succeeded\", event.data);\n                    }\n                }\n                handleSubscriptionCountEvent(event) {\n                    if (event.data.subscription_count) {\n                        this.subscriptionCount = event.data.subscription_count;\n                    }\n                    this.emit(\"pusher:subscription_count\", event.data);\n                }\n                subscribe() {\n                    if (this.subscribed) {\n                        return;\n                    }\n                    this.subscriptionPending = true;\n                    this.subscriptionCancelled = false;\n                    this.authorize(this.pusher.connection.socket_id, (error, data)=>{\n                        if (error) {\n                            this.subscriptionPending = false;\n                            logger.error(error.toString());\n                            this.emit(\"pusher:subscription_error\", Object.assign({}, {\n                                type: \"AuthError\",\n                                error: error.message\n                            }, error instanceof HTTPAuthError ? {\n                                status: error.status\n                            } : {}));\n                        } else {\n                            this.pusher.send_event(\"pusher:subscribe\", {\n                                auth: data.auth,\n                                channel_data: data.channel_data,\n                                channel: this.name\n                            });\n                        }\n                    });\n                }\n                unsubscribe() {\n                    this.subscribed = false;\n                    this.pusher.send_event(\"pusher:unsubscribe\", {\n                        channel: this.name\n                    });\n                }\n                cancelSubscription() {\n                    this.subscriptionCancelled = true;\n                }\n                reinstateSubscription() {\n                    this.subscriptionCancelled = false;\n                }\n                constructor(name, pusher){\n                    super(function(event, data) {\n                        logger.debug(\"No callbacks on \" + name + \" for \" + event);\n                    });\n                    this.name = name;\n                    this.pusher = pusher;\n                    this.subscribed = false;\n                    this.subscriptionPending = false;\n                    this.subscriptionCancelled = false;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/channels/private_channel.ts\n            class private_channel_PrivateChannel extends channel_Channel {\n                authorize(socketId, callback) {\n                    return this.pusher.config.channelAuthorizer({\n                        channelName: this.name,\n                        socketId: socketId\n                    }, callback);\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/channels/members.ts\n            class members_Members {\n                get(id) {\n                    if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n                        return {\n                            id: id,\n                            info: this.members[id]\n                        };\n                    } else {\n                        return null;\n                    }\n                }\n                each(callback) {\n                    objectApply(this.members, (member, id)=>{\n                        callback(this.get(id));\n                    });\n                }\n                setMyID(id) {\n                    this.myID = id;\n                }\n                onSubscription(subscriptionData) {\n                    this.members = subscriptionData.presence.hash;\n                    this.count = subscriptionData.presence.count;\n                    this.me = this.get(this.myID);\n                }\n                addMember(memberData) {\n                    if (this.get(memberData.user_id) === null) {\n                        this.count++;\n                    }\n                    this.members[memberData.user_id] = memberData.user_info;\n                    return this.get(memberData.user_id);\n                }\n                removeMember(memberData) {\n                    var member = this.get(memberData.user_id);\n                    if (member) {\n                        delete this.members[memberData.user_id];\n                        this.count--;\n                    }\n                    return member;\n                }\n                reset() {\n                    this.members = {};\n                    this.count = 0;\n                    this.myID = null;\n                    this.me = null;\n                }\n                constructor(){\n                    this.reset();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\n            var __awaiter =  false || function(thisArg, _arguments, P, generator) {\n                function adopt(value) {\n                    return value instanceof P ? value : new P(function(resolve) {\n                        resolve(value);\n                    });\n                }\n                return new (P || (P = Promise))(function(resolve, reject) {\n                    function fulfilled(value) {\n                        try {\n                            step(generator.next(value));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }\n                    function rejected(value) {\n                        try {\n                            step(generator[\"throw\"](value));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }\n                    function step(result) {\n                        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n                    }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };\n            class presence_channel_PresenceChannel extends private_channel_PrivateChannel {\n                authorize(socketId, callback) {\n                    super.authorize(socketId, (error, authData)=>__awaiter(this, void 0, void 0, function*() {\n                            if (!error) {\n                                authData = authData;\n                                if (authData.channel_data != null) {\n                                    var channelData = JSON.parse(authData.channel_data);\n                                    this.members.setMyID(channelData.user_id);\n                                } else {\n                                    yield this.pusher.user.signinDonePromise;\n                                    if (this.pusher.user.user_data != null) {\n                                        this.members.setMyID(this.pusher.user.user_data.id);\n                                    } else {\n                                        let suffix = url_store.buildLogSuffix(\"authorizationEndpoint\");\n                                        logger.error(\"Invalid auth response for channel '\".concat(this.name, \"', \") + \"expected 'channel_data' field. \".concat(suffix, \", \") + \"or the user should be signed in.\");\n                                        callback(\"Invalid auth response\");\n                                        return;\n                                    }\n                                }\n                            }\n                            callback(error, authData);\n                        }));\n                }\n                handleEvent(event) {\n                    var eventName = event.event;\n                    if (eventName.indexOf(\"pusher_internal:\") === 0) {\n                        this.handleInternalEvent(event);\n                    } else {\n                        var data = event.data;\n                        var metadata = {};\n                        if (event.user_id) {\n                            metadata.user_id = event.user_id;\n                        }\n                        this.emit(eventName, data, metadata);\n                    }\n                }\n                handleInternalEvent(event) {\n                    var eventName = event.event;\n                    var data = event.data;\n                    switch(eventName){\n                        case \"pusher_internal:subscription_succeeded\":\n                            this.handleSubscriptionSucceededEvent(event);\n                            break;\n                        case \"pusher_internal:subscription_count\":\n                            this.handleSubscriptionCountEvent(event);\n                            break;\n                        case \"pusher_internal:member_added\":\n                            var addedMember = this.members.addMember(data);\n                            this.emit(\"pusher:member_added\", addedMember);\n                            break;\n                        case \"pusher_internal:member_removed\":\n                            var removedMember = this.members.removeMember(data);\n                            if (removedMember) {\n                                this.emit(\"pusher:member_removed\", removedMember);\n                            }\n                            break;\n                    }\n                }\n                handleSubscriptionSucceededEvent(event) {\n                    this.subscriptionPending = false;\n                    this.subscribed = true;\n                    if (this.subscriptionCancelled) {\n                        this.pusher.unsubscribe(this.name);\n                    } else {\n                        this.members.onSubscription(event.data);\n                        this.emit(\"pusher:subscription_succeeded\", this.members);\n                    }\n                }\n                disconnect() {\n                    this.members.reset();\n                    super.disconnect();\n                }\n                constructor(name, pusher){\n                    super(name, pusher);\n                    this.members = new members_Members();\n                }\n            }\n            // EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\n            var utf8 = __nested_webpack_require_25511__(1);\n            // EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\n            var base64 = __nested_webpack_require_25511__(0);\n            // CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\n            class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {\n                authorize(socketId, callback) {\n                    super.authorize(socketId, (error, authData)=>{\n                        if (error) {\n                            callback(error, authData);\n                            return;\n                        }\n                        let sharedSecret = authData[\"shared_secret\"];\n                        if (!sharedSecret) {\n                            callback(new Error(\"No shared_secret key in auth payload for encrypted channel: \".concat(this.name)), null);\n                            return;\n                        }\n                        this.key = Object(base64[\"decode\"])(sharedSecret);\n                        delete authData[\"shared_secret\"];\n                        callback(null, authData);\n                    });\n                }\n                trigger(event, data) {\n                    throw new UnsupportedFeature(\"Client events are not currently supported for encrypted channels\");\n                }\n                handleEvent(event) {\n                    var eventName = event.event;\n                    var data = event.data;\n                    if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                        super.handleEvent(event);\n                        return;\n                    }\n                    this.handleEncryptedEvent(eventName, data);\n                }\n                handleEncryptedEvent(event, data) {\n                    if (!this.key) {\n                        logger.debug(\"Received encrypted event before key has been retrieved from the authEndpoint\");\n                        return;\n                    }\n                    if (!data.ciphertext || !data.nonce) {\n                        logger.error(\"Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: \" + data);\n                        return;\n                    }\n                    let cipherText = Object(base64[\"decode\"])(data.ciphertext);\n                    if (cipherText.length < this.nacl.secretbox.overheadLength) {\n                        logger.error(\"Expected encrypted event ciphertext length to be \".concat(this.nacl.secretbox.overheadLength, \", got: \").concat(cipherText.length));\n                        return;\n                    }\n                    let nonce = Object(base64[\"decode\"])(data.nonce);\n                    if (nonce.length < this.nacl.secretbox.nonceLength) {\n                        logger.error(\"Expected encrypted event nonce length to be \".concat(this.nacl.secretbox.nonceLength, \", got: \").concat(nonce.length));\n                        return;\n                    }\n                    let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                    if (bytes === null) {\n                        logger.debug(\"Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...\");\n                        this.authorize(this.pusher.connection.socket_id, (error, authData)=>{\n                            if (error) {\n                                logger.error(\"Failed to make a request to the authEndpoint: \".concat(authData, \". Unable to fetch new key, so dropping encrypted event\"));\n                                return;\n                            }\n                            bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                            if (bytes === null) {\n                                logger.error(\"Failed to decrypt event with new key. Dropping encrypted event\");\n                                return;\n                            }\n                            this.emit(event, this.getDataToEmit(bytes));\n                            return;\n                        });\n                        return;\n                    }\n                    this.emit(event, this.getDataToEmit(bytes));\n                }\n                getDataToEmit(bytes) {\n                    let raw = Object(utf8[\"decode\"])(bytes);\n                    try {\n                        return JSON.parse(raw);\n                    } catch (_a) {\n                        return raw;\n                    }\n                }\n                constructor(name, pusher, nacl){\n                    super(name, pusher);\n                    this.key = null;\n                    this.nacl = nacl;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\n            class connection_manager_ConnectionManager extends dispatcher_Dispatcher {\n                switchCluster(key) {\n                    this.key = key;\n                    this.updateStrategy();\n                    this.retryIn(0);\n                }\n                connect() {\n                    if (this.connection || this.runner) {\n                        return;\n                    }\n                    if (!this.strategy.isSupported()) {\n                        this.updateState(\"failed\");\n                        return;\n                    }\n                    this.updateState(\"connecting\");\n                    this.startConnecting();\n                    this.setUnavailableTimer();\n                }\n                send(data) {\n                    if (this.connection) {\n                        return this.connection.send(data);\n                    } else {\n                        return false;\n                    }\n                }\n                send_event(name, data, channel) {\n                    if (this.connection) {\n                        return this.connection.send_event(name, data, channel);\n                    } else {\n                        return false;\n                    }\n                }\n                disconnect() {\n                    this.disconnectInternally();\n                    this.updateState(\"disconnected\");\n                }\n                isUsingTLS() {\n                    return this.usingTLS;\n                }\n                startConnecting() {\n                    var callback = (error, handshake)=>{\n                        if (error) {\n                            this.runner = this.strategy.connect(0, callback);\n                        } else {\n                            if (handshake.action === \"error\") {\n                                this.emit(\"error\", {\n                                    type: \"HandshakeError\",\n                                    error: handshake.error\n                                });\n                                this.timeline.error({\n                                    handshakeError: handshake.error\n                                });\n                            } else {\n                                this.abortConnecting();\n                                this.handshakeCallbacks[handshake.action](handshake);\n                            }\n                        }\n                    };\n                    this.runner = this.strategy.connect(0, callback);\n                }\n                abortConnecting() {\n                    if (this.runner) {\n                        this.runner.abort();\n                        this.runner = null;\n                    }\n                }\n                disconnectInternally() {\n                    this.abortConnecting();\n                    this.clearRetryTimer();\n                    this.clearUnavailableTimer();\n                    if (this.connection) {\n                        var connection = this.abandonConnection();\n                        connection.close();\n                    }\n                }\n                updateStrategy() {\n                    this.strategy = this.options.getStrategy({\n                        key: this.key,\n                        timeline: this.timeline,\n                        useTLS: this.usingTLS\n                    });\n                }\n                retryIn(delay) {\n                    this.timeline.info({\n                        action: \"retry\",\n                        delay: delay\n                    });\n                    if (delay > 0) {\n                        this.emit(\"connecting_in\", Math.round(delay / 1000));\n                    }\n                    this.retryTimer = new timers_OneOffTimer(delay || 0, ()=>{\n                        this.disconnectInternally();\n                        this.connect();\n                    });\n                }\n                clearRetryTimer() {\n                    if (this.retryTimer) {\n                        this.retryTimer.ensureAborted();\n                        this.retryTimer = null;\n                    }\n                }\n                setUnavailableTimer() {\n                    this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, ()=>{\n                        this.updateState(\"unavailable\");\n                    });\n                }\n                clearUnavailableTimer() {\n                    if (this.unavailableTimer) {\n                        this.unavailableTimer.ensureAborted();\n                    }\n                }\n                sendActivityCheck() {\n                    this.stopActivityCheck();\n                    this.connection.ping();\n                    this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, ()=>{\n                        this.timeline.error({\n                            pong_timed_out: this.options.pongTimeout\n                        });\n                        this.retryIn(0);\n                    });\n                }\n                resetActivityCheck() {\n                    this.stopActivityCheck();\n                    if (this.connection && !this.connection.handlesActivityChecks()) {\n                        this.activityTimer = new timers_OneOffTimer(this.activityTimeout, ()=>{\n                            this.sendActivityCheck();\n                        });\n                    }\n                }\n                stopActivityCheck() {\n                    if (this.activityTimer) {\n                        this.activityTimer.ensureAborted();\n                    }\n                }\n                buildConnectionCallbacks(errorCallbacks) {\n                    return extend({}, errorCallbacks, {\n                        message: (message)=>{\n                            this.resetActivityCheck();\n                            this.emit(\"message\", message);\n                        },\n                        ping: ()=>{\n                            this.send_event(\"pusher:pong\", {});\n                        },\n                        activity: ()=>{\n                            this.resetActivityCheck();\n                        },\n                        error: (error)=>{\n                            this.emit(\"error\", error);\n                        },\n                        closed: ()=>{\n                            this.abandonConnection();\n                            if (this.shouldRetry()) {\n                                this.retryIn(1000);\n                            }\n                        }\n                    });\n                }\n                buildHandshakeCallbacks(errorCallbacks) {\n                    return extend({}, errorCallbacks, {\n                        connected: (handshake)=>{\n                            this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                            this.clearUnavailableTimer();\n                            this.setConnection(handshake.connection);\n                            this.socket_id = this.connection.id;\n                            this.updateState(\"connected\", {\n                                socket_id: this.socket_id\n                            });\n                        }\n                    });\n                }\n                buildErrorCallbacks() {\n                    let withErrorEmitted = (callback)=>{\n                        return (result)=>{\n                            if (result.error) {\n                                this.emit(\"error\", {\n                                    type: \"WebSocketError\",\n                                    error: result.error\n                                });\n                            }\n                            callback(result);\n                        };\n                    };\n                    return {\n                        tls_only: withErrorEmitted(()=>{\n                            this.usingTLS = true;\n                            this.updateStrategy();\n                            this.retryIn(0);\n                        }),\n                        refused: withErrorEmitted(()=>{\n                            this.disconnect();\n                        }),\n                        backoff: withErrorEmitted(()=>{\n                            this.retryIn(1000);\n                        }),\n                        retry: withErrorEmitted(()=>{\n                            this.retryIn(0);\n                        })\n                    };\n                }\n                setConnection(connection) {\n                    this.connection = connection;\n                    for(var event in this.connectionCallbacks){\n                        this.connection.bind(event, this.connectionCallbacks[event]);\n                    }\n                    this.resetActivityCheck();\n                }\n                abandonConnection() {\n                    if (!this.connection) {\n                        return;\n                    }\n                    this.stopActivityCheck();\n                    for(var event in this.connectionCallbacks){\n                        this.connection.unbind(event, this.connectionCallbacks[event]);\n                    }\n                    var connection = this.connection;\n                    this.connection = null;\n                    return connection;\n                }\n                updateState(newState, data) {\n                    var previousState = this.state;\n                    this.state = newState;\n                    if (previousState !== newState) {\n                        var newStateDescription = newState;\n                        if (newStateDescription === \"connected\") {\n                            newStateDescription += \" with new socket ID \" + data.socket_id;\n                        }\n                        logger.debug(\"State changed\", previousState + \" -> \" + newStateDescription);\n                        this.timeline.info({\n                            state: newState,\n                            params: data\n                        });\n                        this.emit(\"state_change\", {\n                            previous: previousState,\n                            current: newState\n                        });\n                        this.emit(newState, data);\n                    }\n                }\n                shouldRetry() {\n                    return this.state === \"connecting\" || this.state === \"connected\";\n                }\n                constructor(key, options){\n                    super();\n                    this.state = \"initialized\";\n                    this.connection = null;\n                    this.key = key;\n                    this.options = options;\n                    this.timeline = this.options.timeline;\n                    this.usingTLS = this.options.useTLS;\n                    this.errorCallbacks = this.buildErrorCallbacks();\n                    this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n                    this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n                    var Network = runtime.getNetwork();\n                    Network.bind(\"online\", ()=>{\n                        this.timeline.info({\n                            netinfo: \"online\"\n                        });\n                        if (this.state === \"connecting\" || this.state === \"unavailable\") {\n                            this.retryIn(0);\n                        }\n                    });\n                    Network.bind(\"offline\", ()=>{\n                        this.timeline.info({\n                            netinfo: \"offline\"\n                        });\n                        if (this.connection) {\n                            this.sendActivityCheck();\n                        }\n                    });\n                    this.updateStrategy();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/channels/channels.ts\n            class channels_Channels {\n                add(name, pusher) {\n                    if (!this.channels[name]) {\n                        this.channels[name] = createChannel(name, pusher);\n                    }\n                    return this.channels[name];\n                }\n                all() {\n                    return values(this.channels);\n                }\n                find(name) {\n                    return this.channels[name];\n                }\n                remove(name) {\n                    var channel = this.channels[name];\n                    delete this.channels[name];\n                    return channel;\n                }\n                disconnect() {\n                    objectApply(this.channels, function(channel) {\n                        channel.disconnect();\n                    });\n                }\n                constructor(){\n                    this.channels = {};\n                }\n            }\n            function createChannel(name, pusher) {\n                if (name.indexOf(\"private-encrypted-\") === 0) {\n                    if (pusher.config.nacl) {\n                        return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n                    }\n                    let errMsg = \"Tried to subscribe to a private-encrypted- channel but no nacl implementation available\";\n                    let suffix = url_store.buildLogSuffix(\"encryptedChannelSupport\");\n                    throw new UnsupportedFeature(\"\".concat(errMsg, \". \").concat(suffix));\n                } else if (name.indexOf(\"private-\") === 0) {\n                    return factory.createPrivateChannel(name, pusher);\n                } else if (name.indexOf(\"presence-\") === 0) {\n                    return factory.createPresenceChannel(name, pusher);\n                } else if (name.indexOf(\"#\") === 0) {\n                    throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n                } else {\n                    return factory.createChannel(name, pusher);\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/utils/factory.ts\n            var Factory = {\n                createChannels () {\n                    return new channels_Channels();\n                },\n                createConnectionManager (key, options) {\n                    return new connection_manager_ConnectionManager(key, options);\n                },\n                createChannel (name, pusher) {\n                    return new channel_Channel(name, pusher);\n                },\n                createPrivateChannel (name, pusher) {\n                    return new private_channel_PrivateChannel(name, pusher);\n                },\n                createPresenceChannel (name, pusher) {\n                    return new presence_channel_PresenceChannel(name, pusher);\n                },\n                createEncryptedChannel (name, pusher, nacl) {\n                    return new encrypted_channel_EncryptedChannel(name, pusher, nacl);\n                },\n                createTimelineSender (timeline, options) {\n                    return new timeline_sender_TimelineSender(timeline, options);\n                },\n                createHandshake (transport, callback) {\n                    return new handshake_Handshake(transport, callback);\n                },\n                createAssistantToTheTransportManager (manager, transport, options) {\n                    return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);\n                }\n            };\n            /* harmony default export */ var factory = Factory;\n            // CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n            class transport_manager_TransportManager {\n                getAssistant(transport) {\n                    return factory.createAssistantToTheTransportManager(this, transport, {\n                        minPingDelay: this.options.minPingDelay,\n                        maxPingDelay: this.options.maxPingDelay\n                    });\n                }\n                isAlive() {\n                    return this.livesLeft > 0;\n                }\n                reportDeath() {\n                    this.livesLeft -= 1;\n                }\n                constructor(options){\n                    this.options = options || {};\n                    this.livesLeft = this.options.lives || Infinity;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n            class sequential_strategy_SequentialStrategy {\n                isSupported() {\n                    return any(this.strategies, util.method(\"isSupported\"));\n                }\n                connect(minPriority, callback) {\n                    var strategies = this.strategies;\n                    var current = 0;\n                    var timeout = this.timeout;\n                    var runner = null;\n                    var tryNextStrategy = (error, handshake)=>{\n                        if (handshake) {\n                            callback(null, handshake);\n                        } else {\n                            current = current + 1;\n                            if (this.loop) {\n                                current = current % strategies.length;\n                            }\n                            if (current < strategies.length) {\n                                if (timeout) {\n                                    timeout = timeout * 2;\n                                    if (this.timeoutLimit) {\n                                        timeout = Math.min(timeout, this.timeoutLimit);\n                                    }\n                                }\n                                runner = this.tryStrategy(strategies[current], minPriority, {\n                                    timeout,\n                                    failFast: this.failFast\n                                }, tryNextStrategy);\n                            } else {\n                                callback(true);\n                            }\n                        }\n                    };\n                    runner = this.tryStrategy(strategies[current], minPriority, {\n                        timeout: timeout,\n                        failFast: this.failFast\n                    }, tryNextStrategy);\n                    return {\n                        abort: function() {\n                            runner.abort();\n                        },\n                        forceMinPriority: function(p) {\n                            minPriority = p;\n                            if (runner) {\n                                runner.forceMinPriority(p);\n                            }\n                        }\n                    };\n                }\n                tryStrategy(strategy, minPriority, options, callback) {\n                    var timer = null;\n                    var runner = null;\n                    if (options.timeout > 0) {\n                        timer = new timers_OneOffTimer(options.timeout, function() {\n                            runner.abort();\n                            callback(true);\n                        });\n                    }\n                    runner = strategy.connect(minPriority, function(error, handshake) {\n                        if (error && timer && timer.isRunning() && !options.failFast) {\n                            return;\n                        }\n                        if (timer) {\n                            timer.ensureAborted();\n                        }\n                        callback(error, handshake);\n                    });\n                    return {\n                        abort: function() {\n                            if (timer) {\n                                timer.ensureAborted();\n                            }\n                            runner.abort();\n                        },\n                        forceMinPriority: function(p) {\n                            runner.forceMinPriority(p);\n                        }\n                    };\n                }\n                constructor(strategies, options){\n                    this.strategies = strategies;\n                    this.loop = Boolean(options.loop);\n                    this.failFast = Boolean(options.failFast);\n                    this.timeout = options.timeout;\n                    this.timeoutLimit = options.timeoutLimit;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n            class best_connected_ever_strategy_BestConnectedEverStrategy {\n                isSupported() {\n                    return any(this.strategies, util.method(\"isSupported\"));\n                }\n                connect(minPriority, callback) {\n                    return connect(this.strategies, minPriority, function(i, runners) {\n                        return function(error, handshake) {\n                            runners[i].error = error;\n                            if (error) {\n                                if (allRunnersFailed(runners)) {\n                                    callback(true);\n                                }\n                                return;\n                            }\n                            apply(runners, function(runner) {\n                                runner.forceMinPriority(handshake.transport.priority);\n                            });\n                            callback(null, handshake);\n                        };\n                    });\n                }\n                constructor(strategies){\n                    this.strategies = strategies;\n                }\n            }\n            function connect(strategies, minPriority, callbackBuilder) {\n                var runners = map(strategies, function(strategy, i, _, rs) {\n                    return strategy.connect(minPriority, callbackBuilder(i, rs));\n                });\n                return {\n                    abort: function() {\n                        apply(runners, abortRunner);\n                    },\n                    forceMinPriority: function(p) {\n                        apply(runners, function(runner) {\n                            runner.forceMinPriority(p);\n                        });\n                    }\n                };\n            }\n            function allRunnersFailed(runners) {\n                return collections_all(runners, function(runner) {\n                    return Boolean(runner.error);\n                });\n            }\n            function abortRunner(runner) {\n                if (!runner.error && !runner.aborted) {\n                    runner.abort();\n                    runner.aborted = true;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/websocket_prioritized_cached_strategy.ts\n            class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {\n                isSupported() {\n                    return this.strategy.isSupported();\n                }\n                connect(minPriority, callback) {\n                    var usingTLS = this.usingTLS;\n                    var info = fetchTransportCache(usingTLS);\n                    var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;\n                    var strategies = [\n                        this.strategy\n                    ];\n                    if (info && info.timestamp + this.ttl >= util.now()) {\n                        var transport = this.transports[info.transport];\n                        if (transport) {\n                            if ([\n                                \"ws\",\n                                \"wss\"\n                            ].includes(info.transport) || cacheSkipCount > 3) {\n                                this.timeline.info({\n                                    cached: true,\n                                    transport: info.transport,\n                                    latency: info.latency\n                                });\n                                strategies.push(new sequential_strategy_SequentialStrategy([\n                                    transport\n                                ], {\n                                    timeout: info.latency * 2 + 1000,\n                                    failFast: true\n                                }));\n                            } else {\n                                cacheSkipCount++;\n                            }\n                        }\n                    }\n                    var startTimestamp = util.now();\n                    var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {\n                        if (error) {\n                            flushTransportCache(usingTLS);\n                            if (strategies.length > 0) {\n                                startTimestamp = util.now();\n                                runner = strategies.pop().connect(minPriority, cb);\n                            } else {\n                                callback(error);\n                            }\n                        } else {\n                            storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);\n                            callback(null, handshake);\n                        }\n                    });\n                    return {\n                        abort: function() {\n                            runner.abort();\n                        },\n                        forceMinPriority: function(p) {\n                            minPriority = p;\n                            if (runner) {\n                                runner.forceMinPriority(p);\n                            }\n                        }\n                    };\n                }\n                constructor(strategy, transports, options){\n                    this.strategy = strategy;\n                    this.transports = transports;\n                    this.ttl = options.ttl || 1800 * 1000;\n                    this.usingTLS = options.useTLS;\n                    this.timeline = options.timeline;\n                }\n            }\n            function getTransportCacheKey(usingTLS) {\n                return \"pusherTransport\" + (usingTLS ? \"TLS\" : \"NonTLS\");\n            }\n            function fetchTransportCache(usingTLS) {\n                var storage = runtime.getLocalStorage();\n                if (storage) {\n                    try {\n                        var serializedCache = storage[getTransportCacheKey(usingTLS)];\n                        if (serializedCache) {\n                            return JSON.parse(serializedCache);\n                        }\n                    } catch (e) {\n                        flushTransportCache(usingTLS);\n                    }\n                }\n                return null;\n            }\n            function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {\n                var storage = runtime.getLocalStorage();\n                if (storage) {\n                    try {\n                        storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                            timestamp: util.now(),\n                            transport: transport,\n                            latency: latency,\n                            cacheSkipCount: cacheSkipCount\n                        });\n                    } catch (e) {}\n                }\n            }\n            function flushTransportCache(usingTLS) {\n                var storage = runtime.getLocalStorage();\n                if (storage) {\n                    try {\n                        delete storage[getTransportCacheKey(usingTLS)];\n                    } catch (e) {}\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n            class delayed_strategy_DelayedStrategy {\n                isSupported() {\n                    return this.strategy.isSupported();\n                }\n                connect(minPriority, callback) {\n                    var strategy = this.strategy;\n                    var runner;\n                    var timer = new timers_OneOffTimer(this.options.delay, function() {\n                        runner = strategy.connect(minPriority, callback);\n                    });\n                    return {\n                        abort: function() {\n                            timer.ensureAborted();\n                            if (runner) {\n                                runner.abort();\n                            }\n                        },\n                        forceMinPriority: function(p) {\n                            minPriority = p;\n                            if (runner) {\n                                runner.forceMinPriority(p);\n                            }\n                        }\n                    };\n                }\n                constructor(strategy, { delay: number }){\n                    this.strategy = strategy;\n                    this.options = {\n                        delay: number\n                    };\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\n            class IfStrategy {\n                isSupported() {\n                    var branch = this.test() ? this.trueBranch : this.falseBranch;\n                    return branch.isSupported();\n                }\n                connect(minPriority, callback) {\n                    var branch = this.test() ? this.trueBranch : this.falseBranch;\n                    return branch.connect(minPriority, callback);\n                }\n                constructor(test, trueBranch, falseBranch){\n                    this.test = test;\n                    this.trueBranch = trueBranch;\n                    this.falseBranch = falseBranch;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\n            class FirstConnectedStrategy {\n                isSupported() {\n                    return this.strategy.isSupported();\n                }\n                connect(minPriority, callback) {\n                    var runner = this.strategy.connect(minPriority, function(error, handshake) {\n                        if (handshake) {\n                            runner.abort();\n                        }\n                        callback(error, handshake);\n                    });\n                    return runner;\n                }\n                constructor(strategy){\n                    this.strategy = strategy;\n                }\n            }\n            // CONCATENATED MODULE: ./src/runtimes/web/default_strategy.ts\n            function testSupportsStrategy(strategy) {\n                return function() {\n                    return strategy.isSupported();\n                };\n            }\n            var getDefaultStrategy = function(config, baseOptions, defineTransport) {\n                var definedTransports = {};\n                function defineTransportStrategy(name, type, priority, options, manager) {\n                    var transport = defineTransport(config, name, type, priority, options, manager);\n                    definedTransports[name] = transport;\n                    return transport;\n                }\n                var ws_options = Object.assign({}, baseOptions, {\n                    hostNonTLS: config.wsHost + \":\" + config.wsPort,\n                    hostTLS: config.wsHost + \":\" + config.wssPort,\n                    httpPath: config.wsPath\n                });\n                var wss_options = Object.assign({}, ws_options, {\n                    useTLS: true\n                });\n                var sockjs_options = Object.assign({}, baseOptions, {\n                    hostNonTLS: config.httpHost + \":\" + config.httpPort,\n                    hostTLS: config.httpHost + \":\" + config.httpsPort,\n                    httpPath: config.httpPath\n                });\n                var timeouts = {\n                    loop: true,\n                    timeout: 15000,\n                    timeoutLimit: 60000\n                };\n                var ws_manager = new transport_manager_TransportManager({\n                    minPingDelay: 10000,\n                    maxPingDelay: config.activityTimeout\n                });\n                var streaming_manager = new transport_manager_TransportManager({\n                    lives: 2,\n                    minPingDelay: 10000,\n                    maxPingDelay: config.activityTimeout\n                });\n                var ws_transport = defineTransportStrategy(\"ws\", \"ws\", 3, ws_options, ws_manager);\n                var wss_transport = defineTransportStrategy(\"wss\", \"ws\", 3, wss_options, ws_manager);\n                var sockjs_transport = defineTransportStrategy(\"sockjs\", \"sockjs\", 1, sockjs_options);\n                var xhr_streaming_transport = defineTransportStrategy(\"xhr_streaming\", \"xhr_streaming\", 1, sockjs_options, streaming_manager);\n                var xdr_streaming_transport = defineTransportStrategy(\"xdr_streaming\", \"xdr_streaming\", 1, sockjs_options, streaming_manager);\n                var xhr_polling_transport = defineTransportStrategy(\"xhr_polling\", \"xhr_polling\", 1, sockjs_options);\n                var xdr_polling_transport = defineTransportStrategy(\"xdr_polling\", \"xdr_polling\", 1, sockjs_options);\n                var ws_loop = new sequential_strategy_SequentialStrategy([\n                    ws_transport\n                ], timeouts);\n                var wss_loop = new sequential_strategy_SequentialStrategy([\n                    wss_transport\n                ], timeouts);\n                var sockjs_loop = new sequential_strategy_SequentialStrategy([\n                    sockjs_transport\n                ], timeouts);\n                var streaming_loop = new sequential_strategy_SequentialStrategy([\n                    new IfStrategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)\n                ], timeouts);\n                var polling_loop = new sequential_strategy_SequentialStrategy([\n                    new IfStrategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)\n                ], timeouts);\n                var http_loop = new sequential_strategy_SequentialStrategy([\n                    new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([\n                        streaming_loop,\n                        new delayed_strategy_DelayedStrategy(polling_loop, {\n                            delay: 4000\n                        })\n                    ]), polling_loop)\n                ], timeouts);\n                var http_fallback_loop = new IfStrategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);\n                var wsStrategy;\n                if (baseOptions.useTLS) {\n                    wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                        ws_loop,\n                        new delayed_strategy_DelayedStrategy(http_fallback_loop, {\n                            delay: 2000\n                        })\n                    ]);\n                } else {\n                    wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                        ws_loop,\n                        new delayed_strategy_DelayedStrategy(wss_loop, {\n                            delay: 2000\n                        }),\n                        new delayed_strategy_DelayedStrategy(http_fallback_loop, {\n                            delay: 5000\n                        })\n                    ]);\n                }\n                return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {\n                    ttl: 1800000,\n                    timeline: baseOptions.timeline,\n                    useTLS: baseOptions.useTLS\n                });\n            };\n            /* harmony default export */ var default_strategy = getDefaultStrategy;\n            // CONCATENATED MODULE: ./src/runtimes/web/transports/transport_connection_initializer.ts\n            /* harmony default export */ var transport_connection_initializer = function() {\n                var self = this;\n                self.timeline.info(self.buildTimelineMessage({\n                    transport: self.name + (self.options.useTLS ? \"s\" : \"\")\n                }));\n                if (self.hooks.isInitialized()) {\n                    self.changeState(\"initialized\");\n                } else if (self.hooks.file) {\n                    self.changeState(\"initializing\");\n                    Dependencies.load(self.hooks.file, {\n                        useTLS: self.options.useTLS\n                    }, function(error, callback) {\n                        if (self.hooks.isInitialized()) {\n                            self.changeState(\"initialized\");\n                            callback(true);\n                        } else {\n                            if (error) {\n                                self.onError(error);\n                            }\n                            self.onClose();\n                            callback(false);\n                        }\n                    });\n                } else {\n                    self.onClose();\n                }\n            };\n            // CONCATENATED MODULE: ./src/runtimes/web/http/http_xdomain_request.ts\n            var http_xdomain_request_hooks = {\n                getRequest: function(socket) {\n                    var xdr = new window.XDomainRequest();\n                    xdr.ontimeout = function() {\n                        socket.emit(\"error\", new RequestTimedOut());\n                        socket.close();\n                    };\n                    xdr.onerror = function(e) {\n                        socket.emit(\"error\", e);\n                        socket.close();\n                    };\n                    xdr.onprogress = function() {\n                        if (xdr.responseText && xdr.responseText.length > 0) {\n                            socket.onChunk(200, xdr.responseText);\n                        }\n                    };\n                    xdr.onload = function() {\n                        if (xdr.responseText && xdr.responseText.length > 0) {\n                            socket.onChunk(200, xdr.responseText);\n                        }\n                        socket.emit(\"finished\", 200);\n                        socket.close();\n                    };\n                    return xdr;\n                },\n                abortRequest: function(xdr) {\n                    xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;\n                    xdr.abort();\n                }\n            };\n            /* harmony default export */ var http_xdomain_request = http_xdomain_request_hooks;\n            // CONCATENATED MODULE: ./src/core/http/http_request.ts\n            const MAX_BUFFER_LENGTH = 256 * 1024;\n            class http_request_HTTPRequest extends dispatcher_Dispatcher {\n                start(payload) {\n                    this.position = 0;\n                    this.xhr = this.hooks.getRequest(this);\n                    this.unloader = ()=>{\n                        this.close();\n                    };\n                    runtime.addUnloadListener(this.unloader);\n                    this.xhr.open(this.method, this.url, true);\n                    if (this.xhr.setRequestHeader) {\n                        this.xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n                    }\n                    this.xhr.send(payload);\n                }\n                close() {\n                    if (this.unloader) {\n                        runtime.removeUnloadListener(this.unloader);\n                        this.unloader = null;\n                    }\n                    if (this.xhr) {\n                        this.hooks.abortRequest(this.xhr);\n                        this.xhr = null;\n                    }\n                }\n                onChunk(status, data) {\n                    while(true){\n                        var chunk = this.advanceBuffer(data);\n                        if (chunk) {\n                            this.emit(\"chunk\", {\n                                status: status,\n                                data: chunk\n                            });\n                        } else {\n                            break;\n                        }\n                    }\n                    if (this.isBufferTooLong(data)) {\n                        this.emit(\"buffer_too_long\");\n                    }\n                }\n                advanceBuffer(buffer) {\n                    var unreadData = buffer.slice(this.position);\n                    var endOfLinePosition = unreadData.indexOf(\"\\n\");\n                    if (endOfLinePosition !== -1) {\n                        this.position += endOfLinePosition + 1;\n                        return unreadData.slice(0, endOfLinePosition);\n                    } else {\n                        return null;\n                    }\n                }\n                isBufferTooLong(buffer) {\n                    return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n                }\n                constructor(hooks, method, url){\n                    super();\n                    this.hooks = hooks;\n                    this.method = method;\n                    this.url = url;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/http/state.ts\n            var State;\n            (function(State) {\n                State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n                State[State[\"OPEN\"] = 1] = \"OPEN\";\n                State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n            })(State || (State = {}));\n            /* harmony default export */ var state = State;\n            // CONCATENATED MODULE: ./src/core/http/http_socket.ts\n            var autoIncrement = 1;\n            class http_socket_HTTPSocket {\n                send(payload) {\n                    return this.sendRaw(JSON.stringify([\n                        payload\n                    ]));\n                }\n                ping() {\n                    this.hooks.sendHeartbeat(this);\n                }\n                close(code, reason) {\n                    this.onClose(code, reason, true);\n                }\n                sendRaw(payload) {\n                    if (this.readyState === state.OPEN) {\n                        try {\n                            runtime.createSocketRequest(\"POST\", getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                            return true;\n                        } catch (e) {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n                reconnect() {\n                    this.closeStream();\n                    this.openStream();\n                }\n                onClose(code, reason, wasClean) {\n                    this.closeStream();\n                    this.readyState = state.CLOSED;\n                    if (this.onclose) {\n                        this.onclose({\n                            code: code,\n                            reason: reason,\n                            wasClean: wasClean\n                        });\n                    }\n                }\n                onChunk(chunk) {\n                    if (chunk.status !== 200) {\n                        return;\n                    }\n                    if (this.readyState === state.OPEN) {\n                        this.onActivity();\n                    }\n                    var payload;\n                    var type = chunk.data.slice(0, 1);\n                    switch(type){\n                        case \"o\":\n                            payload = JSON.parse(chunk.data.slice(1) || \"{}\");\n                            this.onOpen(payload);\n                            break;\n                        case \"a\":\n                            payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                            for(var i = 0; i < payload.length; i++){\n                                this.onEvent(payload[i]);\n                            }\n                            break;\n                        case \"m\":\n                            payload = JSON.parse(chunk.data.slice(1) || \"null\");\n                            this.onEvent(payload);\n                            break;\n                        case \"h\":\n                            this.hooks.onHeartbeat(this);\n                            break;\n                        case \"c\":\n                            payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                            this.onClose(payload[0], payload[1], true);\n                            break;\n                    }\n                }\n                onOpen(options) {\n                    if (this.readyState === state.CONNECTING) {\n                        if (options && options.hostname) {\n                            this.location.base = replaceHost(this.location.base, options.hostname);\n                        }\n                        this.readyState = state.OPEN;\n                        if (this.onopen) {\n                            this.onopen();\n                        }\n                    } else {\n                        this.onClose(1006, \"Server lost session\", true);\n                    }\n                }\n                onEvent(event) {\n                    if (this.readyState === state.OPEN && this.onmessage) {\n                        this.onmessage({\n                            data: event\n                        });\n                    }\n                }\n                onActivity() {\n                    if (this.onactivity) {\n                        this.onactivity();\n                    }\n                }\n                onError(error) {\n                    if (this.onerror) {\n                        this.onerror(error);\n                    }\n                }\n                openStream() {\n                    this.stream = runtime.createSocketRequest(\"POST\", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n                    this.stream.bind(\"chunk\", (chunk)=>{\n                        this.onChunk(chunk);\n                    });\n                    this.stream.bind(\"finished\", (status)=>{\n                        this.hooks.onFinished(this, status);\n                    });\n                    this.stream.bind(\"buffer_too_long\", ()=>{\n                        this.reconnect();\n                    });\n                    try {\n                        this.stream.start();\n                    } catch (error) {\n                        util.defer(()=>{\n                            this.onError(error);\n                            this.onClose(1006, \"Could not start streaming\", false);\n                        });\n                    }\n                }\n                closeStream() {\n                    if (this.stream) {\n                        this.stream.unbind_all();\n                        this.stream.close();\n                        this.stream = null;\n                    }\n                }\n                constructor(hooks, url){\n                    this.hooks = hooks;\n                    this.session = randomNumber(1000) + \"/\" + randomString(8);\n                    this.location = getLocation(url);\n                    this.readyState = state.CONNECTING;\n                    this.openStream();\n                }\n            }\n            function getLocation(url) {\n                var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n                return {\n                    base: parts[1],\n                    queryString: parts[2]\n                };\n            }\n            function getSendURL(url, session) {\n                return url.base + \"/\" + session + \"/xhr_send\";\n            }\n            function getUniqueURL(url) {\n                var separator = url.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n                return url + separator + \"t=\" + +new Date() + \"&n=\" + autoIncrement++;\n            }\n            function replaceHost(url, hostname) {\n                var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n                return urlParts[1] + hostname + urlParts[3];\n            }\n            function randomNumber(max) {\n                return runtime.randomInt(max);\n            }\n            function randomString(length) {\n                var result = [];\n                for(var i = 0; i < length; i++){\n                    result.push(randomNumber(32).toString(32));\n                }\n                return result.join(\"\");\n            }\n            /* harmony default export */ var http_socket = http_socket_HTTPSocket;\n            // CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\n            var http_streaming_socket_hooks = {\n                getReceiveURL: function(url, session) {\n                    return url.base + \"/\" + session + \"/xhr_streaming\" + url.queryString;\n                },\n                onHeartbeat: function(socket) {\n                    socket.sendRaw(\"[]\");\n                },\n                sendHeartbeat: function(socket) {\n                    socket.sendRaw(\"[]\");\n                },\n                onFinished: function(socket, status) {\n                    socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n                }\n            };\n            /* harmony default export */ var http_streaming_socket = http_streaming_socket_hooks;\n            // CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\n            var http_polling_socket_hooks = {\n                getReceiveURL: function(url, session) {\n                    return url.base + \"/\" + session + \"/xhr\" + url.queryString;\n                },\n                onHeartbeat: function() {},\n                sendHeartbeat: function(socket) {\n                    socket.sendRaw(\"[]\");\n                },\n                onFinished: function(socket, status) {\n                    if (status === 200) {\n                        socket.reconnect();\n                    } else {\n                        socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n                    }\n                }\n            };\n            /* harmony default export */ var http_polling_socket = http_polling_socket_hooks;\n            // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n            var http_xhr_request_hooks = {\n                getRequest: function(socket) {\n                    var Constructor = runtime.getXHRAPI();\n                    var xhr = new Constructor();\n                    xhr.onreadystatechange = xhr.onprogress = function() {\n                        switch(xhr.readyState){\n                            case 3:\n                                if (xhr.responseText && xhr.responseText.length > 0) {\n                                    socket.onChunk(xhr.status, xhr.responseText);\n                                }\n                                break;\n                            case 4:\n                                if (xhr.responseText && xhr.responseText.length > 0) {\n                                    socket.onChunk(xhr.status, xhr.responseText);\n                                }\n                                socket.emit(\"finished\", xhr.status);\n                                socket.close();\n                                break;\n                        }\n                    };\n                    return xhr;\n                },\n                abortRequest: function(xhr) {\n                    xhr.onreadystatechange = null;\n                    xhr.abort();\n                }\n            };\n            /* harmony default export */ var http_xhr_request = http_xhr_request_hooks;\n            // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n            var HTTP = {\n                createStreamingSocket (url) {\n                    return this.createSocket(http_streaming_socket, url);\n                },\n                createPollingSocket (url) {\n                    return this.createSocket(http_polling_socket, url);\n                },\n                createSocket (hooks, url) {\n                    return new http_socket(hooks, url);\n                },\n                createXHR (method, url) {\n                    return this.createRequest(http_xhr_request, method, url);\n                },\n                createRequest (hooks, method, url) {\n                    return new http_request_HTTPRequest(hooks, method, url);\n                }\n            };\n            /* harmony default export */ var http_http = HTTP;\n            // CONCATENATED MODULE: ./src/runtimes/web/http/http.ts\n            http_http.createXDR = function(method, url) {\n                return this.createRequest(http_xdomain_request, method, url);\n            };\n            /* harmony default export */ var web_http_http = http_http;\n            // CONCATENATED MODULE: ./src/runtimes/web/runtime.ts\n            var Runtime = {\n                nextAuthCallbackID: 1,\n                auth_callbacks: {},\n                ScriptReceivers: ScriptReceivers,\n                DependenciesReceivers: DependenciesReceivers,\n                getDefaultStrategy: default_strategy,\n                Transports: transports_transports,\n                transportConnectionInitializer: transport_connection_initializer,\n                HTTPFactory: web_http_http,\n                TimelineTransport: jsonp_timeline,\n                getXHRAPI () {\n                    return window.XMLHttpRequest;\n                },\n                getWebSocketAPI () {\n                    return window.WebSocket || window.MozWebSocket;\n                },\n                setup (PusherClass) {\n                    window.Pusher = PusherClass;\n                    var initializeOnDocumentBody = ()=>{\n                        this.onDocumentBody(PusherClass.ready);\n                    };\n                    if (!window.JSON) {\n                        Dependencies.load(\"json2\", {}, initializeOnDocumentBody);\n                    } else {\n                        initializeOnDocumentBody();\n                    }\n                },\n                getDocument () {\n                    return document;\n                },\n                getProtocol () {\n                    return this.getDocument().location.protocol;\n                },\n                getAuthorizers () {\n                    return {\n                        ajax: xhr_auth,\n                        jsonp: jsonp_auth\n                    };\n                },\n                onDocumentBody (callback) {\n                    if (document.body) {\n                        callback();\n                    } else {\n                        setTimeout(()=>{\n                            this.onDocumentBody(callback);\n                        }, 0);\n                    }\n                },\n                createJSONPRequest (url, data) {\n                    return new jsonp_request_JSONPRequest(url, data);\n                },\n                createScriptRequest (src) {\n                    return new ScriptRequest(src);\n                },\n                getLocalStorage () {\n                    try {\n                        return window.localStorage;\n                    } catch (e) {\n                        return undefined;\n                    }\n                },\n                createXHR () {\n                    if (this.getXHRAPI()) {\n                        return this.createXMLHttpRequest();\n                    } else {\n                        return this.createMicrosoftXHR();\n                    }\n                },\n                createXMLHttpRequest () {\n                    var Constructor = this.getXHRAPI();\n                    return new Constructor();\n                },\n                createMicrosoftXHR () {\n                    return new ActiveXObject(\"Microsoft.XMLHTTP\");\n                },\n                getNetwork () {\n                    return net_info_Network;\n                },\n                createWebSocket (url) {\n                    var Constructor = this.getWebSocketAPI();\n                    return new Constructor(url);\n                },\n                createSocketRequest (method, url) {\n                    if (this.isXHRSupported()) {\n                        return this.HTTPFactory.createXHR(method, url);\n                    } else if (this.isXDRSupported(url.indexOf(\"https:\") === 0)) {\n                        return this.HTTPFactory.createXDR(method, url);\n                    } else {\n                        throw \"Cross-origin HTTP requests are not supported\";\n                    }\n                },\n                isXHRSupported () {\n                    var Constructor = this.getXHRAPI();\n                    return Boolean(Constructor) && new Constructor().withCredentials !== undefined;\n                },\n                isXDRSupported (useTLS) {\n                    var protocol = useTLS ? \"https:\" : \"http:\";\n                    var documentProtocol = this.getProtocol();\n                    return Boolean(window[\"XDomainRequest\"]) && documentProtocol === protocol;\n                },\n                addUnloadListener (listener) {\n                    if (window.addEventListener !== undefined) {\n                        window.addEventListener(\"unload\", listener, false);\n                    } else if (window.attachEvent !== undefined) {\n                        window.attachEvent(\"onunload\", listener);\n                    }\n                },\n                removeUnloadListener (listener) {\n                    if (window.addEventListener !== undefined) {\n                        window.removeEventListener(\"unload\", listener, false);\n                    } else if (window.detachEvent !== undefined) {\n                        window.detachEvent(\"onunload\", listener);\n                    }\n                },\n                randomInt (max) {\n                    const random = function() {\n                        const crypto = window.crypto || window[\"msCrypto\"];\n                        const random = crypto.getRandomValues(new Uint32Array(1))[0];\n                        return random / Math.pow(2, 32);\n                    };\n                    return Math.floor(random() * max);\n                }\n            };\n            /* harmony default export */ var runtime = Runtime;\n            // CONCATENATED MODULE: ./src/core/timeline/level.ts\n            var TimelineLevel;\n            (function(TimelineLevel) {\n                TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n                TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n                TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n            })(TimelineLevel || (TimelineLevel = {}));\n            /* harmony default export */ var timeline_level = TimelineLevel;\n            // CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n            class timeline_Timeline {\n                log(level, event) {\n                    if (level <= this.options.level) {\n                        this.events.push(extend({}, event, {\n                            timestamp: util.now()\n                        }));\n                        if (this.options.limit && this.events.length > this.options.limit) {\n                            this.events.shift();\n                        }\n                    }\n                }\n                error(event) {\n                    this.log(timeline_level.ERROR, event);\n                }\n                info(event) {\n                    this.log(timeline_level.INFO, event);\n                }\n                debug(event) {\n                    this.log(timeline_level.DEBUG, event);\n                }\n                isEmpty() {\n                    return this.events.length === 0;\n                }\n                send(sendfn, callback) {\n                    var data = extend({\n                        session: this.session,\n                        bundle: this.sent + 1,\n                        key: this.key,\n                        lib: \"js\",\n                        version: this.options.version,\n                        cluster: this.options.cluster,\n                        features: this.options.features,\n                        timeline: this.events\n                    }, this.options.params);\n                    this.events = [];\n                    sendfn(data, (error, result)=>{\n                        if (!error) {\n                            this.sent++;\n                        }\n                        if (callback) {\n                            callback(error, result);\n                        }\n                    });\n                    return true;\n                }\n                generateUniqueID() {\n                    this.uniqueID++;\n                    return this.uniqueID;\n                }\n                constructor(key, session, options){\n                    this.key = key;\n                    this.session = session;\n                    this.events = [];\n                    this.options = options || {};\n                    this.sent = 0;\n                    this.uniqueID = 0;\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n            class transport_strategy_TransportStrategy {\n                isSupported() {\n                    return this.transport.isSupported({\n                        useTLS: this.options.useTLS\n                    });\n                }\n                connect(minPriority, callback) {\n                    if (!this.isSupported()) {\n                        return failAttempt(new UnsupportedStrategy(), callback);\n                    } else if (this.priority < minPriority) {\n                        return failAttempt(new TransportPriorityTooLow(), callback);\n                    }\n                    var connected = false;\n                    var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n                    var handshake = null;\n                    var onInitialized = function() {\n                        transport.unbind(\"initialized\", onInitialized);\n                        transport.connect();\n                    };\n                    var onOpen = function() {\n                        handshake = factory.createHandshake(transport, function(result) {\n                            connected = true;\n                            unbindListeners();\n                            callback(null, result);\n                        });\n                    };\n                    var onError = function(error) {\n                        unbindListeners();\n                        callback(error);\n                    };\n                    var onClosed = function() {\n                        unbindListeners();\n                        var serializedTransport;\n                        serializedTransport = safeJSONStringify(transport);\n                        callback(new TransportClosed(serializedTransport));\n                    };\n                    var unbindListeners = function() {\n                        transport.unbind(\"initialized\", onInitialized);\n                        transport.unbind(\"open\", onOpen);\n                        transport.unbind(\"error\", onError);\n                        transport.unbind(\"closed\", onClosed);\n                    };\n                    transport.bind(\"initialized\", onInitialized);\n                    transport.bind(\"open\", onOpen);\n                    transport.bind(\"error\", onError);\n                    transport.bind(\"closed\", onClosed);\n                    transport.initialize();\n                    return {\n                        abort: ()=>{\n                            if (connected) {\n                                return;\n                            }\n                            unbindListeners();\n                            if (handshake) {\n                                handshake.close();\n                            } else {\n                                transport.close();\n                            }\n                        },\n                        forceMinPriority: (p)=>{\n                            if (connected) {\n                                return;\n                            }\n                            if (this.priority < p) {\n                                if (handshake) {\n                                    handshake.close();\n                                } else {\n                                    transport.close();\n                                }\n                            }\n                        }\n                    };\n                }\n                constructor(name, priority, transport, options){\n                    this.name = name;\n                    this.priority = priority;\n                    this.transport = transport;\n                    this.options = options || {};\n                }\n            }\n            function failAttempt(error, callback) {\n                util.defer(function() {\n                    callback(error);\n                });\n                return {\n                    abort: function() {},\n                    forceMinPriority: function() {}\n                };\n            }\n            // CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n            const { Transports: strategy_builder_Transports } = runtime;\n            var strategy_builder_defineTransport = function(config, name, type, priority, options, manager) {\n                var transportClass = strategy_builder_Transports[type];\n                if (!transportClass) {\n                    throw new UnsupportedTransport(type);\n                }\n                var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name) === -1);\n                var transport;\n                if (enabled) {\n                    options = Object.assign({\n                        ignoreNullOrigin: config.ignoreNullOrigin\n                    }, options);\n                    transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n                } else {\n                    transport = strategy_builder_UnsupportedStrategy;\n                }\n                return transport;\n            };\n            var strategy_builder_UnsupportedStrategy = {\n                isSupported: function() {\n                    return false;\n                },\n                connect: function(_, callback) {\n                    var deferred = util.defer(function() {\n                        callback(new UnsupportedStrategy());\n                    });\n                    return {\n                        abort: function() {\n                            deferred.ensureAborted();\n                        },\n                        forceMinPriority: function() {}\n                    };\n                }\n            };\n            // CONCATENATED MODULE: ./src/core/options.ts\n            function validateOptions(options) {\n                if (options == null) {\n                    throw \"You must pass an options object\";\n                }\n                if (options.cluster == null) {\n                    throw \"Options object must provide a cluster\";\n                }\n                if (\"disableStats\" in options) {\n                    logger.warn(\"The disableStats option is deprecated in favor of enableStats\");\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n            const composeChannelQuery = (params, authOptions)=>{\n                var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n                for(var key in authOptions.params){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n                }\n                if (authOptions.paramsProvider != null) {\n                    let dynamicParams = authOptions.paramsProvider();\n                    for(var key in dynamicParams){\n                        query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                    }\n                }\n                return query;\n            };\n            const UserAuthenticator = (authOptions)=>{\n                if (typeof runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                    throw \"'\".concat(authOptions.transport, \"' is not a recognized auth transport\");\n                }\n                return (params, callback)=>{\n                    const query = composeChannelQuery(params, authOptions);\n                    runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n                };\n            };\n            /* harmony default export */ var user_authenticator = UserAuthenticator;\n            // CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n            const channel_authorizer_composeChannelQuery = (params, authOptions)=>{\n                var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n                query += \"&channel_name=\" + encodeURIComponent(params.channelName);\n                for(var key in authOptions.params){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n                }\n                if (authOptions.paramsProvider != null) {\n                    let dynamicParams = authOptions.paramsProvider();\n                    for(var key in dynamicParams){\n                        query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                    }\n                }\n                return query;\n            };\n            const ChannelAuthorizer = (authOptions)=>{\n                if (typeof runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                    throw \"'\".concat(authOptions.transport, \"' is not a recognized auth transport\");\n                }\n                return (params, callback)=>{\n                    const query = channel_authorizer_composeChannelQuery(params, authOptions);\n                    runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n                };\n            };\n            /* harmony default export */ var channel_authorizer = ChannelAuthorizer;\n            // CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\n            const ChannelAuthorizerProxy = (pusher, authOptions, channelAuthorizerGenerator)=>{\n                const deprecatedAuthorizerOptions = {\n                    authTransport: authOptions.transport,\n                    authEndpoint: authOptions.endpoint,\n                    auth: {\n                        params: authOptions.params,\n                        headers: authOptions.headers\n                    }\n                };\n                return (params, callback)=>{\n                    const channel = pusher.channel(params.channelName);\n                    const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n                    channelAuthorizer.authorize(params.socketId, callback);\n                };\n            };\n            // CONCATENATED MODULE: ./src/core/config.ts\n            function getConfig(opts, pusher) {\n                let config = {\n                    activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n                    cluster: opts.cluster,\n                    httpPath: opts.httpPath || defaults.httpPath,\n                    httpPort: opts.httpPort || defaults.httpPort,\n                    httpsPort: opts.httpsPort || defaults.httpsPort,\n                    pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n                    statsHost: opts.statsHost || defaults.stats_host,\n                    unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n                    wsPath: opts.wsPath || defaults.wsPath,\n                    wsPort: opts.wsPort || defaults.wsPort,\n                    wssPort: opts.wssPort || defaults.wssPort,\n                    enableStats: getEnableStatsConfig(opts),\n                    httpHost: getHttpHost(opts),\n                    useTLS: shouldUseTLS(opts),\n                    wsHost: getWebsocketHost(opts),\n                    userAuthenticator: buildUserAuthenticator(opts),\n                    channelAuthorizer: buildChannelAuthorizer(opts, pusher)\n                };\n                if (\"disabledTransports\" in opts) config.disabledTransports = opts.disabledTransports;\n                if (\"enabledTransports\" in opts) config.enabledTransports = opts.enabledTransports;\n                if (\"ignoreNullOrigin\" in opts) config.ignoreNullOrigin = opts.ignoreNullOrigin;\n                if (\"timelineParams\" in opts) config.timelineParams = opts.timelineParams;\n                if (\"nacl\" in opts) {\n                    config.nacl = opts.nacl;\n                }\n                return config;\n            }\n            function getHttpHost(opts) {\n                if (opts.httpHost) {\n                    return opts.httpHost;\n                }\n                if (opts.cluster) {\n                    return \"sockjs-\".concat(opts.cluster, \".pusher.com\");\n                }\n                return defaults.httpHost;\n            }\n            function getWebsocketHost(opts) {\n                if (opts.wsHost) {\n                    return opts.wsHost;\n                }\n                return getWebsocketHostFromCluster(opts.cluster);\n            }\n            function getWebsocketHostFromCluster(cluster) {\n                return \"ws-\".concat(cluster, \".pusher.com\");\n            }\n            function shouldUseTLS(opts) {\n                if (runtime.getProtocol() === \"https:\") {\n                    return true;\n                } else if (opts.forceTLS === false) {\n                    return false;\n                }\n                return true;\n            }\n            function getEnableStatsConfig(opts) {\n                if (\"enableStats\" in opts) {\n                    return opts.enableStats;\n                }\n                if (\"disableStats\" in opts) {\n                    return !opts.disableStats;\n                }\n                return false;\n            }\n            const hasCustomHandler = (auth)=>{\n                return \"customHandler\" in auth && auth[\"customHandler\"] != null;\n            };\n            function buildUserAuthenticator(opts) {\n                const userAuthentication = Object.assign(Object.assign({}, defaults.userAuthentication), opts.userAuthentication);\n                if (hasCustomHandler(userAuthentication)) {\n                    return userAuthentication[\"customHandler\"];\n                }\n                return user_authenticator(userAuthentication);\n            }\n            function buildChannelAuth(opts, pusher) {\n                let channelAuthorization;\n                if (\"channelAuthorization\" in opts) {\n                    channelAuthorization = Object.assign(Object.assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n                } else {\n                    channelAuthorization = {\n                        transport: opts.authTransport || defaults.authTransport,\n                        endpoint: opts.authEndpoint || defaults.authEndpoint\n                    };\n                    if (\"auth\" in opts) {\n                        if (\"params\" in opts.auth) channelAuthorization.params = opts.auth.params;\n                        if (\"headers\" in opts.auth) channelAuthorization.headers = opts.auth.headers;\n                    }\n                    if (\"authorizer\" in opts) {\n                        return {\n                            customHandler: ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer)\n                        };\n                    }\n                }\n                return channelAuthorization;\n            }\n            function buildChannelAuthorizer(opts, pusher) {\n                const channelAuthorization = buildChannelAuth(opts, pusher);\n                if (hasCustomHandler(channelAuthorization)) {\n                    return channelAuthorization[\"customHandler\"];\n                }\n                return channel_authorizer(channelAuthorization);\n            }\n            // CONCATENATED MODULE: ./src/core/watchlist.ts\n            class watchlist_WatchlistFacade extends dispatcher_Dispatcher {\n                handleEvent(pusherEvent) {\n                    pusherEvent.data.events.forEach((watchlistEvent)=>{\n                        this.emit(watchlistEvent.name, watchlistEvent);\n                    });\n                }\n                bindWatchlistInternalEvent() {\n                    this.pusher.connection.bind(\"message\", (pusherEvent)=>{\n                        var eventName = pusherEvent.event;\n                        if (eventName === \"pusher_internal:watchlist_events\") {\n                            this.handleEvent(pusherEvent);\n                        }\n                    });\n                }\n                constructor(pusher){\n                    super(function(eventName, data) {\n                        logger.debug(\"No callbacks on watchlist events for \".concat(eventName));\n                    });\n                    this.pusher = pusher;\n                    this.bindWatchlistInternalEvent();\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\n            function flatPromise() {\n                let resolve, reject;\n                const promise = new Promise((res, rej)=>{\n                    resolve = res;\n                    reject = rej;\n                });\n                return {\n                    promise,\n                    resolve,\n                    reject\n                };\n            }\n            /* harmony default export */ var flat_promise = flatPromise;\n            // CONCATENATED MODULE: ./src/core/user.ts\n            class user_UserFacade extends dispatcher_Dispatcher {\n                signin() {\n                    if (this.signin_requested) {\n                        return;\n                    }\n                    this.signin_requested = true;\n                    this._signin();\n                }\n                _signin() {\n                    if (!this.signin_requested) {\n                        return;\n                    }\n                    this._newSigninPromiseIfNeeded();\n                    if (this.pusher.connection.state !== \"connected\") {\n                        return;\n                    }\n                    this.pusher.config.userAuthenticator({\n                        socketId: this.pusher.connection.socket_id\n                    }, this._onAuthorize);\n                }\n                _onSigninSuccess(data) {\n                    try {\n                        this.user_data = JSON.parse(data.user_data);\n                    } catch (e) {\n                        logger.error(\"Failed parsing user data after signin: \".concat(data.user_data));\n                        this._cleanup();\n                        return;\n                    }\n                    if (typeof this.user_data.id !== \"string\" || this.user_data.id === \"\") {\n                        logger.error(\"user_data doesn't contain an id. user_data: \".concat(this.user_data));\n                        this._cleanup();\n                        return;\n                    }\n                    this._signinDoneResolve();\n                    this._subscribeChannels();\n                }\n                _subscribeChannels() {\n                    const ensure_subscribed = (channel)=>{\n                        if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                            channel.reinstateSubscription();\n                        } else if (!channel.subscriptionPending && this.pusher.connection.state === \"connected\") {\n                            channel.subscribe();\n                        }\n                    };\n                    this.serverToUserChannel = new channel_Channel(\"#server-to-user-\".concat(this.user_data.id), this.pusher);\n                    this.serverToUserChannel.bind_global((eventName, data)=>{\n                        if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                            return;\n                        }\n                        this.emit(eventName, data);\n                    });\n                    ensure_subscribed(this.serverToUserChannel);\n                }\n                _cleanup() {\n                    this.user_data = null;\n                    if (this.serverToUserChannel) {\n                        this.serverToUserChannel.unbind_all();\n                        this.serverToUserChannel.disconnect();\n                        this.serverToUserChannel = null;\n                    }\n                    if (this.signin_requested) {\n                        this._signinDoneResolve();\n                    }\n                }\n                _newSigninPromiseIfNeeded() {\n                    if (!this.signin_requested) {\n                        return;\n                    }\n                    if (this.signinDonePromise && !this.signinDonePromise.done) {\n                        return;\n                    }\n                    const { promise, resolve, reject: _ } = flat_promise();\n                    promise.done = false;\n                    const setDone = ()=>{\n                        promise.done = true;\n                    };\n                    promise.then(setDone).catch(setDone);\n                    this.signinDonePromise = promise;\n                    this._signinDoneResolve = resolve;\n                }\n                constructor(pusher){\n                    super(function(eventName, data) {\n                        logger.debug(\"No callbacks on user for \" + eventName);\n                    });\n                    this.signin_requested = false;\n                    this.user_data = null;\n                    this.serverToUserChannel = null;\n                    this.signinDonePromise = null;\n                    this._signinDoneResolve = null;\n                    this._onAuthorize = (err, authData)=>{\n                        if (err) {\n                            logger.warn(\"Error during signin: \".concat(err));\n                            this._cleanup();\n                            return;\n                        }\n                        this.pusher.send_event(\"pusher:signin\", {\n                            auth: authData.auth,\n                            user_data: authData.user_data\n                        });\n                    };\n                    this.pusher = pusher;\n                    this.pusher.connection.bind(\"state_change\", (param)=>{\n                        let { previous, current } = param;\n                        if (previous !== \"connected\" && current === \"connected\") {\n                            this._signin();\n                        }\n                        if (previous === \"connected\" && current !== \"connected\") {\n                            this._cleanup();\n                            this._newSigninPromiseIfNeeded();\n                        }\n                    });\n                    this.watchlist = new watchlist_WatchlistFacade(pusher);\n                    this.pusher.connection.bind(\"message\", (event)=>{\n                        var eventName = event.event;\n                        if (eventName === \"pusher:signin_success\") {\n                            this._onSigninSuccess(event.data);\n                        }\n                        if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {\n                            this.serverToUserChannel.handleEvent(event);\n                        }\n                    });\n                }\n            }\n            // CONCATENATED MODULE: ./src/core/pusher.ts\n            class pusher_Pusher {\n                static ready() {\n                    pusher_Pusher.isReady = true;\n                    for(var i = 0, l = pusher_Pusher.instances.length; i < l; i++){\n                        pusher_Pusher.instances[i].connect();\n                    }\n                }\n                static getClientFeatures() {\n                    return keys(filterObject({\n                        ws: runtime.Transports.ws\n                    }, function(t) {\n                        return t.isSupported({});\n                    }));\n                }\n                switchCluster(options) {\n                    const { appKey, cluster } = options;\n                    this.key = appKey;\n                    this.options = Object.assign(Object.assign({}, this.options), {\n                        cluster\n                    });\n                    this.config = getConfig(this.options, this);\n                    this.connection.switchCluster(this.key);\n                }\n                channel(name) {\n                    return this.channels.find(name);\n                }\n                allChannels() {\n                    return this.channels.all();\n                }\n                connect() {\n                    this.connection.connect();\n                    if (this.timelineSender) {\n                        if (!this.timelineSenderTimer) {\n                            var usingTLS = this.connection.isUsingTLS();\n                            var timelineSender = this.timelineSender;\n                            this.timelineSenderTimer = new timers_PeriodicTimer(60000, function() {\n                                timelineSender.send(usingTLS);\n                            });\n                        }\n                    }\n                }\n                disconnect() {\n                    this.connection.disconnect();\n                    if (this.timelineSenderTimer) {\n                        this.timelineSenderTimer.ensureAborted();\n                        this.timelineSenderTimer = null;\n                    }\n                }\n                bind(event_name, callback, context) {\n                    this.global_emitter.bind(event_name, callback, context);\n                    return this;\n                }\n                unbind(event_name, callback, context) {\n                    this.global_emitter.unbind(event_name, callback, context);\n                    return this;\n                }\n                bind_global(callback) {\n                    this.global_emitter.bind_global(callback);\n                    return this;\n                }\n                unbind_global(callback) {\n                    this.global_emitter.unbind_global(callback);\n                    return this;\n                }\n                unbind_all(callback) {\n                    this.global_emitter.unbind_all();\n                    return this;\n                }\n                subscribeAll() {\n                    var channelName;\n                    for(channelName in this.channels.channels){\n                        if (this.channels.channels.hasOwnProperty(channelName)) {\n                            this.subscribe(channelName);\n                        }\n                    }\n                }\n                subscribe(channel_name) {\n                    var channel = this.channels.add(channel_name, this);\n                    if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                        channel.reinstateSubscription();\n                    } else if (!channel.subscriptionPending && this.connection.state === \"connected\") {\n                        channel.subscribe();\n                    }\n                    return channel;\n                }\n                unsubscribe(channel_name) {\n                    var channel = this.channels.find(channel_name);\n                    if (channel && channel.subscriptionPending) {\n                        channel.cancelSubscription();\n                    } else {\n                        channel = this.channels.remove(channel_name);\n                        if (channel && channel.subscribed) {\n                            channel.unsubscribe();\n                        }\n                    }\n                }\n                send_event(event_name, data, channel) {\n                    return this.connection.send_event(event_name, data, channel);\n                }\n                shouldUseTLS() {\n                    return this.config.useTLS;\n                }\n                signin() {\n                    this.user.signin();\n                }\n                constructor(app_key, options){\n                    checkAppKey(app_key);\n                    validateOptions(options);\n                    this.key = app_key;\n                    this.options = options;\n                    this.config = getConfig(this.options, this);\n                    this.channels = factory.createChannels();\n                    this.global_emitter = new dispatcher_Dispatcher();\n                    this.sessionID = runtime.randomInt(1000000000);\n                    this.timeline = new timeline_Timeline(this.key, this.sessionID, {\n                        cluster: this.config.cluster,\n                        features: pusher_Pusher.getClientFeatures(),\n                        params: this.config.timelineParams || {},\n                        limit: 50,\n                        level: timeline_level.INFO,\n                        version: defaults.VERSION\n                    });\n                    if (this.config.enableStats) {\n                        this.timelineSender = factory.createTimelineSender(this.timeline, {\n                            host: this.config.statsHost,\n                            path: \"/timeline/v2/\" + runtime.TimelineTransport.name\n                        });\n                    }\n                    var getStrategy = (options)=>{\n                        return runtime.getDefaultStrategy(this.config, options, strategy_builder_defineTransport);\n                    };\n                    this.connection = factory.createConnectionManager(this.key, {\n                        getStrategy: getStrategy,\n                        timeline: this.timeline,\n                        activityTimeout: this.config.activityTimeout,\n                        pongTimeout: this.config.pongTimeout,\n                        unavailableTimeout: this.config.unavailableTimeout,\n                        useTLS: Boolean(this.config.useTLS)\n                    });\n                    this.connection.bind(\"connected\", ()=>{\n                        this.subscribeAll();\n                        if (this.timelineSender) {\n                            this.timelineSender.send(this.connection.isUsingTLS());\n                        }\n                    });\n                    this.connection.bind(\"message\", (event)=>{\n                        var eventName = event.event;\n                        var internal = eventName.indexOf(\"pusher_internal:\") === 0;\n                        if (event.channel) {\n                            var channel = this.channel(event.channel);\n                            if (channel) {\n                                channel.handleEvent(event);\n                            }\n                        }\n                        if (!internal) {\n                            this.global_emitter.emit(event.event, event.data);\n                        }\n                    });\n                    this.connection.bind(\"connecting\", ()=>{\n                        this.channels.disconnect();\n                    });\n                    this.connection.bind(\"disconnected\", ()=>{\n                        this.channels.disconnect();\n                    });\n                    this.connection.bind(\"error\", (err)=>{\n                        logger.warn(err);\n                    });\n                    pusher_Pusher.instances.push(this);\n                    this.timeline.info({\n                        instances: pusher_Pusher.instances.length\n                    });\n                    this.user = new user_UserFacade(this);\n                    if (pusher_Pusher.isReady) {\n                        this.connect();\n                    }\n                }\n            }\n            pusher_Pusher.instances = [];\n            pusher_Pusher.isReady = false;\n            pusher_Pusher.logToConsole = false;\n            pusher_Pusher.Runtime = runtime;\n            pusher_Pusher.ScriptReceivers = runtime.ScriptReceivers;\n            pusher_Pusher.DependenciesReceivers = runtime.DependenciesReceivers;\n            pusher_Pusher.auth_callbacks = runtime.auth_callbacks;\n            /* harmony default export */ var core_pusher = __nested_webpack_exports__[\"default\"] = pusher_Pusher;\n            function checkAppKey(key) {\n                if (key === null || key === undefined) {\n                    throw \"You must pass your app key when you instantiate Pusher.\";\n                }\n            }\n            runtime.setup(pusher_Pusher);\n        /***/ }\n    ]);\n}); //# sourceMappingURL=pusher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wdXNoZXItanMvZGlzdC93ZWIvcHVzaGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0NBTUMsR0FFQSxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdEO1NBQ2IsRUFLdUJBO0FBQzdCLEdBQUdLLFFBQVE7SUFDWCxPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1lBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1IsT0FBTztZQUNyRCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTSyxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1DLEdBQUdEO2dCQUNmLE1BQU0sR0FBTUUsR0FBRztnQkFDZixNQUFNLEdBQU1WLFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLSyxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDVixRQUFPRCxPQUFPLEVBQUVDLFNBQVFBLFFBQU9ELE9BQU8sRUFBRU8sOEJBQW1CQTtZQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtZQUN2QyxNQUFNLEdBQUtOLFFBQU9TLENBQUMsR0FBRztZQUN0QixNQUFNLEdBQ04sTUFBTSxHQUFL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QUc5bkI7WUFDeEI4dUIsY0FBYzd3QixlQUFlLEdBQUcrQixRQUFRL0IsZUFBZTtZQUN2RDZ3QixjQUFjM3RCLHFCQUFxQixHQUFHbkIsUUFBUW1CLHFCQUFxQjtZQUNuRTJ0QixjQUFjdGtCLGNBQWMsR0FBR3hLLFFBQVF3SyxjQUFjO1lBQ3JELDBCQUEwQixHQUFHLElBQUlULGNBQWN6TSwwQkFBbUIsQ0FBQyxVQUFVLEdBQUl3eEI7WUFDakYsU0FBU2EsWUFBWXgyQixHQUFHO2dCQUNwQixJQUFJQSxRQUFRLFFBQVFBLFFBQVEwUCxXQUFXO29CQUNuQyxNQUFNO2dCQUNWO1lBQ0o7WUFDQTdJLFFBQVFrb0IsS0FBSyxDQUFDNEc7UUFHZCxHQUFHLEdBQUc7S0FDSTtBQUNWLElBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wdXNoZXItanMvZGlzdC93ZWIvcHVzaGVyLmpzP2RjOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBQdXNoZXIgSmF2YVNjcmlwdCBMaWJyYXJ5IHY4LjQuMC1yYzJcbiAqIGh0dHBzOi8vcHVzaGVyLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCwgUHVzaGVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2VuY2UuXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUHVzaGVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlB1c2hlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGJhc2U2NCBpbXBsZW1lbnRzIEJhc2U2NCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbi8vIEludmFsaWQgY2hhcmFjdGVyIHVzZWQgaW4gZGVjb2RpbmcgdG8gaW5kaWNhdGVcbi8vIHRoYXQgdGhlIGNoYXJhY3RlciB0byBkZWNvZGUgaXMgb3V0IG9mIHJhbmdlIG9mXG4vLyBhbHBoYWJldCBhbmQgY2Fubm90IGJlIGRlY29kZWQuXG52YXIgSU5WQUxJRF9CWVRFID0gMjU2O1xuLyoqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEJhc2U2NCBlbmNvZGluZy5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBtZXRob2RzIHRvIGVuY29kZSBjaHVuay1ieS1jaHVuay5cbiAgICBmdW5jdGlvbiBDb2RlcihfcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICBpZiAoX3BhZGRpbmdDaGFyYWN0ZXIgPT09IHZvaWQgMCkgeyBfcGFkZGluZ0NoYXJhY3RlciA9IFwiPVwiOyB9XG4gICAgICAgIHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgPSBfcGFkZGluZ0NoYXJhY3RlcjtcbiAgICB9XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA4ICsgNSkgLyA2IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxlbmd0aCArIDIpIC8gMyAqIDQgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGF0YS5sZW5ndGggLSAyOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBjID0gKGRhdGFbaV0gPDwgMTYpIHwgKGRhdGFbaSArIDFdIDw8IDgpIHwgKGRhdGFbaSArIDJdKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDEgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAwICogNikgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLmxlbmd0aCAtIGk7XG4gICAgICAgIGlmIChsZWZ0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAobGVmdCA9PT0gMiA/IGRhdGFbaSArIDFdIDw8IDggOiAwKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVuZ3RoICogNiArIDcpIC8gOCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAvIDQgKiAzIHwgMDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RGVjb2RlZExlbmd0aChzLmxlbmd0aCAtIHRoaXMuX2dldFBhZGRpbmdMZW5ndGgocykpO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpKTtcbiAgICAgICAgdmFyIG9wID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaGF2ZUJhZCA9IDA7XG4gICAgICAgIHZhciB2MCA9IDAsIHYxID0gMCwgdjIgPSAwLCB2MyA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoIC0gNDsgaSArPSA0KSB7XG4gICAgICAgICAgICB2MCA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAwKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYyICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgdjEgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYwIDw8IDIpIHwgKHYxID4+PiA0KTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjAgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYxICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdjIgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMikpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAzKSB7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjIgPDwgNikgfCB2MztcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjMgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVCYWQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgY2hhcmFjdGVycyBmb3IgZGVjb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzLFxuICAgIC8vIHdoaWNoIHdlIG5lZWQgdG8gY29udmVydCBiZXR3ZWVuLlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgKyAgIC9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0MyAgNDdcbiAgICAvL1xuICAgIC8vIEVuY29kZSA2IGJpdHMgaW4gYiBpbnRvIGEgbmV3IGNoYXJhY3Rlci5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAvLyBFbmNvZGluZyB1c2VzIGNvbnN0YW50IHRpbWUgb3BlcmF0aW9ucyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBEZWZpbmUgY29tcGFyaXNvbiBvZiBBIHdpdGggQiB1c2luZyAoQSAtIEIpID4+PiA4OlxuICAgICAgICAvLyAgICAgICAgICBpZiBBID4gQiwgdGhlbiByZXN1bHQgaXMgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAvLyAgICAgICAgICBpZiBBIDw9IEIsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gRGVmaW5lIHNlbGVjdGlvbiBvZiBDIG9yIDAgdXNpbmcgYml0d2lzZSBBTkQ6IFggJiBDOlxuICAgICAgICAvLyAgICAgICAgICBpZiBYID09IDAsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy8gICAgICAgICAgaWYgWCAhPSAwLCB0aGVuIHJlc3VsdCBpcyBDXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDMuIFN0YXJ0IHdpdGggdGhlIHNtYWxsZXN0IGNvbXBhcmlzb24gKGIgPj0gMCksIHdoaWNoIGlzIGFsd2F5c1xuICAgICAgICAvLyAgICB0cnVlLCBzbyBzZXQgdGhlIHJlc3VsdCB0byB0aGUgc3RhcnRpbmcgQVNDSUkgdmFsdWUgKDY1KS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gNC4gQ29udGludWUgY29tcGFyaW5nIGIgdG8gaGlnaGVyIEFTQ0lJIHZhbHVlcywgYW5kIHNlbGVjdGluZ1xuICAgICAgICAvLyAgICB6ZXJvIGlmIGNvbXBhcmlzb24gaXNuJ3QgdHJ1ZSwgb3RoZXJ3aXNlIHNlbGVjdGluZyBhIHZhbHVlXG4gICAgICAgIC8vICAgIHRvIGFkZCB0byByZXN1bHQsIHdoaWNoOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICBhKSB1bmRvZXMgdGhlIHByZXZpb3VzIGFkZGl0aW9uXG4gICAgICAgIC8vICAgICAgICAgIGIpIHByb3ZpZGVzIG5ldyB2YWx1ZSB0byBhZGRcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGI7XG4gICAgICAgIC8vIGIgPj0gMFxuICAgICAgICByZXN1bHQgKz0gNjU7XG4gICAgICAgIC8vIGIgPiAyNVxuICAgICAgICByZXN1bHQgKz0gKCgyNSAtIGIpID4+PiA4KSAmICgoMCAtIDY1KSAtIDI2ICsgOTcpO1xuICAgICAgICAvLyBiID4gNTFcbiAgICAgICAgcmVzdWx0ICs9ICgoNTEgLSBiKSA+Pj4gOCkgJiAoKDI2IC0gOTcpIC0gNTIgKyA0OCk7XG4gICAgICAgIC8vIGIgPiA2MVxuICAgICAgICByZXN1bHQgKz0gKCg2MSAtIGIpID4+PiA4KSAmICgoNTIgLSA0OCkgLSA2MiArIDQzKTtcbiAgICAgICAgLy8gYiA+IDYyXG4gICAgICAgIHJlc3VsdCArPSAoKDYyIC0gYikgPj4+IDgpICYgKCg2MiAtIDQzKSAtIDYzICsgNDcpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZXN1bHQpO1xuICAgIH07XG4gICAgLy8gRGVjb2RlIGEgY2hhcmFjdGVyIGNvZGUgaW50byBhIGJ5dGUuXG4gICAgLy8gTXVzdCByZXR1cm4gMjU2IGlmIGNoYXJhY3RlciBpcyBvdXQgb2YgYWxwaGFiZXQgcmFuZ2UuXG4gICAgQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gRGVjb2Rpbmcgd29ya3Mgc2ltaWxhciB0byBlbmNvZGluZzogdXNpbmcgdGhlIHNhbWUgY29tcGFyaXNvblxuICAgICAgICAvLyBmdW5jdGlvbiwgYnV0IG5vdyBpdCB3b3JrcyBvbiByYW5nZXM6IHJlc3VsdCBpcyBhbHdheXMgaW5jcmVtZW50ZWRcbiAgICAgICAgLy8gYnkgdmFsdWUsIGJ1dCB0aGlzIHZhbHVlIGJlY29tZXMgemVybyBpZiB0aGUgcmFuZ2UgaXMgbm90XG4gICAgICAgIC8vIHNhdGlzZmllZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2Rpbmcgc3RhcnRzIHdpdGggaW52YWxpZCB2YWx1ZSwgMjU2LCB3aGljaCBpcyB0aGVuXG4gICAgICAgIC8vIHN1YnRyYWN0ZWQgd2hlbiB0aGUgcmFuZ2UgaXMgc2F0aXNmaWVkLiBJZiBub25lIG9mIHRoZSByYW5nZXNcbiAgICAgICAgLy8gYXBwbHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIDI1Niwgd2hpY2ggaXMgdGhlbiBjaGVja2VkIGJ5XG4gICAgICAgIC8vIHRoZSBjYWxsZXIgdG8gdGhyb3cgZXJyb3IuXG4gICAgICAgIHZhciByZXN1bHQgPSBJTlZBTElEX0JZVEU7IC8vIHN0YXJ0IHdpdGggaW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gYyA9PSA0MyAoYyA+IDQyIGFuZCBjIDwgNDQpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0MiAtIGMpICYgKGMgLSA0NCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQzICsgNjIpO1xuICAgICAgICAvLyBjID09IDQ3IChjID4gNDYgYW5kIGMgPCA0OClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ2IC0gYykgJiAoYyAtIDQ4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDcgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLl9nZXRQYWRkaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMubGVuZ3RoIDwgNCB8fCBwYWRkaW5nTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgcGFkZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0xlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBDb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkNvZGVyID0gQ29kZXI7XG52YXIgc3RkQ29kZXIgPSBuZXcgQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmVuY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIEltcGxlbWVudHMgVVJMLXNhZmUgQmFzZTY0IGVuY29kaW5nLlxuICogKFNhbWUgYXMgQmFzZTY0LCBidXQgJysnIGlzIHJlcGxhY2VkIHdpdGggJy0nLCBhbmQgJy8nIHdpdGggJ18nKS5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgVVJMU2FmZUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUkxTYWZlQ29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVJMU2FmZUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIFVSTC1zYWZlIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzOlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgLSAgIF9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0NSAgOTVcbiAgICAvL1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDUpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDUpIC0gNjMgKyA5NSk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICBVUkxTYWZlQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTtcbiAgICAgICAgLy8gYyA9PSA0NSAoYyA+IDQ0IGFuZCBjIDwgNDYpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0NCAtIGMpICYgKGMgLSA0NikpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ1ICsgNjIpO1xuICAgICAgICAvLyBjID09IDk1IChjID4gOTQgYW5kIGMgPCA5NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk0IC0gYykgJiAoYyAtIDk2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTUgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFNhZmVDb2Rlcjtcbn0oQ29kZXIpKTtcbmV4cG9ydHMuVVJMU2FmZUNvZGVyID0gVVJMU2FmZUNvZGVyO1xudmFyIHVybFNhZmVDb2RlciA9IG5ldyBVUkxTYWZlQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZVVSTFNhZmUoZGF0YSkge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGVVUkxTYWZlID0gZW5jb2RlVVJMU2FmZTtcbmZ1bmN0aW9uIGRlY29kZVVSTFNhZmUocykge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGVVUkxTYWZlID0gZGVjb2RlVVJMU2FmZTtcbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMubWF4RGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMuZGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmRlY29kZWRMZW5ndGgocyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIHV0ZjggaW1wbGVtZW50cyBVVEYtOCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbnZhciBJTlZBTElEX1VURjE2ID0gXCJ1dGY4OiBpbnZhbGlkIHN0cmluZ1wiO1xudmFyIElOVkFMSURfVVRGOCA9IFwidXRmODogaW52YWxpZCBzb3VyY2UgZW5jb2RpbmdcIjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTggYnl0ZSBhcnJheS5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlc3VsdCBsZW5ndGggYW5kIGFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAvLyBlbmNvZGVkTGVuZ3RoKCkgYWxzbyB2YWxpZGF0ZXMgc3RyaW5nIGFuZCB0aHJvd3MgZXJyb3JzLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgcmVwZWF0IHZhbGlkYXRpb24gaGVyZS5cbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZExlbmd0aChzKSk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4YzAgfCBjID4+IDY7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGUwIHwgYyA+PiAxMjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKzsgLy8gZ2V0IG9uZSBtb3JlIGNoYXJhY3RlclxuICAgICAgICAgICAgYyA9IChjICYgMHgzZmYpIDw8IDEwO1xuICAgICAgICAgICAgYyB8PSBzLmNoYXJDb2RlQXQoaSkgJiAweDNmZjtcbiAgICAgICAgICAgIGMgKz0gMHgxMDAwMDtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGYwIHwgYyA+PiAxODtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gMTIpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZExlbmd0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKzsgLy8gXCJlYXRcIiBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgZnJvbSBVVEYtOCBpbnRvIGEgc3RyaW5nLlxuICogVGhyb3dzIGlmIGVuY29kaW5nIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShhcnIpIHtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGFycltpXTtcbiAgICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGIgPCAweGUwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAxIG1vcmUgYnl0ZS5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MWYpIDw8IDYgfCAobjEgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDIgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxMiB8IChuMSAmIDB4M2YpIDw8IDYgfCAobjIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGY4KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAzIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMyA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCB8fCAobjMgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTggfCAobjEgJiAweDNmKSA8PCAxMiB8IChuMiAmIDB4M2YpIDw8IDYgfCAobjMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA8IG1pbiB8fCAoYiA+PSAweGQ4MDAgJiYgYiA8PSAweGRmZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+PSAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgaWYgKGIgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgfCAoYiA+PiAxMCkpKTtcbiAgICAgICAgICAgICAgICBiID0gMHhkYzAwIHwgKGIgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gcmVxdWlyZWQgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyByZXF1aXJlKCdwdXNoZXInKS5kZWZhdWx0IGV0Yy5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL3NjcmlwdF9yZWNlaXZlcl9mYWN0b3J5LnRzXG5jbGFzcyBTY3JpcHRSZWNlaXZlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgbmFtZSkge1xuICAgICAgICB0aGlzLmxhc3RJZCA9IDA7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBjcmVhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5sYXN0SWQrKztcbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubGFzdElkO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLnByZWZpeCArIG51bWJlcjtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUgKyAnWycgKyBudW1iZXIgKyAnXSc7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzW251bWJlcl0gPSBjYWxsYmFja1dyYXBwZXI7XG4gICAgICAgIHJldHVybiB7IG51bWJlcjogbnVtYmVyLCBpZDogaWQsIG5hbWU6IG5hbWUsIGNhbGxiYWNrOiBjYWxsYmFja1dyYXBwZXIgfTtcbiAgICB9XG4gICAgcmVtb3ZlKHJlY2VpdmVyKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW3JlY2VpdmVyLm51bWJlcl07XG4gICAgfVxufVxudmFyIFNjcmlwdFJlY2VpdmVycyA9IG5ldyBTY3JpcHRSZWNlaXZlckZhY3RvcnkoJ19wdXNoZXJfc2NyaXB0XycsICdQdXNoZXIuU2NyaXB0UmVjZWl2ZXJzJyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZGVmYXVsdHMudHNcbnZhciBEZWZhdWx0cyA9IHtcbiAgICBWRVJTSU9OOiBcIjguNC4wLXJjMlwiLFxuICAgIFBST1RPQ09MOiA3LFxuICAgIHdzUG9ydDogODAsXG4gICAgd3NzUG9ydDogNDQzLFxuICAgIHdzUGF0aDogJycsXG4gICAgaHR0cEhvc3Q6ICdzb2NranMucHVzaGVyLmNvbScsXG4gICAgaHR0cFBvcnQ6IDgwLFxuICAgIGh0dHBzUG9ydDogNDQzLFxuICAgIGh0dHBQYXRoOiAnL3B1c2hlcicsXG4gICAgc3RhdHNfaG9zdDogJ3N0YXRzLnB1c2hlci5jb20nLFxuICAgIGF1dGhFbmRwb2ludDogJy9wdXNoZXIvYXV0aCcsXG4gICAgYXV0aFRyYW5zcG9ydDogJ2FqYXgnLFxuICAgIGFjdGl2aXR5VGltZW91dDogMTIwMDAwLFxuICAgIHBvbmdUaW1lb3V0OiAzMDAwMCxcbiAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IDEwMDAwLFxuICAgIHVzZXJBdXRoZW50aWNhdGlvbjoge1xuICAgICAgICBlbmRwb2ludDogJy9wdXNoZXIvdXNlci1hdXRoJyxcbiAgICAgICAgdHJhbnNwb3J0OiAnYWpheCdcbiAgICB9LFxuICAgIGNoYW5uZWxBdXRob3JpemF0aW9uOiB7XG4gICAgICAgIGVuZHBvaW50OiAnL3B1c2hlci9hdXRoJyxcbiAgICAgICAgdHJhbnNwb3J0OiAnYWpheCdcbiAgICB9LFxuICAgIGNkbl9odHRwOiBcImh0dHA6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgY2RuX2h0dHBzOiBcImh0dHBzOi8vanMucHVzaGVyLmNvbVwiLFxuICAgIGRlcGVuZGVuY3lfc3VmZml4OiBcIlwiXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHMgPSAoRGVmYXVsdHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL2RlcGVuZGVuY3lfbG9hZGVyLnRzXG5cblxuY2xhc3MgZGVwZW5kZW5jeV9sb2FkZXJfRGVwZW5kZW5jeUxvYWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG9wdGlvbnMucmVjZWl2ZXJzIHx8IFNjcmlwdFJlY2VpdmVycztcbiAgICAgICAgdGhpcy5sb2FkaW5nID0ge307XG4gICAgfVxuICAgIGxvYWQobmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5sb2FkaW5nW25hbWVdICYmIHNlbGYubG9hZGluZ1tuYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZVNjcmlwdFJlcXVlc3Qoc2VsZi5nZXRQYXRoKG5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHNlbGYucmVjZWl2ZXJzLmNyZWF0ZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY2VpdmVycy5yZW1vdmUocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvYWRpbmdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh3YXNTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShlcnJvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSb290KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNkbjtcbiAgICAgICAgdmFyIHByb3RvY29sID0gcnVudGltZS5nZXREb2N1bWVudCgpLmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VUTFMpIHx8IHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgY2RuID0gdGhpcy5vcHRpb25zLmNkbl9odHRwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNkbiA9IHRoaXMub3B0aW9ucy5jZG5faHR0cDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2RuLnJlcGxhY2UoL1xcLyokLywgJycpICsgJy8nICsgdGhpcy5vcHRpb25zLnZlcnNpb247XG4gICAgfVxuICAgIGdldFBhdGgobmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290KG9wdGlvbnMpICsgJy8nICsgbmFtZSArIHRoaXMub3B0aW9ucy5zdWZmaXggKyAnLmpzJztcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vZGVwZW5kZW5jaWVzLnRzXG5cblxuXG52YXIgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gbmV3IFNjcmlwdFJlY2VpdmVyRmFjdG9yeSgnX3B1c2hlcl9kZXBlbmRlbmNpZXMnLCAnUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycycpO1xudmFyIERlcGVuZGVuY2llcyA9IG5ldyBkZXBlbmRlbmN5X2xvYWRlcl9EZXBlbmRlbmN5TG9hZGVyKHtcbiAgICBjZG5faHR0cDogZGVmYXVsdHMuY2RuX2h0dHAsXG4gICAgY2RuX2h0dHBzOiBkZWZhdWx0cy5jZG5faHR0cHMsXG4gICAgdmVyc2lvbjogZGVmYXVsdHMuVkVSU0lPTixcbiAgICBzdWZmaXg6IGRlZmF1bHRzLmRlcGVuZGVuY3lfc3VmZml4LFxuICAgIHJlY2VpdmVyczogRGVwZW5kZW5jaWVzUmVjZWl2ZXJzXG59KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy91cmxfc3RvcmUudHNcbmNvbnN0IHVybFN0b3JlID0ge1xuICAgIGJhc2VVcmw6ICdodHRwczovL3B1c2hlci5jb20nLFxuICAgIHVybHM6IHtcbiAgICAgICAgYXV0aGVudGljYXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aGVudGljYXRpbmdfdXNlcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aG9yaXppbmctdXNlcnMvJ1xuICAgICAgICB9LFxuICAgICAgICBqYXZhc2NyaXB0UXVpY2tTdGFydDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2phdmFzY3JpcHRfcXVpY2tfc3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJpbmdDbGllbnRFdmVudHM6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvZG9jcy9jbGllbnRfYXBpX2d1aWRlL2NsaWVudF9ldmVudHMjdHJpZ2dlci1ldmVudHMnXG4gICAgICAgIH0sXG4gICAgICAgIGVuY3J5cHRlZENoYW5uZWxTdXBwb3J0OiB7XG4gICAgICAgICAgICBmdWxsVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3B1c2hlci9wdXNoZXItanMvdHJlZS9jYzQ5MTAxNTM3MWE0YmRlNTc0M2QxYzg3YTBmYmFjMGZlYjUzMTk1I2VuY3J5cHRlZC1jaGFubmVsLXN1cHBvcnQnXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgdXJsUHJlZml4ID0gJ1NlZTonO1xuICAgIGNvbnN0IHVybE9iaiA9IHVybFN0b3JlLnVybHNba2V5XTtcbiAgICBpZiAoIXVybE9iailcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHVybE9iai5mdWxsVXJsKSB7XG4gICAgICAgIHVybCA9IHVybE9iai5mdWxsVXJsO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmxPYmoucGF0aCkge1xuICAgICAgICB1cmwgPSB1cmxTdG9yZS5iYXNlVXJsICsgdXJsT2JqLnBhdGg7XG4gICAgfVxuICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGAke3VybFByZWZpeH0gJHt1cmx9YDtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1cmxfc3RvcmUgPSAoeyBidWlsZExvZ1N1ZmZpeCB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL29wdGlvbnMudHNcbnZhciBBdXRoUmVxdWVzdFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhSZXF1ZXN0VHlwZSkge1xuICAgIEF1dGhSZXF1ZXN0VHlwZVtcIlVzZXJBdXRoZW50aWNhdGlvblwiXSA9IFwidXNlci1hdXRoZW50aWNhdGlvblwiO1xuICAgIEF1dGhSZXF1ZXN0VHlwZVtcIkNoYW5uZWxBdXRob3JpemF0aW9uXCJdID0gXCJjaGFubmVsLWF1dGhvcml6YXRpb25cIjtcbn0pKEF1dGhSZXF1ZXN0VHlwZSB8fCAoQXV0aFJlcXVlc3RUeXBlID0ge30pKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9lcnJvcnMudHNcbmNsYXNzIEJhZEV2ZW50TmFtZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBCYWRDaGFubmVsTmFtZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBSZXF1ZXN0VGltZWRPdXQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3cgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNwb3J0Q2xvc2VkIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkRmVhdHVyZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZFRyYW5zcG9ydCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZFN0cmF0ZWd5IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIEhUVFBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2F1dGgveGhyX2F1dGgudHNcblxuXG5cblxuY29uc3QgYWpheCA9IGZ1bmN0aW9uIChjb250ZXh0LCBxdWVyeSwgYXV0aE9wdGlvbnMsIGF1dGhSZXF1ZXN0VHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB4aHIgPSBydW50aW1lLmNyZWF0ZVhIUigpO1xuICAgIHhoci5vcGVuKCdQT1NUJywgYXV0aE9wdGlvbnMuZW5kcG9pbnQsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBhdXRoT3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGF1dGhPcHRpb25zLmhlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMuaGVhZGVyc1Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGR5bmFtaWNIZWFkZXJzID0gYXV0aE9wdGlvbnMuaGVhZGVyc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGhlYWRlck5hbWUgaW4gZHluYW1pY0hlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGR5bmFtaWNIZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBIVFRQQXV0aEVycm9yKDIwMCwgYEpTT04gcmV0dXJuZWQgZnJvbSAke2F1dGhSZXF1ZXN0VHlwZS50b1N0cmluZygpfSBlbmRwb2ludCB3YXMgaW52YWxpZCwgeWV0IHN0YXR1cyBjb2RlIHdhcyAyMDAuIERhdGEgd2FzOiAke3hoci5yZXNwb25zZVRleHR9YCksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1dGhSZXF1ZXN0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dGhSZXF1ZXN0VHlwZS5Vc2VyQXV0aGVudGljYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhlbnRpY2F0aW9uRW5kcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dGhSZXF1ZXN0VHlwZS5DaGFubmVsQXV0aG9yaXphdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGBDbGllbnRzIG11c3QgYmUgYXV0aG9yaXplZCB0byBqb2luIHByaXZhdGUgb3IgcHJlc2VuY2UgY2hhbm5lbHMuICR7dXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRob3JpemF0aW9uRW5kcG9pbnQnKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBIVFRQQXV0aEVycm9yKHhoci5zdGF0dXMsIGBVbmFibGUgdG8gcmV0cmlldmUgYXV0aCBzdHJpbmcgZnJvbSAke2F1dGhSZXF1ZXN0VHlwZS50b1N0cmluZygpfSBlbmRwb2ludCAtIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcmVjZWl2ZWQgc3RhdHVzOiAke3hoci5zdGF0dXN9IGZyb20gJHthdXRoT3B0aW9ucy5lbmRwb2ludH0uICR7c3VmZml4fWApLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQocXVlcnkpO1xuICAgIHJldHVybiB4aHI7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyX2F1dGggPSAoYWpheCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYmFzZTY0LnRzXG5mdW5jdGlvbiBlbmNvZGUocykge1xuICAgIHJldHVybiBidG9hKHV0b2IocykpO1xufVxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgYjY0Y2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG52YXIgYjY0dGFiID0ge307XG5mb3IgKHZhciBiYXNlNjRfaSA9IDAsIGwgPSBiNjRjaGFycy5sZW5ndGg7IGJhc2U2NF9pIDwgbDsgYmFzZTY0X2krKykge1xuICAgIGI2NHRhYltiNjRjaGFycy5jaGFyQXQoYmFzZTY0X2kpXSA9IGJhc2U2NF9pO1xufVxudmFyIGNiX3V0b2IgPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gY2MgPCAweDgwXG4gICAgICAgID8gY1xuICAgICAgICA6IGNjIDwgMHg4MDBcbiAgICAgICAgICAgID8gZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKSArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpXG4gICAgICAgICAgICA6IGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpICtcbiAgICAgICAgICAgICAgICBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpICtcbiAgICAgICAgICAgICAgICBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKTtcbn07XG52YXIgdXRvYiA9IGZ1bmN0aW9uICh1KSB7XG4gICAgcmV0dXJuIHUucmVwbGFjZSgvW15cXHgwMC1cXHg3Rl0vZywgY2JfdXRvYik7XG59O1xudmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uIChjY2MpIHtcbiAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXTtcbiAgICB2YXIgb3JkID0gKGNjYy5jaGFyQ29kZUF0KDApIDw8IDE2KSB8XG4gICAgICAgICgoY2NjLmxlbmd0aCA+IDEgPyBjY2MuY2hhckNvZGVBdCgxKSA6IDApIDw8IDgpIHxcbiAgICAgICAgKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKTtcbiAgICB2YXIgY2hhcnMgPSBbXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdChvcmQgPj4+IDE4KSxcbiAgICAgICAgYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDEyKSAmIDYzKSxcbiAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgIF07XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xufTtcbnZhciBidG9hID0gd2luZG93LmJ0b2EgfHxcbiAgICBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy90aW1lcnMvYWJzdHJhY3RfdGltZXIudHNcbmNsYXNzIFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQsIGNsZWFyLCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbGVhciA9IGNsZWFyO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IGNhbGxiYWNrKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSk7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIgIT09IG51bGw7XG4gICAgfVxuICAgIGVuc3VyZUFib3J0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhYnN0cmFjdF90aW1lciA9IChUaW1lcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2luZGV4LnRzXG5cbmZ1bmN0aW9uIHRpbWVyc19jbGVhclRpbWVvdXQodGltZXIpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbn1cbmZ1bmN0aW9uIHRpbWVyc19jbGVhckludGVydmFsKHRpbWVyKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpO1xufVxuY2xhc3MgdGltZXJzX09uZU9mZlRpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRUaW1lb3V0LCB0aW1lcnNfY2xlYXJUaW1lb3V0LCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIHRpbWVyc19QZXJpb2RpY1RpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRJbnRlcnZhbCwgdGltZXJzX2NsZWFySW50ZXJ2YWwsIGRlbGF5LCBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlsLnRzXG5cbnZhciBVdGlsID0ge1xuICAgIG5vdygpIHtcbiAgICAgICAgaWYgKERhdGUubm93KSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW1lcnNfT25lT2ZmVGltZXIoMCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgbWV0aG9kKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIGJvdW5kQXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbbmFtZV0uYXBwbHkob2JqZWN0LCBib3VuZEFyZ3VtZW50cy5jb25jYXQoYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWwgPSAoVXRpbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvY29sbGVjdGlvbnMudHNcblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHRlbnNpb25zID0gc291cmNlc1tpXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbcHJvcGVydHldICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zW3Byb3BlcnR5XS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuZCh0YXJnZXRbcHJvcGVydHldIHx8IHt9LCBleHRlbnNpb25zW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gZXh0ZW5zaW9uc1twcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSgpIHtcbiAgICB2YXIgbSA9IFsnUHVzaGVyJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0ucHVzaChzYWZlSlNPTlN0cmluZ2lmeShhcmd1bWVudHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5qb2luKCcgOiAnKTtcbn1cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgaXRlbSkge1xuICAgIHZhciBuYXRpdmVJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgaWYgKGFycmF5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvYmplY3RBcHBseShvYmplY3QsIGYpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBmKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAoXywga2V5KSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGFwcGx5KGFycmF5LCBmLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmLmNhbGwoY29udGV4dCB8fCB3aW5kb3csIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZihhcnJheVtpXSwgaSwgYXJyYXksIHJlc3VsdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgZikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZih2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbHRlcihhcnJheSwgdGVzdCkge1xuICAgIHRlc3QgPVxuICAgICAgICB0ZXN0IHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbHRlck9iamVjdChvYmplY3QsIHRlc3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoKHRlc3QgJiYgdGVzdCh2YWx1ZSwga2V5LCBvYmplY3QsIHJlc3VsdCkpIHx8IEJvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYW55KGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVzdChhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uc19hbGwoYXJyYXksIHRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGVzdChhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJhbXNPYmplY3QoZGF0YSkge1xuICAgIHJldHVybiBtYXBPYmplY3QoZGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNhZmVKU09OU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZSh2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKGRhdGEpIHtcbiAgICB2YXIgcGFyYW1zID0gZmlsdGVyT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB2YXIgcXVlcnkgPSBtYXAoZmxhdHRlbihlbmNvZGVQYXJhbXNPYmplY3QocGFyYW1zKSksIHV0aWwubWV0aG9kKCdqb2luJywgJz0nKSkuam9pbignJicpO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIGRlY3ljbGVPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXSwgcGF0aHMgPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGRlcmV6KHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBpLCBuYW1lLCBudTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdHNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAkcmVmOiBwYXRoc1tpXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgbnUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudVtpXSA9IGRlcmV6KHZhbHVlW2ldLCBwYXRoICsgJ1snICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudVtuYW1lXSA9IGRlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgJ1snICsgSlNPTi5zdHJpbmdpZnkobmFtZSkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSkob2JqZWN0LCAnJCcpO1xufVxuZnVuY3Rpb24gc2FmZUpTT05TdHJpbmdpZnkoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNvdXJjZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlT2JqZWN0KHNvdXJjZSkpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9sb2dnZXIudHNcblxuXG5jbGFzcyBsb2dnZXJfTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxMb2cgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdsb2JhbExvZywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdsb2JhbExvZ1dhcm4sIGFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nRXJyb3IsIGFyZ3MpO1xuICAgIH1cbiAgICBnbG9iYWxMb2dXYXJuKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxMb2dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ1dhcm4obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nKGRlZmF1bHRMb2dnaW5nRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmdpZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGNvcmVfcHVzaGVyLmxvZykge1xuICAgICAgICAgICAgY29yZV9wdXNoZXIubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcmVfcHVzaGVyLmxvZ1RvQ29uc29sZSkge1xuICAgICAgICAgICAgY29uc3QgbG9nID0gZGVmYXVsdExvZ2dpbmdGdW5jdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgbG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbG9nZ2VyID0gKG5ldyBsb2dnZXJfTG9nZ2VyKCkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvYXV0aC9qc29ucF9hdXRoLnRzXG5cbnZhciBqc29ucCA9IGZ1bmN0aW9uIChjb250ZXh0LCBxdWVyeSwgYXV0aE9wdGlvbnMsIGF1dGhSZXF1ZXN0VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXV0aE9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGF1dGhPcHRpb25zLmhlYWRlcnNQcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBUbyBzZW5kIGhlYWRlcnMgd2l0aCB0aGUgJHthdXRoUmVxdWVzdFR5cGUudG9TdHJpbmcoKX0gcmVxdWVzdCwgeW91IG11c3QgdXNlIEFKQVgsIHJhdGhlciB0aGFuIEpTT05QLmApO1xuICAgIH1cbiAgICB2YXIgY2FsbGJhY2tOYW1lID0gY29udGV4dC5uZXh0QXV0aENhbGxiYWNrSUQudG9TdHJpbmcoKTtcbiAgICBjb250ZXh0Lm5leHRBdXRoQ2FsbGJhY2tJRCsrO1xuICAgIHZhciBkb2N1bWVudCA9IGNvbnRleHQuZ2V0RG9jdW1lbnQoKTtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgY29udGV4dC5hdXRoX2NhbGxiYWNrc1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfTtcbiAgICB2YXIgY2FsbGJhY2tfbmFtZSA9IFwiUHVzaGVyLmF1dGhfY2FsbGJhY2tzWydcIiArIGNhbGxiYWNrTmFtZSArIFwiJ11cIjtcbiAgICBzY3JpcHQuc3JjID1cbiAgICAgICAgYXV0aE9wdGlvbnMuZW5kcG9pbnQgK1xuICAgICAgICAgICAgJz9jYWxsYmFjaz0nICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja19uYW1lKSArXG4gICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgcXVlcnk7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIganNvbnBfYXV0aCA9IChqc29ucCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vc2NyaXB0X3JlcXVlc3QudHNcbmNsYXNzIFNjcmlwdFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKHNyYykge1xuICAgICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB9XG4gICAgc2VuZChyZWNlaXZlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBlcnJvclN0cmluZyA9ICdFcnJvciBsb2FkaW5nICcgKyBzZWxmLnNyYztcbiAgICAgICAgc2VsZi5zY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2VsZi5zY3JpcHQuaWQgPSByZWNlaXZlci5pZDtcbiAgICAgICAgc2VsZi5zY3JpcHQuc3JjID0gc2VsZi5zcmM7XG4gICAgICAgIHNlbGYuc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2VsZi5zY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgICAgIGlmIChzZWxmLnNjcmlwdC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbGxiYWNrKGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNjcmlwdC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcmlwdC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuc2NyaXB0LmFzeW5jID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50ICYmXG4gICAgICAgICAgICAvb3BlcmEvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yU2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzZWxmLmVycm9yU2NyaXB0LmlkID0gcmVjZWl2ZXIuaWQgKyAnX2Vycm9yJztcbiAgICAgICAgICAgIHNlbGYuZXJyb3JTY3JpcHQudGV4dCA9IHJlY2VpdmVyLm5hbWUgKyBcIignXCIgKyBlcnJvclN0cmluZyArIFwiJyk7XCI7XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5hc3luYyA9IHNlbGYuZXJyb3JTY3JpcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNlbGYuc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAoc2VsZi5lcnJvclNjcmlwdCkge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2VsZi5lcnJvclNjcmlwdCwgc2VsZi5zY3JpcHQubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JpcHQub25sb2FkID0gdGhpcy5zY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdCAmJiB0aGlzLnNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lcnJvclNjcmlwdCAmJiB0aGlzLmVycm9yU2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVycm9yU2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3JTY3JpcHQgPSBudWxsO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2RvbS9qc29ucF9yZXF1ZXN0LnRzXG5cblxuY2xhc3MganNvbnBfcmVxdWVzdF9KU09OUFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgZGF0YSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgc2VuZChyZWNlaXZlcikge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyh0aGlzLmRhdGEpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwgKyAnLycgKyByZWNlaXZlci5udW1iZXIgKyAnPycgKyBxdWVyeTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcnVudGltZS5jcmVhdGVTY3JpcHRSZXF1ZXN0KHVybCk7XG4gICAgICAgIHRoaXMucmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL3RpbWVsaW5lL2pzb25wX3RpbWVsaW5lLnRzXG5cblxudmFyIGdldEFnZW50ID0gZnVuY3Rpb24gKHNlbmRlciwgdXNlVExTKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NoZW1lID0gJ2h0dHAnICsgKHVzZVRMUyA/ICdzJyA6ICcnKSArICc6Ly8nO1xuICAgICAgICB2YXIgdXJsID0gc2NoZW1lICsgKHNlbmRlci5ob3N0IHx8IHNlbmRlci5vcHRpb25zLmhvc3QpICsgc2VuZGVyLm9wdGlvbnMucGF0aDtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZUpTT05QUmVxdWVzdCh1cmwsIGRhdGEpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBydW50aW1lLlNjcmlwdFJlY2VpdmVycy5jcmVhdGUoZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgIFNjcmlwdFJlY2VpdmVycy5yZW1vdmUocmVjZWl2ZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5jbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5ob3N0KSB7XG4gICAgICAgICAgICAgICAgc2VuZGVyLmhvc3QgPSByZXN1bHQuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICB9O1xufTtcbnZhciBqc29ucF90aW1lbGluZV9qc29ucCA9IHtcbiAgICBuYW1lOiAnanNvbnAnLFxuICAgIGdldEFnZW50XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIganNvbnBfdGltZWxpbmUgPSAoanNvbnBfdGltZWxpbmVfanNvbnApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdXJsX3NjaGVtZXMudHNcblxuZnVuY3Rpb24gZ2V0R2VuZXJpY1VSTChiYXNlU2NoZW1lLCBwYXJhbXMsIHBhdGgpIHtcbiAgICB2YXIgc2NoZW1lID0gYmFzZVNjaGVtZSArIChwYXJhbXMudXNlVExTID8gJ3MnIDogJycpO1xuICAgIHZhciBob3N0ID0gcGFyYW1zLnVzZVRMUyA/IHBhcmFtcy5ob3N0VExTIDogcGFyYW1zLmhvc3ROb25UTFM7XG4gICAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgaG9zdCArIHBhdGg7XG59XG5mdW5jdGlvbiBnZXRHZW5lcmljUGF0aChrZXksIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhdGggPSAnL2FwcC8nICsga2V5O1xuICAgIHZhciBxdWVyeSA9ICc/cHJvdG9jb2w9JyArXG4gICAgICAgIGRlZmF1bHRzLlBST1RPQ09MICtcbiAgICAgICAgJyZjbGllbnQ9anMnICtcbiAgICAgICAgJyZ2ZXJzaW9uPScgK1xuICAgICAgICBkZWZhdWx0cy5WRVJTSU9OICtcbiAgICAgICAgKHF1ZXJ5U3RyaW5nID8gJyYnICsgcXVlcnlTdHJpbmcgOiAnJyk7XG4gICAgcmV0dXJuIHBhdGggKyBxdWVyeTtcbn1cbnZhciB3cyA9IHtcbiAgICBnZXRJbml0aWFsOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhdGggPSAocGFyYW1zLmh0dHBQYXRoIHx8ICcnKSArIGdldEdlbmVyaWNQYXRoKGtleSwgJ2ZsYXNoPWZhbHNlJyk7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCd3cycsIHBhcmFtcywgcGF0aCk7XG4gICAgfVxufTtcbnZhciBodHRwID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJy9wdXNoZXInKSArIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCdodHRwJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIHNvY2tqcyA9IHtcbiAgICBnZXRJbml0aWFsOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpO1xuICAgIH0sXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljUGF0aChrZXkpO1xuICAgIH1cbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2NhbGxiYWNrX3JlZ2lzdHJ5LnRzXG5cbmNsYXNzIGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICB9XG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1twcmVmaXgobmFtZSldO1xuICAgIH1cbiAgICBhZGQobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByZWZpeGVkRXZlbnROYW1lID0gcHJlZml4KG5hbWUpO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3NbcHJlZml4ZWRFdmVudE5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gfHwgW107XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0ucHVzaCh7XG4gICAgICAgICAgICBmbjogY2FsbGJhY2ssXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmUobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZSA/IFtwcmVmaXgobmFtZSldIDoga2V5cyh0aGlzLl9jYWxsYmFja3MpO1xuICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDYWxsYmFjayhuYW1lcywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxDYWxsYmFja3MobmFtZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1tuYW1lXSA9IGZpbHRlcih0aGlzLl9jYWxsYmFja3NbbmFtZV0gfHwgW10sIGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGJpbmRpbmcuZm4pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGJpbmRpbmcuY29udGV4dCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICByZW1vdmVBbGxDYWxsYmFja3MobmFtZXMpIHtcbiAgICAgICAgYXBwbHkobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW25hbWVdO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVmaXgobmFtZSkge1xuICAgIHJldHVybiAnXycgKyBuYW1lO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2V2ZW50cy9kaXNwYXRjaGVyLnRzXG5cblxuY2xhc3MgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsVGhyb3VnaCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBjYWxsYmFja19yZWdpc3RyeV9DYWxsYmFja1JlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmZhaWxUaHJvdWdoID0gZmFpbFRocm91Z2g7XG4gICAgfVxuICAgIGJpbmQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiaW5kX2dsb2JhbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5yZW1vdmUoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gZmlsdGVyKHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyB8fCBbXSwgYyA9PiBjICE9PSBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfYWxsKCkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLnVuYmluZF9nbG9iYWwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2xvYmFsX2NhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzW2ldKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzLmdldChldmVudE5hbWUpO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFja3MgJiYgY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmZuLmFwcGx5KGNhbGxiYWNrc1tpXS5jb250ZXh0IHx8IHdpbmRvdywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mYWlsVGhyb3VnaCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsVGhyb3VnaChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uLnRzXG5cblxuXG5cblxuY2xhc3MgdHJhbnNwb3J0X2Nvbm5lY3Rpb25fVHJhbnNwb3J0Q29ubmVjdGlvbiBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoaG9va3MsIG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplID0gcnVudGltZS50cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICduZXcnO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBvcHRpb25zLmFjdGl2aXR5VGltZW91dDtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMudGltZWxpbmUuZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3MuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNQaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhvb2tzLnN1cHBvcnRzUGluZyk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCB8fCB0aGlzLnN0YXRlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaG9va3MudXJscy5nZXRJbml0aWFsKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLmhvb2tzLmdldFNvY2tldCh1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0Nvbm5lY3RpbmcnLCB7IHRyYW5zcG9ydDogdGhpcy5uYW1lLCB1cmwgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nICYmIHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYmVmb3JlT3Blbih0aGlzLnNvY2tldCwgdGhpcy5ob29rcy51cmxzLmdldFBhdGgodGhpcy5rZXksIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih0aGlzLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSkpO1xuICAgIH1cbiAgICBvbkNsb3NlKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBjbG9zZUV2ZW50LnJlYXNvbixcbiAgICAgICAgICAgICAgICB3YXNDbGVhbjogY2xvc2VFdmVudC53YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBjbG9zZUV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShjbG9zZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGJ1aWxkVGltZWxpbmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7IGNpZDogdGhpcy5pZCB9LCBtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnQudHNcblxuY2xhc3MgdHJhbnNwb3J0X1RyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoaG9va3MpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rcy5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24odGhpcy5ob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG52YXIgV1NUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCh7XG4gICAgdXJsczogd3MsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gcnVudGltZS5jcmVhdGVXZWJTb2NrZXQodXJsKTtcbiAgICB9XG59KTtcbnZhciBodHRwQ29uZmlndXJhdGlvbiA9IHtcbiAgICB1cmxzOiBodHRwLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiB0cnVlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuSFRUUEZhY3RvcnkuY3JlYXRlU3RyZWFtaW5nU29ja2V0KHVybCk7XG4gICAgfVxufSwgaHR0cENvbmZpZ3VyYXRpb24pO1xudmFyIHBvbGxpbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuSFRUUEZhY3RvcnkuY3JlYXRlUG9sbGluZ1NvY2tldCh1cmwpO1xuICAgIH1cbn0sIGh0dHBDb25maWd1cmF0aW9uKTtcbnZhciB4aHJDb25maWd1cmF0aW9uID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBydW50aW1lLmlzWEhSU3VwcG9ydGVkKCk7XG4gICAgfVxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydChleHRlbmQoe30sIHBvbGxpbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSk7XG52YXIgVHJhbnNwb3J0cyA9IHtcbiAgICB3czogV1NUcmFuc3BvcnQsXG4gICAgeGhyX3N0cmVhbWluZzogWEhSU3RyZWFtaW5nVHJhbnNwb3J0LFxuICAgIHhocl9wb2xsaW5nOiBYSFJQb2xsaW5nVHJhbnNwb3J0XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0cyA9IChUcmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG5cblxudmFyIFNvY2tKU1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfVHJhbnNwb3J0KHtcbiAgICBmaWxlOiAnc29ja2pzJyxcbiAgICB1cmxzOiBzb2NranMsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiB0cnVlLFxuICAgIHN1cHBvcnRzUGluZzogZmFsc2UsXG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc0luaXRpYWxpemVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU29ja0pTICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU29ja0pTKHVybCwgbnVsbCwge1xuICAgICAgICAgICAganNfcGF0aDogRGVwZW5kZW5jaWVzLmdldFBhdGgoJ3NvY2tqcycsIHtcbiAgICAgICAgICAgICAgICB1c2VUTFM6IG9wdGlvbnMudXNlVExTXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGlnbm9yZV9udWxsX29yaWdpbjogb3B0aW9ucy5pZ25vcmVOdWxsT3JpZ2luXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYmVmb3JlT3BlbjogZnVuY3Rpb24gKHNvY2tldCwgcGF0aCkge1xuICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pKTtcbiAgICB9XG59KTtcbnZhciB4ZHJDb25maWd1cmF0aW9uID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHllcyA9IHJ1bnRpbWUuaXNYRFJTdXBwb3J0ZWQoZW52aXJvbm1lbnQudXNlVExTKTtcbiAgICAgICAgcmV0dXJuIHllcztcbiAgICB9XG59O1xudmFyIFhEUlN0cmVhbWluZ1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfVHJhbnNwb3J0KChleHRlbmQoe30sIHN0cmVhbWluZ0NvbmZpZ3VyYXRpb24sIHhkckNvbmZpZ3VyYXRpb24pKSk7XG52YXIgWERSUG9sbGluZ1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfVHJhbnNwb3J0KGV4dGVuZCh7fSwgcG9sbGluZ0NvbmZpZ3VyYXRpb24sIHhkckNvbmZpZ3VyYXRpb24pKTtcbnRyYW5zcG9ydHMueGRyX3N0cmVhbWluZyA9IFhEUlN0cmVhbWluZ1RyYW5zcG9ydDtcbnRyYW5zcG9ydHMueGRyX3BvbGxpbmcgPSBYRFJQb2xsaW5nVHJhbnNwb3J0O1xudHJhbnNwb3J0cy5zb2NranMgPSBTb2NrSlNUcmFuc3BvcnQ7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRzX3RyYW5zcG9ydHMgPSAodHJhbnNwb3J0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9uZXRfaW5mby50c1xuXG5jbGFzcyBuZXRfaW5mb19OZXRJbmZvIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ29ubGluZScpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdvZmZsaW5lJyk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNPbmxpbmUoKSB7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBuZXRfaW5mb19OZXR3b3JrID0gbmV3IG5ldF9pbmZvX05ldEluZm8oKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL2Fzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIudHNcblxuXG5jbGFzcyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm1pblBpbmdEZWxheSA9IG9wdGlvbnMubWluUGluZ0RlbGF5O1xuICAgICAgICB0aGlzLm1heFBpbmdEZWxheSA9IG9wdGlvbnMubWF4UGluZ0RlbGF5O1xuICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5waW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wZW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBvcGVuVGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMiB8fCBjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjbG9zZUV2ZW50Lndhc0NsZWFuICYmIG9wZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlmZXNwYW4gPSB1dGlsLm5vdygpIC0gb3BlblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAobGlmZXNwYW4gPCAyICogdGhpcy5tYXhQaW5nRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gTWF0aC5tYXgobGlmZXNwYW4gLyAyLCB0aGlzLm1pblBpbmdEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5pc0FsaXZlKCkgJiYgdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL3Byb3RvY29sL3Byb3RvY29sLnRzXG5jb25zdCBQcm90b2NvbCA9IHtcbiAgICBkZWNvZGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZURhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudERhdGEgPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwdXNoZXJFdmVudERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBtZXNzYWdlRGF0YS5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50RGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQudXNlcl9pZCA9IG1lc3NhZ2VEYXRhLnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJywgZXJyb3I6IGUsIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0hhbmRzaGFrZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCcpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYWN0aXZpdHkgdGltZW91dCBzcGVjaWZpZWQgaW4gaGFuZHNoYWtlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5kYXRhLnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG1lc3NhZ2UuZGF0YS5hY3Rpdml0eV90aW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBoYW5kc2hha2UnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUFjdGlvbjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQwMDApIHtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPj0gMTAwMiAmJiBjbG9zZUV2ZW50LmNvZGUgPD0gMTAwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAndGxzX29ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlRXJyb3I6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDAgJiYgY2xvc2VFdmVudC5jb2RlICE9PSAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNsb3NlRXZlbnQucmVhc29uIHx8IGNsb3NlRXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm90b2NvbF9wcm90b2NvbCA9IChQcm90b2NvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uLnRzXG5cblxuXG5cbmNsYXNzIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIHRyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IHRyYW5zcG9ydC5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBldmVudDogbmFtZSwgZGF0YTogZGF0YSB9O1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgZXZlbnQuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdFdmVudCBzZW50JywgZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHByb3RvY29sX3Byb3RvY29sLmVuY29kZU1lc3NhZ2UoZXZlbnQpKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5waW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwaW5nJywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoZXJFdmVudCA9IHByb3RvY29sX3Byb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNzYWdlUGFyc2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVzaGVyRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHJlY2QnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHVzaGVyRXZlbnQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjplcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQgJiYgY2xvc2VFdmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudChjbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcHJvdG9jb2xfcHJvdG9jb2wuZ2V0Q2xvc2VBY3Rpb24oY2xvc2VFdmVudCk7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoYWN0aW9uLCB7IGFjdGlvbjogYWN0aW9uLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9oYW5kc2hha2UvaW5kZXgudHNcblxuXG5cbmNsYXNzIGhhbmRzaGFrZV9IYW5kc2hha2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG0gPT4ge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3RvY29sX3Byb3RvY29sLnByb2Nlc3NIYW5kc2hha2UobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCdlcnJvcicsIHsgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgnY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgY29ubmVjdGlvbl9Db25uZWN0aW9uKHJlc3VsdC5pZCwgdGhpcy50cmFuc3BvcnQpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHJlc3VsdC5hY3Rpdml0eVRpbWVvdXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKHJlc3VsdC5hY3Rpb24sIHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpIHx8ICdiYWNrb2ZmJztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaChhY3Rpb24sIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCB0aGlzLm9uQ2xvc2VkKTtcbiAgICB9XG4gICAgdW5iaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfVxuICAgIGZpbmlzaChhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGV4dGVuZCh7IHRyYW5zcG9ydDogdGhpcy50cmFuc3BvcnQsIGFjdGlvbjogYWN0aW9uIH0sIHBhcmFtcykpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZV9zZW5kZXIudHNcblxuY2xhc3MgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHNlbmQodXNlVExTLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lLnNlbmQocnVudGltZS5UaW1lbGluZVRyYW5zcG9ydC5nZXRBZ2VudCh0aGlzLCB1c2VUTFMpLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2NoYW5uZWwudHNcblxuXG5cblxuXG5jbGFzcyBjaGFubmVsX0NoYW5uZWwgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnTm8gY2FsbGJhY2tzIG9uICcgKyBuYW1lICsgJyBmb3IgJyArIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgYXV0aDogJycgfSk7XG4gICAgfVxuICAgIHRyaWdnZXIoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKGV2ZW50LmluZGV4T2YoJ2NsaWVudC0nKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhZEV2ZW50TmFtZShcIkV2ZW50ICdcIiArIGV2ZW50ICsgXCInIGRvZXMgbm90IHN0YXJ0IHdpdGggJ2NsaWVudC0nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCd0cmlnZ2VyaW5nQ2xpZW50RXZlbnRzJyk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQ2xpZW50IGV2ZW50IHRyaWdnZXJlZCBiZWZvcmUgY2hhbm5lbCAnc3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcgZXZlbnQgLiAke3N1ZmZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoZXIuc2VuZF9ldmVudChldmVudCwgZGF0YSwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOnN1YnNjcmlwdGlvbl9jb3VudCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoZXIudW5zdWJzY3JpYmUodGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9zdWNjZWVkZWQnLCBldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpcHRpb25Db3VudEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25Db3VudCA9IGV2ZW50LmRhdGEuc3Vic2NyaXB0aW9uX2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9jb3VudCcsIGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dGhvcml6ZSh0aGlzLnB1c2hlci5jb25uZWN0aW9uLnNvY2tldF9pZCwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX2Vycm9yJywgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQXV0aEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9LCBlcnJvciBpbnN0YW5jZW9mIEhUVFBBdXRoRXJyb3IgPyB7IHN0YXR1czogZXJyb3Iuc3RhdHVzIH0gOiB7fSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoZXIuc2VuZF9ldmVudCgncHVzaGVyOnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aDogZGF0YS5hdXRoLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsX2RhdGE6IGRhdGEuY2hhbm5lbF9kYXRhLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiB0aGlzLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoZXIuc2VuZF9ldmVudCgncHVzaGVyOnVuc3Vic2NyaWJlJywge1xuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYW5jZWxTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVpbnN0YXRlU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcml2YXRlX2NoYW5uZWwudHNcblxuY2xhc3MgcHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsIGV4dGVuZHMgY2hhbm5lbF9DaGFubmVsIHtcbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hlci5jb25maWcuY2hhbm5lbEF1dGhvcml6ZXIoe1xuICAgICAgICAgICAgY2hhbm5lbE5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHNvY2tldElkOiBzb2NrZXRJZFxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL21lbWJlcnMudHNcblxuY2xhc3MgbWVtYmVyc19NZW1iZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1lbWJlcnMsIGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgaW5mbzogdGhpcy5tZW1iZXJzW2lkXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5tZW1iZXJzLCAobWVtYmVyLCBpZCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5nZXQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE15SUQoaWQpIHtcbiAgICAgICAgdGhpcy5teUlEID0gaWQ7XG4gICAgfVxuICAgIG9uU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gc3Vic2NyaXB0aW9uRGF0YS5wcmVzZW5jZS5oYXNoO1xuICAgICAgICB0aGlzLmNvdW50ID0gc3Vic2NyaXB0aW9uRGF0YS5wcmVzZW5jZS5jb3VudDtcbiAgICAgICAgdGhpcy5tZSA9IHRoaXMuZ2V0KHRoaXMubXlJRCk7XG4gICAgfVxuICAgIGFkZE1lbWJlcihtZW1iZXJEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF0gPSBtZW1iZXJEYXRhLnVzZXJfaW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG1lbWJlckRhdGEudXNlcl9pZCk7XG4gICAgfVxuICAgIHJlbW92ZU1lbWJlcihtZW1iZXJEYXRhKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF07XG4gICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbWJlcjtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IHt9O1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5teUlEID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZSA9IG51bGw7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL3ByZXNlbmNlX2NoYW5uZWwudHNcbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcblxuXG5cblxuY2xhc3MgcHJlc2VuY2VfY2hhbm5lbF9QcmVzZW5jZUNoYW5uZWwgZXh0ZW5kcyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHB1c2hlcikge1xuICAgICAgICBzdXBlcihuYW1lLCBwdXNoZXIpO1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBuZXcgbWVtYmVyc19NZW1iZXJzKCk7XG4gICAgfVxuICAgIGF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIuYXV0aG9yaXplKHNvY2tldElkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXV0aERhdGEgPSBhdXRoRGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aERhdGEuY2hhbm5lbF9kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gSlNPTi5wYXJzZShhdXRoRGF0YS5jaGFubmVsX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRChjaGFubmVsRGF0YS51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVzaGVyLnVzZXIuc2lnbmluRG9uZVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1c2hlci51c2VyLnVzZXJfZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRCh0aGlzLnB1c2hlci51c2VyLnVzZXJfZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRob3JpemF0aW9uRW5kcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBhdXRoIHJlc3BvbnNlIGZvciBjaGFubmVsICcke3RoaXMubmFtZX0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgJ2NoYW5uZWxfZGF0YScgZmllbGQuICR7c3VmZml4fSwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYG9yIHRoZSB1c2VyIHNob3VsZCBiZSBzaWduZWQgaW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygnSW52YWxpZCBhdXRoIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgYXV0aERhdGEpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJuYWxFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmIChldmVudC51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudXNlcl9pZCA9IGV2ZW50LnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlSW50ZXJuYWxFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX2FkZGVkJzpcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMuYWRkTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9hZGRlZCcsIGFkZGVkTWVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDptZW1iZXJfcmVtb3ZlZCc6XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMucmVtb3ZlTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywgcmVtb3ZlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMub25TdWJzY3JpcHRpb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgdGhpcy5tZW1iZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMucmVzZXQoKTtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL3V0ZjgvbGliL3V0ZjguanNcbnZhciB1dGY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL2Jhc2U2NC9saWIvYmFzZTY0LmpzXG52YXIgYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9lbmNyeXB0ZWRfY2hhbm5lbC50c1xuXG5cblxuXG5cbmNsYXNzIGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwgZXh0ZW5kcyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHB1c2hlciwgbmFjbCkge1xuICAgICAgICBzdXBlcihuYW1lLCBwdXNoZXIpO1xuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICAgIHRoaXMubmFjbCA9IG5hY2w7XG4gICAgfVxuICAgIGF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIuYXV0aG9yaXplKHNvY2tldElkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgYXV0aERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaGFyZWRTZWNyZXQgPSBhdXRoRGF0YVsnc2hhcmVkX3NlY3JldCddO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYE5vIHNoYXJlZF9zZWNyZXQga2V5IGluIGF1dGggcGF5bG9hZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWw6ICR7dGhpcy5uYW1lfWApLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmtleSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICBkZWxldGUgYXV0aERhdGFbJ3NoYXJlZF9zZWNyZXQnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGF1dGhEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXIoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZSgnQ2xpZW50IGV2ZW50cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIGVuY3J5cHRlZCBjaGFubmVscycpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgPT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXI6JykgPT09IDApIHtcbiAgICAgICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgfVxuICAgIGhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnUmVjZWl2ZWQgZW5jcnlwdGVkIGV2ZW50IGJlZm9yZSBrZXkgaGFzIGJlZW4gcmV0cmlldmVkIGZyb20gdGhlIGF1dGhFbmRwb2ludCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5jaXBoZXJ0ZXh0IHx8ICFkYXRhLm5vbmNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgZm9ybWF0IGZvciBlbmNyeXB0ZWQgZXZlbnQsIGV4cGVjdGVkIG9iamVjdCB3aXRoIGBjaXBoZXJ0ZXh0YCBhbmQgYG5vbmNlYCBmaWVsZHMsIGdvdDogJyArXG4gICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNpcGhlclRleHQgPSBPYmplY3QoYmFzZTY0W1wiZGVjb2RlXCJdKShkYXRhLmNpcGhlcnRleHQpO1xuICAgICAgICBpZiAoY2lwaGVyVGV4dC5sZW5ndGggPCB0aGlzLm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEV4cGVjdGVkIGVuY3J5cHRlZCBldmVudCBjaXBoZXJ0ZXh0IGxlbmd0aCB0byBiZSAke3RoaXMubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGh9LCBnb3Q6ICR7Y2lwaGVyVGV4dC5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vbmNlID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoZGF0YS5ub25jZSk7XG4gICAgICAgIGlmIChub25jZS5sZW5ndGggPCB0aGlzLm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEV4cGVjdGVkIGVuY3J5cHRlZCBldmVudCBub25jZSBsZW5ndGggdG8gYmUgJHt0aGlzLm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RofSwgZ290OiAke25vbmNlLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLm5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVyVGV4dCwgbm9uY2UsIHRoaXMua2V5KTtcbiAgICAgICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBkZWNyeXB0IGFuIGV2ZW50LCBwcm9iYWJseSBiZWNhdXNlIGl0IHdhcyBlbmNyeXB0ZWQgd2l0aCBhIGRpZmZlcmVudCBrZXkuIEZldGNoaW5nIGEgbmV3IGtleSBmcm9tIHRoZSBhdXRoRW5kcG9pbnQuLi4nKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXplKHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBhdXRoRW5kcG9pbnQ6ICR7YXV0aERhdGF9LiBVbmFibGUgdG8gZmV0Y2ggbmV3IGtleSwgc28gZHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSB0aGlzLm5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVyVGV4dCwgbm9uY2UsIHRoaXMua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVjcnlwdCBldmVudCB3aXRoIG5ldyBrZXkuIERyb3BwaW5nIGVuY3J5cHRlZCBldmVudGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwgdGhpcy5nZXREYXRhVG9FbWl0KGJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCB0aGlzLmdldERhdGFUb0VtaXQoYnl0ZXMpKTtcbiAgICB9XG4gICAgZ2V0RGF0YVRvRW1pdChieXRlcykge1xuICAgICAgICBsZXQgcmF3ID0gT2JqZWN0KHV0ZjhbXCJkZWNvZGVcIl0pKGJ5dGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9tYW5hZ2VyLnRzXG5cblxuXG5cblxuY2xhc3MgY29ubmVjdGlvbl9tYW5hZ2VyX0Nvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGhpcy5vcHRpb25zLnRpbWVsaW5lO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gdGhpcy5vcHRpb25zLnVzZVRMUztcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrcyA9IHRoaXMuYnVpbGRFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MgPSB0aGlzLmJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyh0aGlzLmVycm9yQ2FsbGJhY2tzKTtcbiAgICAgICAgdGhpcy5oYW5kc2hha2VDYWxsYmFja3MgPSB0aGlzLmJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzKHRoaXMuZXJyb3JDYWxsYmFja3MpO1xuICAgICAgICB2YXIgTmV0d29yayA9IHJ1bnRpbWUuZ2V0TmV0d29yaygpO1xuICAgICAgICBOZXR3b3JrLmJpbmQoJ29ubGluZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IG5ldGluZm86ICdvbmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAndW5hdmFpbGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvZmZsaW5lJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29mZmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICB9XG4gICAgc3dpdGNoQ2x1c3RlcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uIHx8IHRoaXMucnVubmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgdGhpcy5zZXRVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgfVxuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZF9ldmVudChuYW1lLCBkYXRhLCBjaGFubmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZF9ldmVudChuYW1lLCBkYXRhLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RJbnRlcm5hbGx5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIH1cbiAgICBpc1VzaW5nVExTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2luZ1RMUztcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSAoZXJyb3IsIGhhbmRzaGFrZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uZXIgPSB0aGlzLnN0cmF0ZWd5LmNvbm5lY3QoMCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZS5hY3Rpb24gPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdIYW5kc2hha2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogaGFuZHNoYWtlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmVycm9yKHsgaGFuZHNoYWtlRXJyb3I6IGhhbmRzaGFrZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlQ2FsbGJhY2tzW2hhbmRzaGFrZS5hY3Rpb25dKGhhbmRzaGFrZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bm5lciA9IHRoaXMuc3RyYXRlZ3kuY29ubmVjdCgwLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGFib3J0Q29ubmVjdGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RJbnRlcm5hbGx5KCkge1xuICAgICAgICB0aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLmNsZWFyUmV0cnlUaW1lcigpO1xuICAgICAgICB0aGlzLmNsZWFyVW5hdmFpbGFibGVUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuYWJhbmRvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdHJhdGVneSgpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHRoaXMub3B0aW9ucy5nZXRTdHJhdGVneSh7XG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMudGltZWxpbmUsXG4gICAgICAgICAgICB1c2VUTFM6IHRoaXMudXNpbmdUTFNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHJ5SW4oZGVsYXkpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgYWN0aW9uOiAncmV0cnknLCBkZWxheTogZGVsYXkgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZ19pbicsIE1hdGgucm91bmQoZGVsYXkgLyAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcihkZWxheSB8fCAwLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RJbnRlcm5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyUmV0cnlUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VW5hdmFpbGFibGVUaW1lcigpIHtcbiAgICAgICAgdGhpcy51bmF2YWlsYWJsZVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMudW5hdmFpbGFibGVUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCd1bmF2YWlsYWJsZScpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy51bmF2YWlsYWJsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnVuYXZhaWxhYmxlVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5waW5nKCk7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmVycm9yKHsgcG9uZ190aW1lZF9vdXQ6IHRoaXMub3B0aW9ucy5wb25nVGltZW91dCB9KTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0QWN0aXZpdHlDaGVjaygpIHtcbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmICF0aGlzLmNvbm5lY3Rpb24uaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5hY3Rpdml0eVRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQWN0aXZpdHlDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZpdHlUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZENvbm5lY3Rpb25DYWxsYmFja3MoZXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZXJyb3JDYWxsYmFja3MsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGluZzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZF9ldmVudCgncHVzaGVyOnBvbmcnLCB7fSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFiYW5kb25Db25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmV0cnkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5SW4oMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRIYW5kc2hha2VDYWxsYmFja3MoZXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZXJyb3JDYWxsYmFja3MsIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZDogKGhhbmRzaGFrZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lb3V0ID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmFjdGl2aXR5VGltZW91dCwgaGFuZHNoYWtlLmFjdGl2aXR5VGltZW91dCwgaGFuZHNoYWtlLmNvbm5lY3Rpb24uYWN0aXZpdHlUaW1lb3V0IHx8IEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVW5hdmFpbGFibGVUaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihoYW5kc2hha2UuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRfaWQgPSB0aGlzLmNvbm5lY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnY29ubmVjdGVkJywgeyBzb2NrZXRfaWQ6IHRoaXMuc29ja2V0X2lkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRFcnJvckNhbGxiYWNrcygpIHtcbiAgICAgICAgbGV0IHdpdGhFcnJvckVtaXR0ZWQgPSBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgdHlwZTogJ1dlYlNvY2tldEVycm9yJywgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bHNfb25seTogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2luZ1RMUyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdHJhdGVneSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVmdXNlZDogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJhY2tvZmY6IHdpdGhFcnJvckVtaXR0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigxMDAwKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmV0cnk6IHdpdGhFcnJvckVtaXR0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKGV2ZW50LCB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3NbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgIH1cbiAgICBhYmFuZG9uQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnVuYmluZChldmVudCwgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgZGF0YSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVEZXNjcmlwdGlvbiA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlRGVzY3JpcHRpb24gPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVEZXNjcmlwdGlvbiArPSAnIHdpdGggbmV3IHNvY2tldCBJRCAnICsgZGF0YS5zb2NrZXRfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1N0YXRlIGNoYW5nZWQnLCBwcmV2aW91c1N0YXRlICsgJyAtPiAnICsgbmV3U3RhdGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBzdGF0ZTogbmV3U3RhdGUsIHBhcmFtczogZGF0YSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGVfY2hhbmdlJywgeyBwcmV2aW91czogcHJldmlvdXNTdGF0ZSwgY3VycmVudDogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZFJldHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVscy50c1xuXG5cblxuXG5jbGFzcyBjaGFubmVsc19DaGFubmVscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgICB9XG4gICAgYWRkKG5hbWUsIHB1c2hlcikge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbm5lbHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbbmFtZV0gPSBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh0aGlzLmNoYW5uZWxzKTtcbiAgICB9XG4gICAgZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH1cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5jaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtZW5jcnlwdGVkLScpID09PSAwKSB7XG4gICAgICAgIGlmIChwdXNoZXIuY29uZmlnLm5hY2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUVuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBwdXNoZXIuY29uZmlnLm5hY2wpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJNc2cgPSAnVHJpZWQgdG8gc3Vic2NyaWJlIHRvIGEgcHJpdmF0ZS1lbmNyeXB0ZWQtIGNoYW5uZWwgYnV0IG5vIG5hY2wgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQnKTtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZShgJHtlcnJNc2d9LiAke3N1ZmZpeH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcml2YXRlLScpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVByaXZhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigncHJlc2VuY2UtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCYWRDaGFubmVsTmFtZSgnQ2Fubm90IGNyZWF0ZSBhIGNoYW5uZWwgd2l0aCBuYW1lIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL2ZhY3RvcnkudHNcblxuXG5cblxuXG5cblxuXG5cbnZhciBGYWN0b3J5ID0ge1xuICAgIGNyZWF0ZUNoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxzX0NoYW5uZWxzKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDb25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIoa2V5LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2hhbm5lbF9DaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVQcml2YXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZVByZXNlbmNlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcmVzZW5jZV9jaGFubmVsX1ByZXNlbmNlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIG5hY2wpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlbmNyeXB0ZWRfY2hhbm5lbF9FbmNyeXB0ZWRDaGFubmVsKG5hbWUsIHB1c2hlciwgbmFjbCk7XG4gICAgfSxcbiAgICBjcmVhdGVUaW1lbGluZVNlbmRlcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlcih0aW1lbGluZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjcmVhdGVIYW5kc2hha2UodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IGhhbmRzaGFrZV9IYW5kc2hha2UodHJhbnNwb3J0LCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBjcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmFjdG9yeSA9IChGYWN0b3J5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL3RyYW5zcG9ydF9tYW5hZ2VyLnRzXG5cbmNsYXNzIHRyYW5zcG9ydF9tYW5hZ2VyX1RyYW5zcG9ydE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5saXZlc0xlZnQgPSB0aGlzLm9wdGlvbnMubGl2ZXMgfHwgSW5maW5pdHk7XG4gICAgfVxuICAgIGdldEFzc2lzdGFudCh0cmFuc3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyKHRoaXMsIHRyYW5zcG9ydCwge1xuICAgICAgICAgICAgbWluUGluZ0RlbGF5OiB0aGlzLm9wdGlvbnMubWluUGluZ0RlbGF5LFxuICAgICAgICAgICAgbWF4UGluZ0RlbGF5OiB0aGlzLm9wdGlvbnMubWF4UGluZ0RlbGF5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0FsaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlc0xlZnQgPiAwO1xuICAgIH1cbiAgICByZXBvcnREZWF0aCgpIHtcbiAgICAgICAgdGhpcy5saXZlc0xlZnQgLT0gMTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9zZXF1ZW50aWFsX3N0cmF0ZWd5LnRzXG5cblxuXG5jbGFzcyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ2llcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0cmF0ZWdpZXMgPSBzdHJhdGVnaWVzO1xuICAgICAgICB0aGlzLmxvb3AgPSBCb29sZWFuKG9wdGlvbnMubG9vcCk7XG4gICAgICAgIHRoaXMuZmFpbEZhc3QgPSBCb29sZWFuKG9wdGlvbnMuZmFpbEZhc3QpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMudGltZW91dExpbWl0ID0gb3B0aW9ucy50aW1lb3V0TGltaXQ7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuc3RyYXRlZ2llcywgdXRpbC5tZXRob2QoJ2lzU3VwcG9ydGVkJykpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IHRoaXMuc3RyYXRlZ2llcztcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgdmFyIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIHZhciB0cnlOZXh0U3RyYXRlZ3kgPSAoZXJyb3IsIGhhbmRzaGFrZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudCAlIHN0cmF0ZWdpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA8IHN0cmF0ZWdpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gdGltZW91dCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgdGhpcy50aW1lb3V0TGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IHRoaXMudHJ5U3RyYXRlZ3koc3RyYXRlZ2llc1tjdXJyZW50XSwgbWluUHJpb3JpdHksIHsgdGltZW91dCwgZmFpbEZhc3Q6IHRoaXMuZmFpbEZhc3QgfSwgdHJ5TmV4dFN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcnVubmVyID0gdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0OiB0aW1lb3V0LCBmYWlsRmFzdDogdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJ5U3RyYXRlZ3koc3RyYXRlZ3ksIG1pblByaW9yaXR5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcihvcHRpb25zLnRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bm5lciA9IHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgdGltZXIgJiYgdGltZXIuaXNSdW5uaW5nKCkgJiYgIW9wdGlvbnMuZmFpbEZhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaGFuZHNoYWtlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneS50c1xuXG5cbmNsYXNzIGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ2llcykge1xuICAgICAgICB0aGlzLnN0cmF0ZWdpZXMgPSBzdHJhdGVnaWVzO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnN0cmF0ZWdpZXMsIHV0aWwubWV0aG9kKCdpc1N1cHBvcnRlZCcpKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3QodGhpcy5zdHJhdGVnaWVzLCBtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGksIHJ1bm5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHJ1bm5lcnNbaV0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbFJ1bm5lcnNGYWlsZWQocnVubmVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHkocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShoYW5kc2hha2UudHJhbnNwb3J0LnByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYW5kc2hha2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdChzdHJhdGVnaWVzLCBtaW5Qcmlvcml0eSwgY2FsbGJhY2tCdWlsZGVyKSB7XG4gICAgdmFyIHJ1bm5lcnMgPSBtYXAoc3RyYXRlZ2llcywgZnVuY3Rpb24gKHN0cmF0ZWd5LCBpLCBfLCBycykge1xuICAgICAgICByZXR1cm4gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2tCdWlsZGVyKGksIHJzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFwcGx5KHJ1bm5lcnMsIGFib3J0UnVubmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGFwcGx5KHJ1bm5lcnMsIGZ1bmN0aW9uIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFsbFJ1bm5lcnNGYWlsZWQocnVubmVycykge1xuICAgIHJldHVybiBjb2xsZWN0aW9uc19hbGwocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihydW5uZXIuZXJyb3IpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWJvcnRSdW5uZXIocnVubmVyKSB7XG4gICAgaWYgKCFydW5uZXIuZXJyb3IgJiYgIXJ1bm5lci5hYm9ydGVkKSB7XG4gICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICBydW5uZXIuYWJvcnRlZCA9IHRydWU7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvd2Vic29ja2V0X3ByaW9yaXRpemVkX2NhY2hlZF9zdHJhdGVneS50c1xuXG5cblxuXG5jbGFzcyB3ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5X1dlYlNvY2tldFByaW9yaXRpemVkQ2FjaGVkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCB0cmFuc3BvcnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRzID0gdHJhbnNwb3J0cztcbiAgICAgICAgdGhpcy50dGwgPSBvcHRpb25zLnR0bCB8fCAxODAwICogMTAwMDtcbiAgICAgICAgdGhpcy51c2luZ1RMUyA9IG9wdGlvbnMudXNlVExTO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB1c2luZ1RMUyA9IHRoaXMudXNpbmdUTFM7XG4gICAgICAgIHZhciBpbmZvID0gZmV0Y2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgIHZhciBjYWNoZVNraXBDb3VudCA9IGluZm8gJiYgaW5mby5jYWNoZVNraXBDb3VudCA/IGluZm8uY2FjaGVTa2lwQ291bnQgOiAwO1xuICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IFt0aGlzLnN0cmF0ZWd5XTtcbiAgICAgICAgaWYgKGluZm8gJiYgaW5mby50aW1lc3RhbXAgKyB0aGlzLnR0bCA+PSB1dGlsLm5vdygpKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzW2luZm8udHJhbnNwb3J0XTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoWyd3cycsICd3c3MnXS5pbmNsdWRlcyhpbmZvLnRyYW5zcG9ydCkgfHwgY2FjaGVTa2lwQ291bnQgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGluZm8udHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZW5jeTogaW5mby5sYXRlbmN5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJhdGVnaWVzLnB1c2gobmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt0cmFuc3BvcnRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiBpbmZvLmxhdGVuY3kgKiAyICsgMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxGYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlU2tpcENvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgICAgIHZhciBydW5uZXIgPSBzdHJhdGVnaWVzXG4gICAgICAgICAgICAucG9wKClcbiAgICAgICAgICAgIC5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiBjYihlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ2llcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gc3RyYXRlZ2llcy5wb3AoKS5jb25uZWN0KG1pblByaW9yaXR5LCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUywgaGFuZHNoYWtlLnRyYW5zcG9ydC5uYW1lLCB1dGlsLm5vdygpIC0gc3RhcnRUaW1lc3RhbXAsIGNhY2hlU2tpcENvdW50KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYW5kc2hha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBtaW5Qcmlvcml0eSA9IHA7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpIHtcbiAgICByZXR1cm4gJ3B1c2hlclRyYW5zcG9ydCcgKyAodXNpbmdUTFMgPyAnVExTJyA6ICdOb25UTFMnKTtcbn1cbmZ1bmN0aW9uIGZldGNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpIHtcbiAgICB2YXIgc3RvcmFnZSA9IHJ1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQ2FjaGUgPSBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV07XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZENhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCB0cmFuc3BvcnQsIGxhdGVuY3ksIGNhY2hlU2tpcENvdW50KSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV0gPSBzYWZlSlNPTlN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB1dGlsLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IGxhdGVuY3ksXG4gICAgICAgICAgICAgICAgY2FjaGVTa2lwQ291bnQ6IGNhY2hlU2tpcENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gcnVudGltZS5nZXRMb2NhbFN0b3JhZ2UoKTtcbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZGVsYXllZF9zdHJhdGVneS50c1xuXG5jbGFzcyBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIHsgZGVsYXk6IG51bWJlciB9KSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyBkZWxheTogbnVtYmVyIH07XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5O1xuICAgICAgICB2YXIgcnVubmVyO1xuICAgICAgICB2YXIgdGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy5kZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2lmX3N0cmF0ZWd5LnRzXG5jbGFzcyBJZlN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXN0LCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICB0aGlzLnRydWVCcmFuY2ggPSB0cnVlQnJhbmNoO1xuICAgICAgICB0aGlzLmZhbHNlQnJhbmNoID0gZmFsc2VCcmFuY2g7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy50ZXN0KCkgPyB0aGlzLnRydWVCcmFuY2ggOiB0aGlzLmZhbHNlQnJhbmNoO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBicmFuY2ggPSB0aGlzLnRlc3QoKSA/IHRoaXMudHJ1ZUJyYW5jaCA6IHRoaXMuZmFsc2VCcmFuY2g7XG4gICAgICAgIHJldHVybiBicmFuY2guY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2ZpcnN0X2Nvbm5lY3RlZF9zdHJhdGVneS50c1xuY2xhc3MgRmlyc3RDb25uZWN0ZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJ1bm5lciA9IHRoaXMuc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBoYW5kc2hha2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kZWZhdWx0X3N0cmF0ZWd5LnRzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHN0cmF0ZWd5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbn1cbnZhciBnZXREZWZhdWx0U3RyYXRlZ3kgPSBmdW5jdGlvbiAoY29uZmlnLCBiYXNlT3B0aW9ucywgZGVmaW5lVHJhbnNwb3J0KSB7XG4gICAgdmFyIGRlZmluZWRUcmFuc3BvcnRzID0ge307XG4gICAgZnVuY3Rpb24gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3kobmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydChjb25maWcsIG5hbWUsIHR5cGUsIHByaW9yaXR5LCBvcHRpb25zLCBtYW5hZ2VyKTtcbiAgICAgICAgZGVmaW5lZFRyYW5zcG9ydHNbbmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIHZhciB3c19vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMsIHtcbiAgICAgICAgaG9zdE5vblRMUzogY29uZmlnLndzSG9zdCArICc6JyArIGNvbmZpZy53c1BvcnQsXG4gICAgICAgIGhvc3RUTFM6IGNvbmZpZy53c0hvc3QgKyAnOicgKyBjb25maWcud3NzUG9ydCxcbiAgICAgICAgaHR0cFBhdGg6IGNvbmZpZy53c1BhdGhcbiAgICB9KTtcbiAgICB2YXIgd3NzX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB3c19vcHRpb25zLCB7XG4gICAgICAgIHVzZVRMUzogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBzb2NranNfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VPcHRpb25zLCB7XG4gICAgICAgIGhvc3ROb25UTFM6IGNvbmZpZy5odHRwSG9zdCArICc6JyArIGNvbmZpZy5odHRwUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBzUG9ydCxcbiAgICAgICAgaHR0cFBhdGg6IGNvbmZpZy5odHRwUGF0aFxuICAgIH0pO1xuICAgIHZhciB0aW1lb3V0cyA9IHtcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgdGltZW91dDogMTUwMDAsXG4gICAgICAgIHRpbWVvdXRMaW1pdDogNjAwMDBcbiAgICB9O1xuICAgIHZhciB3c19tYW5hZ2VyID0gbmV3IHRyYW5zcG9ydF9tYW5hZ2VyX1RyYW5zcG9ydE1hbmFnZXIoe1xuICAgICAgICBtaW5QaW5nRGVsYXk6IDEwMDAwLFxuICAgICAgICBtYXhQaW5nRGVsYXk6IGNvbmZpZy5hY3Rpdml0eVRpbWVvdXRcbiAgICB9KTtcbiAgICB2YXIgc3RyZWFtaW5nX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcih7XG4gICAgICAgIGxpdmVzOiAyLFxuICAgICAgICBtaW5QaW5nRGVsYXk6IDEwMDAwLFxuICAgICAgICBtYXhQaW5nRGVsYXk6IGNvbmZpZy5hY3Rpdml0eVRpbWVvdXRcbiAgICB9KTtcbiAgICB2YXIgd3NfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3dzJywgJ3dzJywgMywgd3Nfb3B0aW9ucywgd3NfbWFuYWdlcik7XG4gICAgdmFyIHdzc190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnd3NzJywgJ3dzJywgMywgd3NzX29wdGlvbnMsIHdzX21hbmFnZXIpO1xuICAgIHZhciBzb2NranNfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3NvY2tqcycsICdzb2NranMnLCAxLCBzb2NranNfb3B0aW9ucyk7XG4gICAgdmFyIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hocl9zdHJlYW1pbmcnLCAneGhyX3N0cmVhbWluZycsIDEsIHNvY2tqc19vcHRpb25zLCBzdHJlYW1pbmdfbWFuYWdlcik7XG4gICAgdmFyIHhkcl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hkcl9zdHJlYW1pbmcnLCAneGRyX3N0cmVhbWluZycsIDEsIHNvY2tqc19vcHRpb25zLCBzdHJlYW1pbmdfbWFuYWdlcik7XG4gICAgdmFyIHhocl9wb2xsaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4aHJfcG9sbGluZycsICd4aHJfcG9sbGluZycsIDEsIHNvY2tqc19vcHRpb25zKTtcbiAgICB2YXIgeGRyX3BvbGxpbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hkcl9wb2xsaW5nJywgJ3hkcl9wb2xsaW5nJywgMSwgc29ja2pzX29wdGlvbnMpO1xuICAgIHZhciB3c19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHdzc19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBzb2NranNfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbc29ja2pzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgc3RyZWFtaW5nX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW1xuICAgICAgICBuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneSh4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydCksIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0LCB4ZHJfc3RyZWFtaW5nX3RyYW5zcG9ydClcbiAgICBdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHBvbGxpbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbXG4gICAgICAgIG5ldyBJZlN0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHhocl9wb2xsaW5nX3RyYW5zcG9ydCksIHhocl9wb2xsaW5nX3RyYW5zcG9ydCwgeGRyX3BvbGxpbmdfdHJhbnNwb3J0KVxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgaHR0cF9sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFtcbiAgICAgICAgbmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyZWFtaW5nX2xvb3ApLCBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHN0cmVhbWluZ19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KHBvbGxpbmdfbG9vcCwgeyBkZWxheTogNDAwMCB9KVxuICAgICAgICBdKSwgcG9sbGluZ19sb29wKVxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgaHR0cF9mYWxsYmFja19sb29wID0gbmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koaHR0cF9sb29wKSwgaHR0cF9sb29wLCBzb2NranNfbG9vcCk7XG4gICAgdmFyIHdzU3RyYXRlZ3k7XG4gICAgaWYgKGJhc2VPcHRpb25zLnVzZVRMUykge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShbXG4gICAgICAgICAgICB3c19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KGh0dHBfZmFsbGJhY2tfbG9vcCwgeyBkZWxheTogMjAwMCB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzU3RyYXRlZ3kgPSBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHdzX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kod3NzX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSksXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3koaHR0cF9mYWxsYmFja19sb29wLCB7IGRlbGF5OiA1MDAwIH0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHdlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3lfV2ViU29ja2V0UHJpb3JpdGl6ZWRDYWNoZWRTdHJhdGVneShuZXcgRmlyc3RDb25uZWN0ZWRTdHJhdGVneShuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneSh3c190cmFuc3BvcnQpLCB3c1N0cmF0ZWd5LCBodHRwX2ZhbGxiYWNrX2xvb3ApKSwgZGVmaW5lZFRyYW5zcG9ydHMsIHtcbiAgICAgICAgdHRsOiAxODAwMDAwLFxuICAgICAgICB0aW1lbGluZTogYmFzZU9wdGlvbnMudGltZWxpbmUsXG4gICAgICAgIHVzZVRMUzogYmFzZU9wdGlvbnMudXNlVExTXG4gICAgfSk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdF9zdHJhdGVneSA9IChnZXREZWZhdWx0U3RyYXRlZ3kpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvdHJhbnNwb3J0cy90cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplci50c1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudGltZWxpbmUuaW5mbyhzZWxmLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHtcbiAgICAgICAgdHJhbnNwb3J0OiBzZWxmLm5hbWUgKyAoc2VsZi5vcHRpb25zLnVzZVRMUyA/ICdzJyA6ICcnKVxuICAgIH0pKTtcbiAgICBpZiAoc2VsZi5ob29rcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5ob29rcy5maWxlKSB7XG4gICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemluZycpO1xuICAgICAgICBEZXBlbmRlbmNpZXMubG9hZChzZWxmLmhvb2tzLmZpbGUsIHsgdXNlVExTOiBzZWxmLm9wdGlvbnMudXNlVExTIH0sIGZ1bmN0aW9uIChlcnJvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmhvb2tzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgIH1cbn0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvaHR0cC9odHRwX3hkb21haW5fcmVxdWVzdC50c1xuXG52YXIgaHR0cF94ZG9tYWluX3JlcXVlc3RfaG9va3MgPSB7XG4gICAgZ2V0UmVxdWVzdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgeGRyID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgbmV3IFJlcXVlc3RUaW1lZE91dCgpKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4ZHIucmVzcG9uc2VUZXh0ICYmIHhkci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoeGRyLnJlc3BvbnNlVGV4dCAmJiB4ZHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuaygyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgMjAwKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geGRyO1xuICAgIH0sXG4gICAgYWJvcnRSZXF1ZXN0OiBmdW5jdGlvbiAoeGRyKSB7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSB4ZHIub25lcnJvciA9IHhkci5vbnByb2dyZXNzID0geGRyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHhkci5hYm9ydCgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hkb21haW5fcmVxdWVzdCA9IChodHRwX3hkb21haW5fcmVxdWVzdF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3JlcXVlc3QudHNcblxuXG5jb25zdCBNQVhfQlVGRkVSX0xFTkdUSCA9IDI1NiAqIDEwMjQ7XG5jbGFzcyBodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCBtZXRob2QsIHVybCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG4gICAgc3RhcnQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy54aHIgPSB0aGlzLmhvb2tzLmdldFJlcXVlc3QodGhpcyk7XG4gICAgICAgIHRoaXMudW5sb2FkZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bnRpbWUuYWRkVW5sb2FkTGlzdGVuZXIodGhpcy51bmxvYWRlcik7XG4gICAgICAgIHRoaXMueGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChwYXlsb2FkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnVubG9hZGVyKSB7XG4gICAgICAgICAgICBydW50aW1lLnJlbW92ZVVubG9hZExpc3RlbmVyKHRoaXMudW5sb2FkZXIpO1xuICAgICAgICAgICAgdGhpcy51bmxvYWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueGhyKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2tzLmFib3J0UmVxdWVzdCh0aGlzLnhocik7XG4gICAgICAgICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaHVuayhzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IHRoaXMuYWR2YW5jZUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2h1bmsnLCB7IHN0YXR1czogc3RhdHVzLCBkYXRhOiBjaHVuayB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQnVmZmVyVG9vTG9uZyhkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdidWZmZXJfdG9vX2xvbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZHZhbmNlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB2YXIgdW5yZWFkRGF0YSA9IGJ1ZmZlci5zbGljZSh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGVuZE9mTGluZVBvc2l0aW9uID0gdW5yZWFkRGF0YS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgaWYgKGVuZE9mTGluZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBlbmRPZkxpbmVQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICByZXR1cm4gdW5yZWFkRGF0YS5zbGljZSgwLCBlbmRPZkxpbmVQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0J1ZmZlclRvb0xvbmcoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlci5sZW5ndGggPiBNQVhfQlVGRkVSX0xFTkdUSDtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9zdGF0ZS50c1xudmFyIFN0YXRlO1xuKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgIFN0YXRlW1N0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDBdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUEVOXCJdID0gMV0gPSBcIk9QRU5cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNMT1NFRFwiXSA9IDNdID0gXCJDTE9TRURcIjtcbn0pKFN0YXRlIHx8IChTdGF0ZSA9IHt9KSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdGF0ZSA9IChTdGF0ZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3NvY2tldC50c1xuXG5cblxudmFyIGF1dG9JbmNyZW1lbnQgPSAxO1xuY2xhc3MgaHR0cF9zb2NrZXRfSFRUUFNvY2tldCB7XG4gICAgY29uc3RydWN0b3IoaG9va3MsIHVybCkge1xuICAgICAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHJhbmRvbU51bWJlcigxMDAwKSArICcvJyArIHJhbmRvbVN0cmluZyg4KTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGdldExvY2F0aW9uKHVybCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xuICAgIH1cbiAgICBzZW5kKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJhdyhKU09OLnN0cmluZ2lmeShbcGF5bG9hZF0pKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgdGhpcy5ob29rcy5zZW5kSGVhcnRiZWF0KHRoaXMpO1xuICAgIH1cbiAgICBjbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGNvZGUsIHJlYXNvbiwgdHJ1ZSk7XG4gICAgfVxuICAgIHNlbmRSYXcocGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUuY3JlYXRlU29ja2V0UmVxdWVzdCgnUE9TVCcsIGdldFVuaXF1ZVVSTChnZXRTZW5kVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKS5zdGFydChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVN0cmVhbSgpO1xuICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICB9XG4gICAgb25DbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuQ0xPU0VEO1xuICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2Uoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgd2FzQ2xlYW46IHdhc0NsZWFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNodW5rKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuay5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4pIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXlsb2FkO1xuICAgICAgICB2YXIgdHlwZSA9IGNodW5rLmRhdGEuc2xpY2UoMCwgMSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAne30nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXlsb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdudWxsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rcy5vbkhlYXJ0YmVhdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uT3BlbihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLmJhc2UgPSByZXBsYWNlSG9zdCh0aGlzLmxvY2F0aW9uLmJhc2UsIG9wdGlvbnMuaG9zdG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuT1BFTjtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMub25vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4gJiYgdGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKHsgZGF0YTogZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25BY3Rpdml0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMub25hY3Rpdml0eSkge1xuICAgICAgICAgICAgdGhpcy5vbmFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5TdHJlYW0oKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gcnVudGltZS5jcmVhdGVTb2NrZXRSZXF1ZXN0KCdQT1NUJywgZ2V0VW5pcXVlVVJMKHRoaXMuaG9va3MuZ2V0UmVjZWl2ZVVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2NodW5rJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2ZpbmlzaGVkJywgc3RhdHVzID0+IHtcbiAgICAgICAgICAgIHRoaXMuaG9va3Mub25GaW5pc2hlZCh0aGlzLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnYnVmZmVyX3Rvb19sb25nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ0NvdWxkIG5vdCBzdGFydCBzdHJlYW1pbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZVN0cmVhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS51bmJpbmRfYWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb24odXJsKSB7XG4gICAgdmFyIHBhcnRzID0gLyhbXlxcP10qKVxcLyooXFw/Py4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IHBhcnRzWzFdLFxuICAgICAgICBxdWVyeVN0cmluZzogcGFydHNbMl1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VuZFVSTCh1cmwsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc2VuZCc7XG59XG5mdW5jdGlvbiBnZXRVbmlxdWVVUkwodXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgIHJldHVybiB1cmwgKyBzZXBhcmF0b3IgKyAndD0nICsgK25ldyBEYXRlKCkgKyAnJm49JyArIGF1dG9JbmNyZW1lbnQrKztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VIb3N0KHVybCwgaG9zdG5hbWUpIHtcbiAgICB2YXIgdXJsUGFydHMgPSAvKGh0dHBzPzpcXC9cXC8pKFteXFwvOl0rKSgoXFwvfDopPy4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB1cmxQYXJ0c1sxXSArIGhvc3RuYW1lICsgdXJsUGFydHNbM107XG59XG5mdW5jdGlvbiByYW5kb21OdW1iZXIobWF4KSB7XG4gICAgcmV0dXJuIHJ1bnRpbWUucmFuZG9tSW50KG1heCk7XG59XG5mdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmFuZG9tTnVtYmVyKDMyKS50b1N0cmluZygzMikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9zb2NrZXQgPSAoaHR0cF9zb2NrZXRfSFRUUFNvY2tldCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3N0cmVhbWluZ19zb2NrZXQudHNcbnZhciBodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MgPSB7XG4gICAgZ2V0UmVjZWl2ZVVSTDogZnVuY3Rpb24gKHVybCwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc3RyZWFtaW5nJyArIHVybC5xdWVyeVN0cmluZztcbiAgICB9LFxuICAgIG9uSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgc2VuZEhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIG9uRmluaXNoZWQ6IGZ1bmN0aW9uIChzb2NrZXQsIHN0YXR1cykge1xuICAgICAgICBzb2NrZXQub25DbG9zZSgxMDA2LCAnQ29ubmVjdGlvbiBpbnRlcnJ1cHRlZCAoJyArIHN0YXR1cyArICcpJywgZmFsc2UpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3N0cmVhbWluZ19zb2NrZXQgPSAoaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfcG9sbGluZ19zb2NrZXQudHNcbnZhciBodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzID0ge1xuICAgIGdldFJlY2VpdmVVUkw6IGZ1bmN0aW9uICh1cmwsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyJyArIHVybC5xdWVyeVN0cmluZztcbiAgICB9LFxuICAgIG9uSGVhcnRiZWF0OiBmdW5jdGlvbiAoKSB7XG4gICAgfSxcbiAgICBzZW5kSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgb25GaW5pc2hlZDogZnVuY3Rpb24gKHNvY2tldCwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0LnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc29ja2V0Lm9uQ2xvc2UoMTAwNiwgJ0Nvbm5lY3Rpb24gaW50ZXJydXB0ZWQgKCcgKyBzdGF0dXMgKyAnKScsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3BvbGxpbmdfc29ja2V0ID0gKGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cF94aHJfcmVxdWVzdC50c1xuXG52YXIgaHR0cF94aHJfcmVxdWVzdF9ob29rcyA9IHtcbiAgICBnZXRSZXF1ZXN0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHJ1bnRpbWUuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZVRleHQgJiYgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuayh4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuICAgIGFib3J0UmVxdWVzdDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfeGhyX3JlcXVlc3QgPSAoaHR0cF94aHJfcmVxdWVzdF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvaHR0cC9odHRwLnRzXG5cblxuXG5cblxudmFyIEhUVFAgPSB7XG4gICAgY3JlYXRlU3RyZWFtaW5nU29ja2V0KHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb2NrZXQoaHR0cF9zdHJlYW1pbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUG9sbGluZ1NvY2tldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ja2V0KGh0dHBfcG9sbGluZ19zb2NrZXQsIHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVTb2NrZXQoaG9va3MsIHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGh0dHBfc29ja2V0KGhvb2tzLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlWEhSKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3QoaHR0cF94aHJfcmVxdWVzdCwgbWV0aG9kLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUmVxdWVzdChob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QoaG9va3MsIG1ldGhvZCwgdXJsKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9odHRwID0gKEhUVFApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvaHR0cC9odHRwLnRzXG5cblxuaHR0cF9odHRwLmNyZWF0ZVhEUiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3QoaHR0cF94ZG9tYWluX3JlcXVlc3QsIG1ldGhvZCwgdXJsKTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB3ZWJfaHR0cF9odHRwID0gKGh0dHBfaHR0cCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9ydW50aW1lLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgUnVudGltZSA9IHtcbiAgICBuZXh0QXV0aENhbGxiYWNrSUQ6IDEsXG4gICAgYXV0aF9jYWxsYmFja3M6IHt9LFxuICAgIFNjcmlwdFJlY2VpdmVyczogU2NyaXB0UmVjZWl2ZXJzLFxuICAgIERlcGVuZGVuY2llc1JlY2VpdmVyczogRGVwZW5kZW5jaWVzUmVjZWl2ZXJzLFxuICAgIGdldERlZmF1bHRTdHJhdGVneTogZGVmYXVsdF9zdHJhdGVneSxcbiAgICBUcmFuc3BvcnRzOiB0cmFuc3BvcnRzX3RyYW5zcG9ydHMsXG4gICAgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyOiB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplcixcbiAgICBIVFRQRmFjdG9yeTogd2ViX2h0dHBfaHR0cCxcbiAgICBUaW1lbGluZVRyYW5zcG9ydDoganNvbnBfdGltZWxpbmUsXG4gICAgZ2V0WEhSQVBJKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuICAgIH0sXG4gICAgZ2V0V2ViU29ja2V0QVBJKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0O1xuICAgIH0sXG4gICAgc2V0dXAoUHVzaGVyQ2xhc3MpIHtcbiAgICAgICAgd2luZG93LlB1c2hlciA9IFB1c2hlckNsYXNzO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZU9uRG9jdW1lbnRCb2R5ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRvY3VtZW50Qm9keShQdXNoZXJDbGFzcy5yZWFkeSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghd2luZG93LkpTT04pIHtcbiAgICAgICAgICAgIERlcGVuZGVuY2llcy5sb2FkKCdqc29uMicsIHt9LCBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZU9uRG9jdW1lbnRCb2R5KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSxcbiAgICBnZXRQcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnQoKS5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICB9LFxuICAgIGdldEF1dGhvcml6ZXJzKCkge1xuICAgICAgICByZXR1cm4geyBhamF4OiB4aHJfYXV0aCwganNvbnA6IGpzb25wX2F1dGggfTtcbiAgICB9LFxuICAgIG9uRG9jdW1lbnRCb2R5KGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRvY3VtZW50Qm9keShjYWxsYmFjayk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlSlNPTlBSZXF1ZXN0KHVybCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IGpzb25wX3JlcXVlc3RfSlNPTlBSZXF1ZXN0KHVybCwgZGF0YSk7XG4gICAgfSxcbiAgICBjcmVhdGVTY3JpcHRSZXF1ZXN0KHNyYykge1xuICAgICAgICByZXR1cm4gbmV3IFNjcmlwdFJlcXVlc3Qoc3JjKTtcbiAgICB9LFxuICAgIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVYSFIoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFhIUkFQSSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTWljcm9zb2Z0WEhSKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVhNTEh0dHBSZXF1ZXN0KCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFhIUkFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgfSxcbiAgICBjcmVhdGVNaWNyb3NvZnRYSFIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9LFxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXRfaW5mb19OZXR3b3JrO1xuICAgIH0sXG4gICAgY3JlYXRlV2ViU29ja2V0KHVybCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFdlYlNvY2tldEFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHVybCk7XG4gICAgfSxcbiAgICBjcmVhdGVTb2NrZXRSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWEhSU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkhUVFBGYWN0b3J5LmNyZWF0ZVhIUihtZXRob2QsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1hEUlN1cHBvcnRlZCh1cmwuaW5kZXhPZignaHR0cHM6JykgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5IVFRQRmFjdG9yeS5jcmVhdGVYRFIobWV0aG9kLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0Nyb3NzLW9yaWdpbiBIVFRQIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNYSFJTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHJldHVybiAoQm9vbGVhbihDb25zdHJ1Y3RvcikgJiYgbmV3IENvbnN0cnVjdG9yKCkud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaXNYRFJTdXBwb3J0ZWQodXNlVExTKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHVzZVRMUyA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgICAgICAgdmFyIGRvY3VtZW50UHJvdG9jb2wgPSB0aGlzLmdldFByb3RvY29sKCk7XG4gICAgICAgIHJldHVybiAoQm9vbGVhbih3aW5kb3dbJ1hEb21haW5SZXF1ZXN0J10pICYmIGRvY3VtZW50UHJvdG9jb2wgPT09IHByb3RvY29sKTtcbiAgICB9LFxuICAgIGFkZFVubG9hZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlVW5sb2FkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5kZXRhY2hFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuZGV0YWNoRXZlbnQoJ29udW5sb2FkJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21JbnQobWF4KSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Wydtc0NyeXB0byddO1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbSAvIE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tKCkgKiBtYXgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBydW50aW1lID0gKFJ1bnRpbWUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL2xldmVsLnRzXG52YXIgVGltZWxpbmVMZXZlbDtcbihmdW5jdGlvbiAoVGltZWxpbmVMZXZlbCkge1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiSU5GT1wiXSA9IDZdID0gXCJJTkZPXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiREVCVUdcIl0gPSA3XSA9IFwiREVCVUdcIjtcbn0pKFRpbWVsaW5lTGV2ZWwgfHwgKFRpbWVsaW5lTGV2ZWwgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfbGV2ZWwgPSAoVGltZWxpbmVMZXZlbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmUudHNcblxuXG5cbmNsYXNzIHRpbWVsaW5lX1RpbWVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VudCA9IDA7XG4gICAgICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIH1cbiAgICBsb2cobGV2ZWwsIGV2ZW50KSB7XG4gICAgICAgIGlmIChsZXZlbCA8PSB0aGlzLm9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXh0ZW5kKHt9LCBldmVudCwgeyB0aW1lc3RhbXA6IHV0aWwubm93KCkgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdCAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVycm9yKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkVSUk9SLCBldmVudCk7XG4gICAgfVxuICAgIGluZm8oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuSU5GTywgZXZlbnQpO1xuICAgIH1cbiAgICBkZWJ1ZyhldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5ERUJVRywgZXZlbnQpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBzZW5kKHNlbmRmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgYnVuZGxlOiB0aGlzLnNlbnQgKyAxLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGxpYjogJ2pzJyxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5vcHRpb25zLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogdGhpcy5vcHRpb25zLmZlYXR1cmVzLFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMuZXZlbnRzXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICBzZW5kZm4oZGF0YSwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlVW5pcXVlSUQoKSB7XG4gICAgICAgIHRoaXMudW5pcXVlSUQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pcXVlSUQ7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvdHJhbnNwb3J0X3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJpb3JpdHksIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKHtcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy5vcHRpb25zLnVzZVRMU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVW5zdXBwb3J0ZWRTdHJhdGVneSgpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcmlvcml0eSA8IG1pblByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbEF0dGVtcHQobmV3IFRyYW5zcG9ydFByaW9yaXR5VG9vTG93KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydC5jcmVhdGVDb25uZWN0aW9uKHRoaXMubmFtZSwgdGhpcy5wcmlvcml0eSwgdGhpcy5vcHRpb25zLmtleSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIGhhbmRzaGFrZSA9IG51bGw7XG4gICAgICAgIHZhciBvbkluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kc2hha2UgPSBmYWN0b3J5LmNyZWF0ZUhhbmRzaGFrZSh0cmFuc3BvcnQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkVHJhbnNwb3J0O1xuICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zcG9ydCA9IHNhZmVKU09OU3RyaW5naWZ5KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgVHJhbnNwb3J0Q2xvc2VkKHNlcmlhbGl6ZWRUcmFuc3BvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICB0cmFuc3BvcnQuaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJpb3JpdHkgPCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZmFpbEF0dGVtcHQoZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAoKSB7IH1cbiAgICB9O1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc3RyYXRlZ3lfYnVpbGRlci50c1xuXG5cblxuXG5cbmNvbnN0IHsgVHJhbnNwb3J0czogc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzIH0gPSBydW50aW1lO1xudmFyIHN0cmF0ZWd5X2J1aWxkZXJfZGVmaW5lVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgICB2YXIgdHJhbnNwb3J0Q2xhc3MgPSBzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHNbdHlwZV07XG4gICAgaWYgKCF0cmFuc3BvcnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUcmFuc3BvcnQodHlwZSk7XG4gICAgfVxuICAgIHZhciBlbmFibGVkID0gKCFjb25maWcuZW5hYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cywgbmFtZSkgIT09IC0xKSAmJlxuICAgICAgICAoIWNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgICAgIGFycmF5SW5kZXhPZihjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSA9PT0gLTEpO1xuICAgIHZhciB0cmFuc3BvcnQ7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBpZ25vcmVOdWxsT3JpZ2luOiBjb25maWcuaWdub3JlTnVsbE9yaWdpbiB9LCBvcHRpb25zKTtcbiAgICAgICAgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneShuYW1lLCBwcmlvcml0eSwgbWFuYWdlciA/IG1hbmFnZXIuZ2V0QXNzaXN0YW50KHRyYW5zcG9ydENsYXNzKSA6IHRyYW5zcG9ydENsYXNzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IHN0cmF0ZWd5X2J1aWxkZXJfVW5zdXBwb3J0ZWRTdHJhdGVneTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5ID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvb3B0aW9ucy50c1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgYW4gb3B0aW9ucyBvYmplY3QnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbHVzdGVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ09wdGlvbnMgb2JqZWN0IG11c3QgcHJvdmlkZSBhIGNsdXN0ZXInO1xuICAgIH1cbiAgICBpZiAoJ2Rpc2FibGVTdGF0cycgaW4gb3B0aW9ucykge1xuICAgICAgICBsb2dnZXIud2FybignVGhlIGRpc2FibGVTdGF0cyBvcHRpb24gaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBlbmFibGVTdGF0cycpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL3VzZXJfYXV0aGVudGljYXRvci50c1xuXG5cbmNvbnN0IGNvbXBvc2VDaGFubmVsUXVlcnkgPSAocGFyYW1zLCBhdXRoT3B0aW9ucykgPT4ge1xuICAgIHZhciBxdWVyeSA9ICdzb2NrZXRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc29ja2V0SWQpO1xuICAgIGZvciAodmFyIGtleSBpbiBhdXRoT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGF1dGhPcHRpb25zLnBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGR5bmFtaWNQYXJhbXMgPSBhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlcigpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZHluYW1pY1BhcmFtcykge1xuICAgICAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChkeW5hbWljUGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn07XG5jb25zdCBVc2VyQXV0aGVudGljYXRvciA9IChhdXRoT3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2YgcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGAnJHthdXRoT3B0aW9ucy50cmFuc3BvcnR9JyBpcyBub3QgYSByZWNvZ25pemVkIGF1dGggdHJhbnNwb3J0YDtcbiAgICB9XG4gICAgcmV0dXJuIChwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29tcG9zZUNoYW5uZWxRdWVyeShwYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0ocnVudGltZSwgcXVlcnksIGF1dGhPcHRpb25zLCBBdXRoUmVxdWVzdFR5cGUuVXNlckF1dGhlbnRpY2F0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1c2VyX2F1dGhlbnRpY2F0b3IgPSAoVXNlckF1dGhlbnRpY2F0b3IpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvY2hhbm5lbF9hdXRob3JpemVyLnRzXG5cblxuY29uc3QgY2hhbm5lbF9hdXRob3JpemVyX2NvbXBvc2VDaGFubmVsUXVlcnkgPSAocGFyYW1zLCBhdXRoT3B0aW9ucykgPT4ge1xuICAgIHZhciBxdWVyeSA9ICdzb2NrZXRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc29ja2V0SWQpO1xuICAgIHF1ZXJ5ICs9ICcmY2hhbm5lbF9uYW1lPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNoYW5uZWxOYW1lKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXV0aE9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChhdXRoT3B0aW9ucy5wYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgIGxldCBkeW5hbWljUGFyYW1zID0gYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGR5bmFtaWNQYXJhbXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoZHluYW1pY1BhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59O1xuY29uc3QgQ2hhbm5lbEF1dGhvcml6ZXIgPSAoYXV0aE9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIHJ1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBgJyR7YXV0aE9wdGlvbnMudHJhbnNwb3J0fScgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydGA7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNoYW5uZWxfYXV0aG9yaXplcl9jb21wb3NlQ2hhbm5lbFF1ZXJ5KHBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShydW50aW1lLCBxdWVyeSwgYXV0aE9wdGlvbnMsIEF1dGhSZXF1ZXN0VHlwZS5DaGFubmVsQXV0aG9yaXphdGlvbiwgY2FsbGJhY2spO1xuICAgIH07XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2hhbm5lbF9hdXRob3JpemVyID0gKENoYW5uZWxBdXRob3JpemVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL2RlcHJlY2F0ZWRfY2hhbm5lbF9hdXRob3JpemVyLnRzXG5jb25zdCBDaGFubmVsQXV0aG9yaXplclByb3h5ID0gKHB1c2hlciwgYXV0aE9wdGlvbnMsIGNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yKSA9PiB7XG4gICAgY29uc3QgZGVwcmVjYXRlZEF1dGhvcml6ZXJPcHRpb25zID0ge1xuICAgICAgICBhdXRoVHJhbnNwb3J0OiBhdXRoT3B0aW9ucy50cmFuc3BvcnQsXG4gICAgICAgIGF1dGhFbmRwb2ludDogYXV0aE9wdGlvbnMuZW5kcG9pbnQsXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIHBhcmFtczogYXV0aE9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgaGVhZGVyczogYXV0aE9wdGlvbnMuaGVhZGVyc1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHB1c2hlci5jaGFubmVsKHBhcmFtcy5jaGFubmVsTmFtZSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxBdXRob3JpemVyID0gY2hhbm5lbEF1dGhvcml6ZXJHZW5lcmF0b3IoY2hhbm5lbCwgZGVwcmVjYXRlZEF1dGhvcml6ZXJPcHRpb25zKTtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6ZXIuYXV0aG9yaXplKHBhcmFtcy5zb2NrZXRJZCwgY2FsbGJhY2spO1xuICAgIH07XG59O1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NvbmZpZy50c1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbmZpZyhvcHRzLCBwdXNoZXIpIHtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG9wdHMuYWN0aXZpdHlUaW1lb3V0IHx8IGRlZmF1bHRzLmFjdGl2aXR5VGltZW91dCxcbiAgICAgICAgY2x1c3Rlcjogb3B0cy5jbHVzdGVyLFxuICAgICAgICBodHRwUGF0aDogb3B0cy5odHRwUGF0aCB8fCBkZWZhdWx0cy5odHRwUGF0aCxcbiAgICAgICAgaHR0cFBvcnQ6IG9wdHMuaHR0cFBvcnQgfHwgZGVmYXVsdHMuaHR0cFBvcnQsXG4gICAgICAgIGh0dHBzUG9ydDogb3B0cy5odHRwc1BvcnQgfHwgZGVmYXVsdHMuaHR0cHNQb3J0LFxuICAgICAgICBwb25nVGltZW91dDogb3B0cy5wb25nVGltZW91dCB8fCBkZWZhdWx0cy5wb25nVGltZW91dCxcbiAgICAgICAgc3RhdHNIb3N0OiBvcHRzLnN0YXRzSG9zdCB8fCBkZWZhdWx0cy5zdGF0c19ob3N0LFxuICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IG9wdHMudW5hdmFpbGFibGVUaW1lb3V0IHx8IGRlZmF1bHRzLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgd3NQYXRoOiBvcHRzLndzUGF0aCB8fCBkZWZhdWx0cy53c1BhdGgsXG4gICAgICAgIHdzUG9ydDogb3B0cy53c1BvcnQgfHwgZGVmYXVsdHMud3NQb3J0LFxuICAgICAgICB3c3NQb3J0OiBvcHRzLndzc1BvcnQgfHwgZGVmYXVsdHMud3NzUG9ydCxcbiAgICAgICAgZW5hYmxlU3RhdHM6IGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpLFxuICAgICAgICBodHRwSG9zdDogZ2V0SHR0cEhvc3Qob3B0cyksXG4gICAgICAgIHVzZVRMUzogc2hvdWxkVXNlVExTKG9wdHMpLFxuICAgICAgICB3c0hvc3Q6IGdldFdlYnNvY2tldEhvc3Qob3B0cyksXG4gICAgICAgIHVzZXJBdXRoZW50aWNhdG9yOiBidWlsZFVzZXJBdXRoZW50aWNhdG9yKG9wdHMpLFxuICAgICAgICBjaGFubmVsQXV0aG9yaXplcjogYnVpbGRDaGFubmVsQXV0aG9yaXplcihvcHRzLCBwdXNoZXIpXG4gICAgfTtcbiAgICBpZiAoJ2Rpc2FibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyA9IG9wdHMuZGlzYWJsZWRUcmFuc3BvcnRzO1xuICAgIGlmICgnZW5hYmxlZFRyYW5zcG9ydHMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyA9IG9wdHMuZW5hYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdpZ25vcmVOdWxsT3JpZ2luJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuaWdub3JlTnVsbE9yaWdpbiA9IG9wdHMuaWdub3JlTnVsbE9yaWdpbjtcbiAgICBpZiAoJ3RpbWVsaW5lUGFyYW1zJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcudGltZWxpbmVQYXJhbXMgPSBvcHRzLnRpbWVsaW5lUGFyYW1zO1xuICAgIGlmICgnbmFjbCcgaW4gb3B0cykge1xuICAgICAgICBjb25maWcubmFjbCA9IG9wdHMubmFjbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGdldEh0dHBIb3N0KG9wdHMpIHtcbiAgICBpZiAob3B0cy5odHRwSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy5odHRwSG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2x1c3Rlcikge1xuICAgICAgICByZXR1cm4gYHNvY2tqcy0ke29wdHMuY2x1c3Rlcn0ucHVzaGVyLmNvbWA7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cy5odHRwSG9zdDtcbn1cbmZ1bmN0aW9uIGdldFdlYnNvY2tldEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLndzSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy53c0hvc3Q7XG4gICAgfVxuICAgIHJldHVybiBnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIob3B0cy5jbHVzdGVyKTtcbn1cbmZ1bmN0aW9uIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGB3cy0ke2NsdXN0ZXJ9LnB1c2hlci5jb21gO1xufVxuZnVuY3Rpb24gc2hvdWxkVXNlVExTKG9wdHMpIHtcbiAgICBpZiAocnVudGltZS5nZXRQcm90b2NvbCgpID09PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0cy5mb3JjZVRMUyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpIHtcbiAgICBpZiAoJ2VuYWJsZVN0YXRzJyBpbiBvcHRzKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmVuYWJsZVN0YXRzO1xuICAgIH1cbiAgICBpZiAoJ2Rpc2FibGVTdGF0cycgaW4gb3B0cykge1xuICAgICAgICByZXR1cm4gIW9wdHMuZGlzYWJsZVN0YXRzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBoYXNDdXN0b21IYW5kbGVyID0gKGF1dGgpID0+IHtcbiAgICByZXR1cm4gJ2N1c3RvbUhhbmRsZXInIGluIGF1dGggJiYgYXV0aFsnY3VzdG9tSGFuZGxlciddICE9IG51bGw7XG59O1xuZnVuY3Rpb24gYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSB7XG4gICAgY29uc3QgdXNlckF1dGhlbnRpY2F0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy51c2VyQXV0aGVudGljYXRpb24pLCBvcHRzLnVzZXJBdXRoZW50aWNhdGlvbik7XG4gICAgaWYgKGhhc0N1c3RvbUhhbmRsZXIodXNlckF1dGhlbnRpY2F0aW9uKSkge1xuICAgICAgICByZXR1cm4gdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiB1c2VyX2F1dGhlbnRpY2F0b3IodXNlckF1dGhlbnRpY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNoYW5uZWxBdXRob3JpemF0aW9uO1xuICAgIGlmICgnY2hhbm5lbEF1dGhvcml6YXRpb24nIGluIG9wdHMpIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmNoYW5uZWxBdXRob3JpemF0aW9uKSwgb3B0cy5jaGFubmVsQXV0aG9yaXphdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogb3B0cy5hdXRoVHJhbnNwb3J0IHx8IGRlZmF1bHRzLmF1dGhUcmFuc3BvcnQsXG4gICAgICAgICAgICBlbmRwb2ludDogb3B0cy5hdXRoRW5kcG9pbnQgfHwgZGVmYXVsdHMuYXV0aEVuZHBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGlmICgnYXV0aCcgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKCdwYXJhbXMnIGluIG9wdHMuYXV0aClcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5wYXJhbXMgPSBvcHRzLmF1dGgucGFyYW1zO1xuICAgICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBvcHRzLmF1dGgpXG4gICAgICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24uaGVhZGVycyA9IG9wdHMuYXV0aC5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXV0aG9yaXplcicgaW4gb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXN0b21IYW5kbGVyOiBDaGFubmVsQXV0aG9yaXplclByb3h5KHB1c2hlciwgY2hhbm5lbEF1dGhvcml6YXRpb24sIG9wdHMuYXV0aG9yaXplcilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uO1xufVxuZnVuY3Rpb24gYnVpbGRDaGFubmVsQXV0aG9yaXplcihvcHRzLCBwdXNoZXIpIHtcbiAgICBjb25zdCBjaGFubmVsQXV0aG9yaXphdGlvbiA9IGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKTtcbiAgICBpZiAoaGFzQ3VzdG9tSGFuZGxlcihjaGFubmVsQXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsX2F1dGhvcml6ZXIoY2hhbm5lbEF1dGhvcml6YXRpb24pO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3dhdGNobGlzdC50c1xuXG5cbmNsYXNzIHdhdGNobGlzdF9XYXRjaGxpc3RGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNhbGxiYWNrcyBvbiB3YXRjaGxpc3QgZXZlbnRzIGZvciAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLmJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KHB1c2hlckV2ZW50KSB7XG4gICAgICAgIHB1c2hlckV2ZW50LmRhdGEuZXZlbnRzLmZvckVhY2god2F0Y2hsaXN0RXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHdhdGNobGlzdEV2ZW50Lm5hbWUsIHdhdGNobGlzdEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCkge1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCBwdXNoZXJFdmVudCA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHVzaGVyRXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOndhdGNobGlzdF9ldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mbGF0X3Byb21pc2UudHNcbmZ1bmN0aW9uIGZsYXRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmbGF0X3Byb21pc2UgPSAoZmxhdFByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3VzZXIudHNcblxuXG5cblxuXG5jbGFzcyB1c2VyX1VzZXJGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiB1c2VyIGZvciAnICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lnbmluRG9uZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQXV0aG9yaXplID0gKGVyciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgZHVyaW5nIHNpZ25pbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzaWduaW4nLCB7XG4gICAgICAgICAgICAgICAgYXV0aDogYXV0aERhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICB1c2VyX2RhdGE6IGF1dGhEYXRhLnVzZXJfZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ3N0YXRlX2NoYW5nZScsICh7IHByZXZpb3VzLCBjdXJyZW50IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV3U2lnbmluUHJvbWlzZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdGNobGlzdCA9IG5ldyB3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlKHB1c2hlcik7XG4gICAgICAgIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXI6c2lnbmluX3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5uYW1lID09PSBldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25pbigpO1xuICAgIH1cbiAgICBfc2lnbmluKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkXG4gICAgICAgIH0sIHRoaXMuX29uQXV0aG9yaXplKTtcbiAgICB9XG4gICAgX29uU2lnbmluU3VjY2VzcyhkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS51c2VyX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCBwYXJzaW5nIHVzZXIgZGF0YSBhZnRlciBzaWduaW46ICR7ZGF0YS51c2VyX2RhdGF9YCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnVzZXJfZGF0YS5pZCAhPT0gJ3N0cmluZycgfHwgdGhpcy51c2VyX2RhdGEuaWQgPT09ICcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYHVzZXJfZGF0YSBkb2Vzbid0IGNvbnRhaW4gYW4gaWQuIHVzZXJfZGF0YTogJHt0aGlzLnVzZXJfZGF0YX1gKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGFubmVscygpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IGVuc3VyZV9zdWJzY3JpYmVkID0gY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG5ldyBjaGFubmVsX0NoYW5uZWwoYCNzZXJ2ZXItdG8tdXNlci0ke3RoaXMudXNlcl9kYXRhLmlkfWAsIHRoaXMucHVzaGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmJpbmRfZ2xvYmFsKChldmVudE5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwIHx8XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW5zdXJlX3N1YnNjcmliZWQodGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsKTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduaW5Eb25lUHJvbWlzZSAmJiAhdGhpcy5zaWduaW5Eb25lUHJvbWlzZS5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3Q6IF8gfSA9IGZsYXRfcHJvbWlzZSgpO1xuICAgICAgICBwcm9taXNlLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2V0RG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKS5jYXRjaChzZXREb25lKTtcbiAgICAgICAgdGhpcy5zaWduaW5Eb25lUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIHB1c2hlcl9QdXNoZXIge1xuICAgIHN0YXRpYyByZWFkeSgpIHtcbiAgICAgICAgcHVzaGVyX1B1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzW2ldLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xpZW50RmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBydW50aW1lLlRyYW5zcG9ydHMud3MgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlzU3VwcG9ydGVkKHt9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhcHBfa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrQXBwS2V5KGFwcF9rZXkpO1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMua2V5ID0gYXBwX2tleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25maWcgPSBnZXRDb25maWcodGhpcy5vcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IGZhY3RvcnkuY3JlYXRlQ2hhbm5lbHMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlciA9IG5ldyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSUQgPSBydW50aW1lLnJhbmRvbUludCgxMDAwMDAwMDAwKTtcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IG5ldyB0aW1lbGluZV9UaW1lbGluZSh0aGlzLmtleSwgdGhpcy5zZXNzaW9uSUQsIHtcbiAgICAgICAgICAgIGNsdXN0ZXI6IHRoaXMuY29uZmlnLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogcHVzaGVyX1B1c2hlci5nZXRDbGllbnRGZWF0dXJlcygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLmNvbmZpZy50aW1lbGluZVBhcmFtcyB8fCB7fSxcbiAgICAgICAgICAgIGxpbWl0OiA1MCxcbiAgICAgICAgICAgIGxldmVsOiB0aW1lbGluZV9sZXZlbC5JTkZPLFxuICAgICAgICAgICAgdmVyc2lvbjogZGVmYXVsdHMuVkVSU0lPTlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVN0YXRzKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyID0gZmFjdG9yeS5jcmVhdGVUaW1lbGluZVNlbmRlcih0aGlzLnRpbWVsaW5lLCB7XG4gICAgICAgICAgICAgICAgaG9zdDogdGhpcy5jb25maWcuc3RhdHNIb3N0LFxuICAgICAgICAgICAgICAgIHBhdGg6ICcvdGltZWxpbmUvdjIvJyArIHJ1bnRpbWUuVGltZWxpbmVUcmFuc3BvcnQubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdldFN0cmF0ZWd5ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lLmdldERlZmF1bHRTdHJhdGVneSh0aGlzLmNvbmZpZywgb3B0aW9ucywgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBmYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKHRoaXMua2V5LCB7XG4gICAgICAgICAgICBnZXRTdHJhdGVneTogZ2V0U3RyYXRlZ3ksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5jb25maWcuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgcG9uZ1RpbWVvdXQ6IHRoaXMuY29uZmlnLnBvbmdUaW1lb3V0LFxuICAgICAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiB0aGlzLmNvbmZpZy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgICAgICB1c2VUTFM6IEJvb2xlYW4odGhpcy5jb25maWcudXNlVExTKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIuc2VuZCh0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgdmFyIGludGVybmFsID0gZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuZW1pdChldmVudC5ldmVudCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGluZycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBpbnN0YW5jZXM6IHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzLmxlbmd0aCB9KTtcbiAgICAgICAgdGhpcy51c2VyID0gbmV3IHVzZXJfVXNlckZhY2FkZSh0aGlzKTtcbiAgICAgICAgaWYgKHB1c2hlcl9QdXNoZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQ2x1c3RlcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYXBwS2V5LCBjbHVzdGVyIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmtleSA9IGFwcEtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IGNsdXN0ZXIgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZ2V0Q29uZmlnKHRoaXMub3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5zd2l0Y2hDbHVzdGVyKHRoaXMua2V5KTtcbiAgICB9XG4gICAgY2hhbm5lbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmZpbmQobmFtZSk7XG4gICAgfVxuICAgIGFsbENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscy5hbGwoKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy5jb25uZWN0aW9uLmlzVXNpbmdUTFMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTZW5kZXIgPSB0aGlzLnRpbWVsaW5lU2VuZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lciA9IG5ldyB0aW1lcnNfUGVyaW9kaWNUaW1lcig2MDAwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNlbmRlci5zZW5kKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfYWxsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2FsbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICB2YXIgY2hhbm5lbE5hbWU7XG4gICAgICAgIGZvciAoY2hhbm5lbE5hbWUgaW4gdGhpcy5jaGFubmVscy5jaGFubmVscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShjaGFubmVsX25hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmFkZChjaGFubmVsX25hbWUsIHRoaXMpO1xuICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsLnJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjaGFubmVsX25hbWUpO1xuICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuY2FuY2VsU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscy5yZW1vdmUoY2hhbm5lbF9uYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgIH1cbiAgICBzaG91bGRVc2VUTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy51c2VUTFM7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgdGhpcy51c2VyLnNpZ25pbigpO1xuICAgIH1cbn1cbnB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzID0gW107XG5wdXNoZXJfUHVzaGVyLmlzUmVhZHkgPSBmYWxzZTtcbnB1c2hlcl9QdXNoZXIubG9nVG9Db25zb2xlID0gZmFsc2U7XG5wdXNoZXJfUHVzaGVyLlJ1bnRpbWUgPSBydW50aW1lO1xucHVzaGVyX1B1c2hlci5TY3JpcHRSZWNlaXZlcnMgPSBydW50aW1lLlNjcmlwdFJlY2VpdmVycztcbnB1c2hlcl9QdXNoZXIuRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gcnVudGltZS5EZXBlbmRlbmNpZXNSZWNlaXZlcnM7XG5wdXNoZXJfUHVzaGVyLmF1dGhfY2FsbGJhY2tzID0gcnVudGltZS5hdXRoX2NhbGxiYWNrcztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfcHVzaGVyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAocHVzaGVyX1B1c2hlcik7XG5mdW5jdGlvbiBjaGVja0FwcEtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93ICdZb3UgbXVzdCBwYXNzIHlvdXIgYXBwIGtleSB3aGVuIHlvdSBpbnN0YW50aWF0ZSBQdXNoZXIuJztcbiAgICB9XG59XG5ydW50aW1lLnNldHVwKHB1c2hlcl9QdXNoZXIpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJiIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsIl9fIiwiY29uc3RydWN0b3IiLCJJTlZBTElEX0JZVEUiLCJDb2RlciIsIl9wYWRkaW5nQ2hhcmFjdGVyIiwiZW5jb2RlZExlbmd0aCIsImxlbmd0aCIsImVuY29kZSIsImRhdGEiLCJvdXQiLCJfZW5jb2RlQnl0ZSIsImxlZnQiLCJtYXhEZWNvZGVkTGVuZ3RoIiwiZGVjb2RlZExlbmd0aCIsIl9nZXRQYWRkaW5nTGVuZ3RoIiwiZGVjb2RlIiwiVWludDhBcnJheSIsInBhZGRpbmdMZW5ndGgiLCJvcCIsImhhdmVCYWQiLCJ2MCIsInYxIiwidjIiLCJ2MyIsIl9kZWNvZGVDaGFyIiwiY2hhckNvZGVBdCIsIkVycm9yIiwicmVzdWx0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RkQ29kZXIiLCJVUkxTYWZlQ29kZXIiLCJfc3VwZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInVybFNhZmVDb2RlciIsImVuY29kZVVSTFNhZmUiLCJkZWNvZGVVUkxTYWZlIiwiSU5WQUxJRF9VVEYxNiIsIklOVkFMSURfVVRGOCIsImFyciIsInBvcyIsImNoYXJzIiwibWluIiwibjEiLCJuMiIsIm4zIiwicHVzaCIsImpvaW4iLCJkZWZhdWx0IiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIlNjcmlwdFJlY2VpdmVyRmFjdG9yeSIsImNhbGxiYWNrIiwibGFzdElkIiwibnVtYmVyIiwiaWQiLCJwcmVmaXgiLCJjYWxsZWQiLCJjYWxsYmFja1dyYXBwZXIiLCJyZW1vdmUiLCJyZWNlaXZlciIsIlNjcmlwdFJlY2VpdmVycyIsIkRlZmF1bHRzIiwiVkVSU0lPTiIsIlBST1RPQ09MIiwid3NQb3J0Iiwid3NzUG9ydCIsIndzUGF0aCIsImh0dHBIb3N0IiwiaHR0cFBvcnQiLCJodHRwc1BvcnQiLCJodHRwUGF0aCIsInN0YXRzX2hvc3QiLCJhdXRoRW5kcG9pbnQiLCJhdXRoVHJhbnNwb3J0IiwiYWN0aXZpdHlUaW1lb3V0IiwicG9uZ1RpbWVvdXQiLCJ1bmF2YWlsYWJsZVRpbWVvdXQiLCJ1c2VyQXV0aGVudGljYXRpb24iLCJlbmRwb2ludCIsInRyYW5zcG9ydCIsImNoYW5uZWxBdXRob3JpemF0aW9uIiwiY2RuX2h0dHAiLCJjZG5faHR0cHMiLCJkZXBlbmRlbmN5X3N1ZmZpeCIsImRlZmF1bHRzIiwiZGVwZW5kZW5jeV9sb2FkZXJfRGVwZW5kZW5jeUxvYWRlciIsImxvYWQiLCJvcHRpb25zIiwic2VsZiIsImxvYWRpbmciLCJyZXF1ZXN0IiwicnVudGltZSIsImNyZWF0ZVNjcmlwdFJlcXVlc3QiLCJnZXRQYXRoIiwicmVjZWl2ZXJzIiwiZXJyb3IiLCJjYWxsYmFja3MiLCJzdWNjZXNzQ2FsbGJhY2siLCJ3YXNTdWNjZXNzZnVsIiwiY2xlYW51cCIsInNlbmQiLCJnZXRSb290IiwiY2RuIiwicHJvdG9jb2wiLCJnZXREb2N1bWVudCIsImxvY2F0aW9uIiwidXNlVExTIiwicmVwbGFjZSIsInZlcnNpb24iLCJzdWZmaXgiLCJEZXBlbmRlbmNpZXNSZWNlaXZlcnMiLCJEZXBlbmRlbmNpZXMiLCJ1cmxTdG9yZSIsImJhc2VVcmwiLCJ1cmxzIiwiYXV0aGVudGljYXRpb25FbmRwb2ludCIsInBhdGgiLCJhdXRob3JpemF0aW9uRW5kcG9pbnQiLCJqYXZhc2NyaXB0UXVpY2tTdGFydCIsInRyaWdnZXJpbmdDbGllbnRFdmVudHMiLCJlbmNyeXB0ZWRDaGFubmVsU3VwcG9ydCIsImZ1bGxVcmwiLCJidWlsZExvZ1N1ZmZpeCIsInVybFByZWZpeCIsInVybE9iaiIsInVybCIsInVybF9zdG9yZSIsIkF1dGhSZXF1ZXN0VHlwZSIsIkJhZEV2ZW50TmFtZSIsIm1zZyIsIkJhZENoYW5uZWxOYW1lIiwiUmVxdWVzdFRpbWVkT3V0IiwiVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3ciLCJUcmFuc3BvcnRDbG9zZWQiLCJVbnN1cHBvcnRlZEZlYXR1cmUiLCJVbnN1cHBvcnRlZFRyYW5zcG9ydCIsIlVuc3VwcG9ydGVkU3RyYXRlZ3kiLCJIVFRQQXV0aEVycm9yIiwic3RhdHVzIiwiYWpheCIsImNvbnRleHQiLCJxdWVyeSIsImF1dGhPcHRpb25zIiwiYXV0aFJlcXVlc3RUeXBlIiwieGhyIiwiY3JlYXRlWEhSIiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJoZWFkZXJOYW1lIiwiaGVhZGVycyIsImhlYWRlcnNQcm92aWRlciIsImR5bmFtaWNIZWFkZXJzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsImUiLCJ0b1N0cmluZyIsIlVzZXJBdXRoZW50aWNhdGlvbiIsIkNoYW5uZWxBdXRob3JpemF0aW9uIiwieGhyX2F1dGgiLCJidG9hIiwidXRvYiIsImI2NGNoYXJzIiwiYjY0dGFiIiwiYmFzZTY0X2kiLCJjaGFyQXQiLCJjYl91dG9iIiwiY2MiLCJ1IiwiY2JfZW5jb2RlIiwiY2NjIiwicGFkbGVuIiwib3JkIiwiVGltZXIiLCJpc1J1bm5pbmciLCJ0aW1lciIsImVuc3VyZUFib3J0ZWQiLCJjbGVhciIsInNldCIsImRlbGF5IiwiYWJzdHJhY3RfdGltZXIiLCJ0aW1lcnNfY2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidGltZXJzX2NsZWFySW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidGltZXJzX09uZU9mZlRpbWVyIiwic2V0VGltZW91dCIsInRpbWVyc19QZXJpb2RpY1RpbWVyIiwic2V0SW50ZXJ2YWwiLCJVdGlsIiwibm93IiwiRGF0ZSIsInZhbHVlT2YiLCJkZWZlciIsIm1ldGhvZCIsImFyZ3MiLCJib3VuZEFyZ3VtZW50cyIsInNsaWNlIiwiY29uY2F0IiwidXRpbCIsImV4dGVuZCIsInRhcmdldCIsInNvdXJjZXMiLCJleHRlbnNpb25zIiwic3RyaW5naWZ5Iiwic2FmZUpTT05TdHJpbmdpZnkiLCJhcnJheUluZGV4T2YiLCJhcnJheSIsIml0ZW0iLCJuYXRpdmVJbmRleE9mIiwiaW5kZXhPZiIsIm9iamVjdEFwcGx5IiwiZiIsImtleXMiLCJfIiwidmFsdWVzIiwibWFwIiwibWFwT2JqZWN0IiwiZmlsdGVyIiwidGVzdCIsImZpbHRlck9iamVjdCIsIkJvb2xlYW4iLCJmbGF0dGVuIiwiYW55IiwiY29sbGVjdGlvbnNfYWxsIiwiZW5jb2RlUGFyYW1zT2JqZWN0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYnVpbGRRdWVyeVN0cmluZyIsInBhcmFtcyIsInVuZGVmaW5lZCIsImRlY3ljbGVPYmplY3QiLCJvYmplY3RzIiwicGF0aHMiLCJkZXJleiIsIm51IiwiJHJlZiIsInNvdXJjZSIsImxvZ2dlcl9Mb2dnZXIiLCJkZWJ1ZyIsImxvZyIsImdsb2JhbExvZyIsIndhcm4iLCJnbG9iYWxMb2dXYXJuIiwiZ2xvYmFsTG9nRXJyb3IiLCJtZXNzYWdlIiwiY29uc29sZSIsImRlZmF1bHRMb2dnaW5nRnVuY3Rpb24iLCJjb3JlX3B1c2hlciIsImxvZ1RvQ29uc29sZSIsImxvZ2dlciIsImpzb25wIiwiY2FsbGJhY2tOYW1lIiwibmV4dEF1dGhDYWxsYmFja0lEIiwiZG9jdW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwiYXV0aF9jYWxsYmFja3MiLCJjYWxsYmFja19uYW1lIiwic3JjIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZG9jdW1lbnRFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsImpzb25wX2F1dGgiLCJTY3JpcHRSZXF1ZXN0IiwiZXJyb3JTdHJpbmciLCJ0eXBlIiwiY2hhcnNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwib25sb2FkIiwiYXN5bmMiLCJhdHRhY2hFdmVudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImVycm9yU2NyaXB0IiwidGV4dCIsIm5leHRTaWJsaW5nIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwianNvbnBfcmVxdWVzdF9KU09OUFJlcXVlc3QiLCJnZXRBZ2VudCIsInNlbmRlciIsInNjaGVtZSIsImhvc3QiLCJjcmVhdGVKU09OUFJlcXVlc3QiLCJqc29ucF90aW1lbGluZV9qc29ucCIsImpzb25wX3RpbWVsaW5lIiwiZ2V0R2VuZXJpY1VSTCIsImJhc2VTY2hlbWUiLCJob3N0VExTIiwiaG9zdE5vblRMUyIsImdldEdlbmVyaWNQYXRoIiwicXVlcnlTdHJpbmciLCJ3cyIsImdldEluaXRpYWwiLCJodHRwIiwic29ja2pzIiwiY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSIsIl9jYWxsYmFja3MiLCJhZGQiLCJwcmVmaXhlZEV2ZW50TmFtZSIsImZuIiwibmFtZXMiLCJyZW1vdmVDYWxsYmFjayIsInJlbW92ZUFsbENhbGxiYWNrcyIsImJpbmRpbmciLCJkaXNwYXRjaGVyX0Rpc3BhdGNoZXIiLCJldmVudE5hbWUiLCJiaW5kX2dsb2JhbCIsImdsb2JhbF9jYWxsYmFja3MiLCJ1bmJpbmQiLCJ1bmJpbmRfZ2xvYmFsIiwidW5iaW5kX2FsbCIsImVtaXQiLCJtZXRhZGF0YSIsImZhaWxUaHJvdWdoIiwidHJhbnNwb3J0X2Nvbm5lY3Rpb25fVHJhbnNwb3J0Q29ubmVjdGlvbiIsImhhbmRsZXNBY3Rpdml0eUNoZWNrcyIsImhvb2tzIiwic3VwcG9ydHNQaW5nIiwiY29ubmVjdCIsInNvY2tldCIsInN0YXRlIiwiZ2V0U29ja2V0Iiwib25FcnJvciIsImNoYW5nZVN0YXRlIiwiYmluZExpc3RlbmVycyIsImNsb3NlIiwicGluZyIsIm9uT3BlbiIsImJlZm9yZU9wZW4iLCJvbm9wZW4iLCJ0aW1lbGluZSIsImJ1aWxkVGltZWxpbmVNZXNzYWdlIiwib25DbG9zZSIsImNsb3NlRXZlbnQiLCJjb2RlIiwicmVhc29uIiwid2FzQ2xlYW4iLCJ1bmJpbmRMaXN0ZW5lcnMiLCJvbk1lc3NhZ2UiLCJvbkFjdGl2aXR5Iiwib25jbG9zZSIsIm9ubWVzc2FnZSIsIm9uYWN0aXZpdHkiLCJpbmZvIiwiY2lkIiwicHJpb3JpdHkiLCJpbml0aWFsaXplIiwidHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyIiwiZ2VuZXJhdGVVbmlxdWVJRCIsInRyYW5zcG9ydF9UcmFuc3BvcnQiLCJpc1N1cHBvcnRlZCIsImVudmlyb25tZW50IiwiY3JlYXRlQ29ubmVjdGlvbiIsIldTVHJhbnNwb3J0IiwiaXNJbml0aWFsaXplZCIsImdldFdlYlNvY2tldEFQSSIsImNyZWF0ZVdlYlNvY2tldCIsImh0dHBDb25maWd1cmF0aW9uIiwic3RyZWFtaW5nQ29uZmlndXJhdGlvbiIsIkhUVFBGYWN0b3J5IiwiY3JlYXRlU3RyZWFtaW5nU29ja2V0IiwicG9sbGluZ0NvbmZpZ3VyYXRpb24iLCJjcmVhdGVQb2xsaW5nU29ja2V0IiwieGhyQ29uZmlndXJhdGlvbiIsImlzWEhSU3VwcG9ydGVkIiwiWEhSU3RyZWFtaW5nVHJhbnNwb3J0IiwiWEhSUG9sbGluZ1RyYW5zcG9ydCIsIlRyYW5zcG9ydHMiLCJ4aHJfc3RyZWFtaW5nIiwieGhyX3BvbGxpbmciLCJ0cmFuc3BvcnRzIiwiU29ja0pTVHJhbnNwb3J0IiwiZmlsZSIsIlNvY2tKUyIsImpzX3BhdGgiLCJpZ25vcmVfbnVsbF9vcmlnaW4iLCJpZ25vcmVOdWxsT3JpZ2luIiwieGRyQ29uZmlndXJhdGlvbiIsInllcyIsImlzWERSU3VwcG9ydGVkIiwiWERSU3RyZWFtaW5nVHJhbnNwb3J0IiwiWERSUG9sbGluZ1RyYW5zcG9ydCIsInhkcl9zdHJlYW1pbmciLCJ4ZHJfcG9sbGluZyIsInRyYW5zcG9ydHNfdHJhbnNwb3J0cyIsIm5ldF9pbmZvX05ldEluZm8iLCJpc09ubGluZSIsIm9uTGluZSIsIm5ldF9pbmZvX05ldHdvcmsiLCJhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciIsInBpbmdEZWxheSIsImNvbm5lY3Rpb24iLCJvcGVuVGltZXN0YW1wIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwicmVwb3J0RGVhdGgiLCJsaWZlc3BhbiIsIm1heFBpbmdEZWxheSIsIk1hdGgiLCJtYXgiLCJtaW5QaW5nRGVsYXkiLCJpc0FsaXZlIiwiUHJvdG9jb2wiLCJkZWNvZGVNZXNzYWdlIiwibWVzc2FnZUV2ZW50IiwibWVzc2FnZURhdGEiLCJwdXNoZXJFdmVudERhdGEiLCJwdXNoZXJFdmVudCIsImV2ZW50IiwiY2hhbm5lbCIsInVzZXJfaWQiLCJlbmNvZGVNZXNzYWdlIiwicHJvY2Vzc0hhbmRzaGFrZSIsImFjdGl2aXR5X3RpbWVvdXQiLCJhY3Rpb24iLCJzb2NrZXRfaWQiLCJnZXRDbG9zZUFjdGlvbiIsImdldENsb3NlRXJyb3IiLCJwcm90b2NvbF9wcm90b2NvbCIsImNvbm5lY3Rpb25fQ29ubmVjdGlvbiIsInNlbmRfZXZlbnQiLCJsaXN0ZW5lcnMiLCJhY3Rpdml0eSIsImNsb3NlZCIsImhhbmRsZUNsb3NlRXZlbnQiLCJsaXN0ZW5lciIsImhhbmRzaGFrZV9IYW5kc2hha2UiLCJmaW5pc2giLCJ0aW1lbGluZV9zZW5kZXJfVGltZWxpbmVTZW5kZXIiLCJpc0VtcHR5IiwiVGltZWxpbmVUcmFuc3BvcnQiLCJjaGFubmVsX0NoYW5uZWwiLCJhdXRob3JpemUiLCJzb2NrZXRJZCIsImF1dGgiLCJ0cmlnZ2VyIiwic3Vic2NyaWJlZCIsInB1c2hlciIsImRpc2Nvbm5lY3QiLCJzdWJzY3JpcHRpb25QZW5kaW5nIiwiaGFuZGxlRXZlbnQiLCJoYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudCIsImhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQiLCJzdWJzY3JpcHRpb25DYW5jZWxsZWQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmlwdGlvbl9jb3VudCIsInN1YnNjcmlwdGlvbkNvdW50Iiwic3Vic2NyaWJlIiwiYXNzaWduIiwiY2hhbm5lbF9kYXRhIiwiY2FuY2VsU3Vic2NyaXB0aW9uIiwicmVpbnN0YXRlU3Vic2NyaXB0aW9uIiwicHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsIiwiY29uZmlnIiwiY2hhbm5lbEF1dGhvcml6ZXIiLCJjaGFubmVsTmFtZSIsIm1lbWJlcnNfTWVtYmVycyIsIm1lbWJlcnMiLCJlYWNoIiwibWVtYmVyIiwic2V0TXlJRCIsIm15SUQiLCJvblN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbkRhdGEiLCJwcmVzZW5jZSIsImhhc2giLCJjb3VudCIsIm1lIiwiYWRkTWVtYmVyIiwibWVtYmVyRGF0YSIsInVzZXJfaW5mbyIsInJlbW92ZU1lbWJlciIsInJlc2V0IiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJkb25lIiwidGhlbiIsInByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsIiwiYXV0aERhdGEiLCJjaGFubmVsRGF0YSIsInVzZXIiLCJzaWduaW5Eb25lUHJvbWlzZSIsInVzZXJfZGF0YSIsImhhbmRsZUludGVybmFsRXZlbnQiLCJhZGRlZE1lbWJlciIsInJlbW92ZWRNZW1iZXIiLCJ1dGY4IiwiYmFzZTY0IiwiZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbCIsInNoYXJlZFNlY3JldCIsImhhbmRsZUVuY3J5cHRlZEV2ZW50IiwiY2lwaGVydGV4dCIsIm5vbmNlIiwiY2lwaGVyVGV4dCIsIm5hY2wiLCJzZWNyZXRib3giLCJvdmVyaGVhZExlbmd0aCIsIm5vbmNlTGVuZ3RoIiwiYnl0ZXMiLCJnZXREYXRhVG9FbWl0IiwicmF3IiwiX2EiLCJjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIiLCJzd2l0Y2hDbHVzdGVyIiwidXBkYXRlU3RyYXRlZ3kiLCJyZXRyeUluIiwicnVubmVyIiwic3RyYXRlZ3kiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0Q29ubmVjdGluZyIsInNldFVuYXZhaWxhYmxlVGltZXIiLCJkaXNjb25uZWN0SW50ZXJuYWxseSIsImlzVXNpbmdUTFMiLCJ1c2luZ1RMUyIsImhhbmRzaGFrZSIsImhhbmRzaGFrZUVycm9yIiwiYWJvcnRDb25uZWN0aW5nIiwiaGFuZHNoYWtlQ2FsbGJhY2tzIiwiYWJvcnQiLCJjbGVhclJldHJ5VGltZXIiLCJjbGVhclVuYXZhaWxhYmxlVGltZXIiLCJhYmFuZG9uQ29ubmVjdGlvbiIsImdldFN0cmF0ZWd5Iiwicm91bmQiLCJyZXRyeVRpbWVyIiwidW5hdmFpbGFibGVUaW1lciIsInNlbmRBY3Rpdml0eUNoZWNrIiwic3RvcEFjdGl2aXR5Q2hlY2siLCJhY3Rpdml0eVRpbWVyIiwicG9uZ190aW1lZF9vdXQiLCJyZXNldEFjdGl2aXR5Q2hlY2siLCJidWlsZENvbm5lY3Rpb25DYWxsYmFja3MiLCJlcnJvckNhbGxiYWNrcyIsInNob3VsZFJldHJ5IiwiYnVpbGRIYW5kc2hha2VDYWxsYmFja3MiLCJjb25uZWN0ZWQiLCJJbmZpbml0eSIsInNldENvbm5lY3Rpb24iLCJidWlsZEVycm9yQ2FsbGJhY2tzIiwid2l0aEVycm9yRW1pdHRlZCIsInRsc19vbmx5IiwicmVmdXNlZCIsImJhY2tvZmYiLCJyZXRyeSIsImNvbm5lY3Rpb25DYWxsYmFja3MiLCJuZXdTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZURlc2NyaXB0aW9uIiwicHJldmlvdXMiLCJjdXJyZW50IiwiTmV0d29yayIsImdldE5ldHdvcmsiLCJuZXRpbmZvIiwiY2hhbm5lbHNfQ2hhbm5lbHMiLCJjaGFubmVscyIsImNyZWF0ZUNoYW5uZWwiLCJhbGwiLCJmaW5kIiwiY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbCIsImVyck1zZyIsImNyZWF0ZVByaXZhdGVDaGFubmVsIiwiY3JlYXRlUHJlc2VuY2VDaGFubmVsIiwiRmFjdG9yeSIsImNyZWF0ZUNoYW5uZWxzIiwiY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXIiLCJjcmVhdGVUaW1lbGluZVNlbmRlciIsImNyZWF0ZUhhbmRzaGFrZSIsImNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciIsInRyYW5zcG9ydF9tYW5hZ2VyX1RyYW5zcG9ydE1hbmFnZXIiLCJnZXRBc3Npc3RhbnQiLCJsaXZlc0xlZnQiLCJsaXZlcyIsInNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5Iiwic3RyYXRlZ2llcyIsIm1pblByaW9yaXR5IiwidGltZW91dCIsInRyeU5leHRTdHJhdGVneSIsImxvb3AiLCJ0aW1lb3V0TGltaXQiLCJ0cnlTdHJhdGVneSIsImZhaWxGYXN0IiwiZm9yY2VNaW5Qcmlvcml0eSIsImJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneSIsInJ1bm5lcnMiLCJhbGxSdW5uZXJzRmFpbGVkIiwiY2FsbGJhY2tCdWlsZGVyIiwicnMiLCJhYm9ydFJ1bm5lciIsImFib3J0ZWQiLCJ3ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5X1dlYlNvY2tldFByaW9yaXRpemVkQ2FjaGVkU3RyYXRlZ3kiLCJmZXRjaFRyYW5zcG9ydENhY2hlIiwiY2FjaGVTa2lwQ291bnQiLCJ0aW1lc3RhbXAiLCJ0dGwiLCJpbmNsdWRlcyIsImNhY2hlZCIsImxhdGVuY3kiLCJzdGFydFRpbWVzdGFtcCIsInBvcCIsImNiIiwiZmx1c2hUcmFuc3BvcnRDYWNoZSIsInN0b3JlVHJhbnNwb3J0Q2FjaGUiLCJnZXRUcmFuc3BvcnRDYWNoZUtleSIsInN0b3JhZ2UiLCJnZXRMb2NhbFN0b3JhZ2UiLCJzZXJpYWxpemVkQ2FjaGUiLCJkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneSIsIklmU3RyYXRlZ3kiLCJicmFuY2giLCJ0cnVlQnJhbmNoIiwiZmFsc2VCcmFuY2giLCJGaXJzdENvbm5lY3RlZFN0cmF0ZWd5IiwidGVzdFN1cHBvcnRzU3RyYXRlZ3kiLCJnZXREZWZhdWx0U3RyYXRlZ3kiLCJiYXNlT3B0aW9ucyIsImRlZmluZVRyYW5zcG9ydCIsImRlZmluZWRUcmFuc3BvcnRzIiwiZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3kiLCJ3c19vcHRpb25zIiwid3NIb3N0Iiwid3NzX29wdGlvbnMiLCJzb2NranNfb3B0aW9ucyIsInRpbWVvdXRzIiwid3NfbWFuYWdlciIsInN0cmVhbWluZ19tYW5hZ2VyIiwid3NfdHJhbnNwb3J0Iiwid3NzX3RyYW5zcG9ydCIsInNvY2tqc190cmFuc3BvcnQiLCJ4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydCIsInhkcl9zdHJlYW1pbmdfdHJhbnNwb3J0IiwieGhyX3BvbGxpbmdfdHJhbnNwb3J0IiwieGRyX3BvbGxpbmdfdHJhbnNwb3J0Iiwid3NfbG9vcCIsIndzc19sb29wIiwic29ja2pzX2xvb3AiLCJzdHJlYW1pbmdfbG9vcCIsInBvbGxpbmdfbG9vcCIsImh0dHBfbG9vcCIsImh0dHBfZmFsbGJhY2tfbG9vcCIsIndzU3RyYXRlZ3kiLCJkZWZhdWx0X3N0cmF0ZWd5IiwidHJhbnNwb3J0X2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXIiLCJodHRwX3hkb21haW5fcmVxdWVzdF9ob29rcyIsImdldFJlcXVlc3QiLCJ4ZHIiLCJYRG9tYWluUmVxdWVzdCIsIm9udGltZW91dCIsIm9ucHJvZ3Jlc3MiLCJvbkNodW5rIiwiYWJvcnRSZXF1ZXN0IiwiaHR0cF94ZG9tYWluX3JlcXVlc3QiLCJNQVhfQlVGRkVSX0xFTkdUSCIsImh0dHBfcmVxdWVzdF9IVFRQUmVxdWVzdCIsInN0YXJ0IiwicGF5bG9hZCIsInBvc2l0aW9uIiwidW5sb2FkZXIiLCJhZGRVbmxvYWRMaXN0ZW5lciIsInJlbW92ZVVubG9hZExpc3RlbmVyIiwiY2h1bmsiLCJhZHZhbmNlQnVmZmVyIiwiaXNCdWZmZXJUb29Mb25nIiwiYnVmZmVyIiwidW5yZWFkRGF0YSIsImVuZE9mTGluZVBvc2l0aW9uIiwiU3RhdGUiLCJhdXRvSW5jcmVtZW50IiwiaHR0cF9zb2NrZXRfSFRUUFNvY2tldCIsInNlbmRSYXciLCJzZW5kSGVhcnRiZWF0IiwiT1BFTiIsImNyZWF0ZVNvY2tldFJlcXVlc3QiLCJnZXRVbmlxdWVVUkwiLCJnZXRTZW5kVVJMIiwic2Vzc2lvbiIsInJlY29ubmVjdCIsImNsb3NlU3RyZWFtIiwib3BlblN0cmVhbSIsIkNMT1NFRCIsIm9uRXZlbnQiLCJvbkhlYXJ0YmVhdCIsIkNPTk5FQ1RJTkciLCJob3N0bmFtZSIsImJhc2UiLCJyZXBsYWNlSG9zdCIsInN0cmVhbSIsImdldFJlY2VpdmVVUkwiLCJvbkZpbmlzaGVkIiwicmFuZG9tTnVtYmVyIiwicmFuZG9tU3RyaW5nIiwiZ2V0TG9jYXRpb24iLCJwYXJ0cyIsImV4ZWMiLCJzZXBhcmF0b3IiLCJ1cmxQYXJ0cyIsInJhbmRvbUludCIsImh0dHBfc29ja2V0IiwiaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzIiwiaHR0cF9zdHJlYW1pbmdfc29ja2V0IiwiaHR0cF9wb2xsaW5nX3NvY2tldF9ob29rcyIsImh0dHBfcG9sbGluZ19zb2NrZXQiLCJodHRwX3hocl9yZXF1ZXN0X2hvb2tzIiwiQ29uc3RydWN0b3IiLCJnZXRYSFJBUEkiLCJodHRwX3hocl9yZXF1ZXN0IiwiSFRUUCIsImNyZWF0ZVNvY2tldCIsImNyZWF0ZVJlcXVlc3QiLCJodHRwX2h0dHAiLCJjcmVhdGVYRFIiLCJ3ZWJfaHR0cF9odHRwIiwiUnVudGltZSIsIlhNTEh0dHBSZXF1ZXN0IiwiV2ViU29ja2V0IiwiTW96V2ViU29ja2V0Iiwic2V0dXAiLCJQdXNoZXJDbGFzcyIsIlB1c2hlciIsImluaXRpYWxpemVPbkRvY3VtZW50Qm9keSIsIm9uRG9jdW1lbnRCb2R5IiwicmVhZHkiLCJnZXRQcm90b2NvbCIsImdldEF1dGhvcml6ZXJzIiwiYm9keSIsImxvY2FsU3RvcmFnZSIsImNyZWF0ZVhNTEh0dHBSZXF1ZXN0IiwiY3JlYXRlTWljcm9zb2Z0WEhSIiwiQWN0aXZlWE9iamVjdCIsIndpdGhDcmVkZW50aWFscyIsImRvY3VtZW50UHJvdG9jb2wiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJyYW5kb20iLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJVaW50MzJBcnJheSIsInBvdyIsImZsb29yIiwiVGltZWxpbmVMZXZlbCIsInRpbWVsaW5lX2xldmVsIiwidGltZWxpbmVfVGltZWxpbmUiLCJsZXZlbCIsImV2ZW50cyIsImxpbWl0Iiwic2hpZnQiLCJFUlJPUiIsIklORk8iLCJERUJVRyIsInNlbmRmbiIsImJ1bmRsZSIsInNlbnQiLCJsaWIiLCJjbHVzdGVyIiwiZmVhdHVyZXMiLCJ1bmlxdWVJRCIsInRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneSIsImZhaWxBdHRlbXB0Iiwib25Jbml0aWFsaXplZCIsInNlcmlhbGl6ZWRUcmFuc3BvcnQiLCJzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHMiLCJzdHJhdGVneV9idWlsZGVyX2RlZmluZVRyYW5zcG9ydCIsInRyYW5zcG9ydENsYXNzIiwiZW5hYmxlZCIsImVuYWJsZWRUcmFuc3BvcnRzIiwiZGlzYWJsZWRUcmFuc3BvcnRzIiwic3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5IiwiZGVmZXJyZWQiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJjb21wb3NlQ2hhbm5lbFF1ZXJ5IiwicGFyYW1zUHJvdmlkZXIiLCJkeW5hbWljUGFyYW1zIiwiVXNlckF1dGhlbnRpY2F0b3IiLCJ1c2VyX2F1dGhlbnRpY2F0b3IiLCJjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSIsIkNoYW5uZWxBdXRob3JpemVyIiwiY2hhbm5lbF9hdXRob3JpemVyIiwiQ2hhbm5lbEF1dGhvcml6ZXJQcm94eSIsImNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yIiwiZGVwcmVjYXRlZEF1dGhvcml6ZXJPcHRpb25zIiwiZ2V0Q29uZmlnIiwib3B0cyIsInN0YXRzSG9zdCIsImVuYWJsZVN0YXRzIiwiZ2V0RW5hYmxlU3RhdHNDb25maWciLCJnZXRIdHRwSG9zdCIsInNob3VsZFVzZVRMUyIsImdldFdlYnNvY2tldEhvc3QiLCJ1c2VyQXV0aGVudGljYXRvciIsImJ1aWxkVXNlckF1dGhlbnRpY2F0b3IiLCJidWlsZENoYW5uZWxBdXRob3JpemVyIiwidGltZWxpbmVQYXJhbXMiLCJnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIiLCJmb3JjZVRMUyIsImRpc2FibGVTdGF0cyIsImhhc0N1c3RvbUhhbmRsZXIiLCJidWlsZENoYW5uZWxBdXRoIiwiY3VzdG9tSGFuZGxlciIsImF1dGhvcml6ZXIiLCJ3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlIiwiZm9yRWFjaCIsIndhdGNobGlzdEV2ZW50IiwiYmluZFdhdGNobGlzdEludGVybmFsRXZlbnQiLCJmbGF0UHJvbWlzZSIsInByb21pc2UiLCJyZXMiLCJyZWoiLCJmbGF0X3Byb21pc2UiLCJ1c2VyX1VzZXJGYWNhZGUiLCJzaWduaW4iLCJzaWduaW5fcmVxdWVzdGVkIiwiX3NpZ25pbiIsIl9uZXdTaWduaW5Qcm9taXNlSWZOZWVkZWQiLCJfb25BdXRob3JpemUiLCJfb25TaWduaW5TdWNjZXNzIiwiX2NsZWFudXAiLCJfc2lnbmluRG9uZVJlc29sdmUiLCJfc3Vic2NyaWJlQ2hhbm5lbHMiLCJlbnN1cmVfc3Vic2NyaWJlZCIsInNlcnZlclRvVXNlckNoYW5uZWwiLCJzZXREb25lIiwiY2F0Y2giLCJlcnIiLCJ3YXRjaGxpc3QiLCJwdXNoZXJfUHVzaGVyIiwiaXNSZWFkeSIsImluc3RhbmNlcyIsImdldENsaWVudEZlYXR1cmVzIiwiYXBwS2V5IiwiYWxsQ2hhbm5lbHMiLCJ0aW1lbGluZVNlbmRlciIsInRpbWVsaW5lU2VuZGVyVGltZXIiLCJldmVudF9uYW1lIiwiZ2xvYmFsX2VtaXR0ZXIiLCJzdWJzY3JpYmVBbGwiLCJjaGFubmVsX25hbWUiLCJhcHBfa2V5IiwiY2hlY2tBcHBLZXkiLCJzZXNzaW9uSUQiLCJpbnRlcm5hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pusher-js/dist/web/pusher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/arrows.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/arrows.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PrevArrow = exports.NextArrow = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nvar PrevArrow = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(PrevArrow, _React$PureComponent);\n    var _super = _createSuper(PrevArrow);\n    function PrevArrow() {\n        _classCallCheck(this, PrevArrow);\n        return _super.apply(this, arguments);\n    }\n    _createClass(PrevArrow, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                if (e) {\n                    e.preventDefault();\n                }\n                this.props.clickHandler(options, e);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var prevClasses = {\n                    \"slick-arrow\": true,\n                    \"slick-prev\": true\n                };\n                var prevHandler = this.clickHandler.bind(this, {\n                    message: \"previous\"\n                });\n                if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {\n                    prevClasses[\"slick-disabled\"] = true;\n                    prevHandler = null;\n                }\n                var prevArrowProps = {\n                    key: \"0\",\n                    \"data-role\": \"none\",\n                    className: (0, _classnames[\"default\"])(prevClasses),\n                    style: {\n                        display: \"block\"\n                    },\n                    onClick: prevHandler\n                };\n                var customProps = {\n                    currentSlide: this.props.currentSlide,\n                    slideCount: this.props.slideCount\n                };\n                var prevArrow;\n                if (this.props.prevArrow) {\n                    prevArrow = /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));\n                } else {\n                    prevArrow = /*#__PURE__*/ _react[\"default\"].createElement(\"button\", _extends({\n                        key: \"0\",\n                        type: \"button\"\n                    }, prevArrowProps), \" \", \"Previous\");\n                }\n                return prevArrow;\n            }\n        }\n    ]);\n    return PrevArrow;\n}(_react[\"default\"].PureComponent);\nexports.PrevArrow = PrevArrow;\nvar NextArrow = /*#__PURE__*/ function(_React$PureComponent2) {\n    _inherits(NextArrow, _React$PureComponent2);\n    var _super2 = _createSuper(NextArrow);\n    function NextArrow() {\n        _classCallCheck(this, NextArrow);\n        return _super2.apply(this, arguments);\n    }\n    _createClass(NextArrow, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                if (e) {\n                    e.preventDefault();\n                }\n                this.props.clickHandler(options, e);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var nextClasses = {\n                    \"slick-arrow\": true,\n                    \"slick-next\": true\n                };\n                var nextHandler = this.clickHandler.bind(this, {\n                    message: \"next\"\n                });\n                if (!(0, _innerSliderUtils.canGoNext)(this.props)) {\n                    nextClasses[\"slick-disabled\"] = true;\n                    nextHandler = null;\n                }\n                var nextArrowProps = {\n                    key: \"1\",\n                    \"data-role\": \"none\",\n                    className: (0, _classnames[\"default\"])(nextClasses),\n                    style: {\n                        display: \"block\"\n                    },\n                    onClick: nextHandler\n                };\n                var customProps = {\n                    currentSlide: this.props.currentSlide,\n                    slideCount: this.props.slideCount\n                };\n                var nextArrow;\n                if (this.props.nextArrow) {\n                    nextArrow = /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));\n                } else {\n                    nextArrow = /*#__PURE__*/ _react[\"default\"].createElement(\"button\", _extends({\n                        key: \"1\",\n                        type: \"button\"\n                    }, nextArrowProps), \" \", \"Next\");\n                }\n                return nextArrow;\n            }\n        }\n    ]);\n    return NextArrow;\n}(_react[\"default\"].PureComponent);\nexports.NextArrow = NextArrow;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvYXJyb3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsR0FBRztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLEdBQUc7UUFBSSxPQUFPLE9BQU9BO0lBQUssSUFBSSxTQUFVQSxHQUFHO1FBQUksT0FBT0EsT0FBTyxjQUFjLE9BQU9DLFVBQVVELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBSyxHQUFHRCxRQUFRQztBQUFNO0FBRS9VSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFFN0MsSUFBSUksU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUVuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDBFQUFZO0FBRTdELElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUMsOEdBQTBCO0FBRTFELFNBQVNELHVCQUF1QlosR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlnQixVQUFVLEdBQUdoQixNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLFNBQVNpQjtJQUFhQSxXQUFXWixPQUFPYSxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSWxCLE9BQU9ELFNBQVMsQ0FBQ3FCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFB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QUFDOUMsS0FBSyxDQUFDOEMsWUFBWTtvQkFDckNDLFlBQVksSUFBSSxDQUFDL0MsS0FBSyxDQUFDK0MsVUFBVTtnQkFDbkM7Z0JBQ0EsSUFBSW1CO2dCQUVKLElBQUksSUFBSSxDQUFDbEUsS0FBSyxDQUFDa0UsU0FBUyxFQUFFO29CQUN4QkEsWUFBWSxXQUFXLEdBQUUxRyxNQUFNLENBQUMsVUFBVSxDQUFDZ0csWUFBWSxDQUFDLElBQUksQ0FBQ3hELEtBQUssQ0FBQ2tFLFNBQVMsRUFBRTlFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHNkUsaUJBQWlCWDtnQkFDakksT0FBTztvQkFDTFksWUFBWSxXQUFXLEdBQUUxRyxNQUFNLENBQUMsVUFBVSxDQUFDaUcsYUFBYSxDQUFDLFVBQVUzRixTQUFTO3dCQUMxRU8sS0FBSzt3QkFDTHFGLE1BQU07b0JBQ1IsR0FBR08saUJBQWlCLEtBQUs7Z0JBQzNCO2dCQUVBLE9BQU9DO1lBQ1Q7UUFDRjtLQUFFO0lBRUYsT0FBTzNHO0FBQ1QsRUFBRUMsTUFBTSxDQUFDLFVBQVUsQ0FBQ21HLGFBQWE7QUFFakN2RyxpQkFBaUIsR0FBR0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9hcnJvd3MuanM/NjY4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QcmV2QXJyb3cgPSBleHBvcnRzLk5leHRBcnJvdyA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9jbGFzc25hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSk7XG5cbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByZXZBcnJvdywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHJldkFycm93KTtcblxuICBmdW5jdGlvbiBQcmV2QXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByZXZBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUHJldkFycm93LCBbe1xuICAgIGtleTogXCJjbGlja0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcy5jbGlja0hhbmRsZXIob3B0aW9ucywgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcHJldkNsYXNzZXMgPSB7XG4gICAgICAgIFwic2xpY2stYXJyb3dcIjogdHJ1ZSxcbiAgICAgICAgXCJzbGljay1wcmV2XCI6IHRydWVcbiAgICAgIH07XG4gICAgICB2YXIgcHJldkhhbmRsZXIgPSB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMsIHtcbiAgICAgICAgbWVzc2FnZTogXCJwcmV2aW91c1wiXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmluZmluaXRlICYmICh0aGlzLnByb3BzLmN1cnJlbnRTbGlkZSA9PT0gMCB8fCB0aGlzLnByb3BzLnNsaWRlQ291bnQgPD0gdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cpKSB7XG4gICAgICAgIHByZXZDbGFzc2VzW1wic2xpY2stZGlzYWJsZWRcIl0gPSB0cnVlO1xuICAgICAgICBwcmV2SGFuZGxlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2QXJyb3dQcm9wcyA9IHtcbiAgICAgICAga2V5OiBcIjBcIixcbiAgICAgICAgXCJkYXRhLXJvbGVcIjogXCJub25lXCIsXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkocHJldkNsYXNzZXMpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBwcmV2SGFuZGxlclxuICAgICAgfTtcbiAgICAgIHZhciBjdXN0b21Qcm9wcyA9IHtcbiAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLnByb3BzLmN1cnJlbnRTbGlkZSxcbiAgICAgICAgc2xpZGVDb3VudDogdGhpcy5wcm9wcy5zbGlkZUNvdW50XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZBcnJvdztcblxuICAgICAgaWYgKHRoaXMucHJvcHMucHJldkFycm93KSB7XG4gICAgICAgIHByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0aGlzLnByb3BzLnByZXZBcnJvdywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2QXJyb3dQcm9wcyksIGN1c3RvbVByb3BzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IFwiMFwiLFxuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgfSwgcHJldkFycm93UHJvcHMpLCBcIiBcIiwgXCJQcmV2aW91c1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZBcnJvdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJldkFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnRzLlByZXZBcnJvdyA9IFByZXZBcnJvdztcblxudmFyIE5leHRBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhOZXh0QXJyb3csIF9SZWFjdCRQdXJlQ29tcG9uZW50Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoTmV4dEFycm93KTtcblxuICBmdW5jdGlvbiBOZXh0QXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5leHRBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5leHRBcnJvdywgW3tcbiAgICBrZXk6IFwiY2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zLCBlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMuY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIG5leHRDbGFzc2VzID0ge1xuICAgICAgICBcInNsaWNrLWFycm93XCI6IHRydWUsXG4gICAgICAgIFwic2xpY2stbmV4dFwiOiB0cnVlXG4gICAgICB9O1xuICAgICAgdmFyIG5leHRIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwibmV4dFwiXG4gICAgICB9KTtcblxuICAgICAgaWYgKCEoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuR29OZXh0KSh0aGlzLnByb3BzKSkge1xuICAgICAgICBuZXh0Q2xhc3Nlc1tcInNsaWNrLWRpc2FibGVkXCJdID0gdHJ1ZTtcbiAgICAgICAgbmV4dEhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dEFycm93UHJvcHMgPSB7XG4gICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgIFwiZGF0YS1yb2xlXCI6IFwibm9uZVwiLFxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKG5leHRDbGFzc2VzKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogbmV4dEhhbmRsZXJcbiAgICAgIH07XG4gICAgICB2YXIgY3VzdG9tUHJvcHMgPSB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5wcm9wcy5jdXJyZW50U2xpZGUsXG4gICAgICAgIHNsaWRlQ291bnQ6IHRoaXMucHJvcHMuc2xpZGVDb3VudFxuICAgICAgfTtcbiAgICAgIHZhciBuZXh0QXJyb3c7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLm5leHRBcnJvdykge1xuICAgICAgICBuZXh0QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5uZXh0QXJyb3csIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV4dEFycm93UHJvcHMpLCBjdXN0b21Qcm9wcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIjFcIixcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgIH0sIG5leHRBcnJvd1Byb3BzKSwgXCIgXCIsIFwiTmV4dFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRBcnJvdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV4dEFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnRzLk5leHRBcnJvdyA9IE5leHRBcnJvdzsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlByZXZBcnJvdyIsIk5leHRBcnJvdyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2NsYXNzbmFtZXMiLCJfaW5uZXJTbGlkZXJVdGlscyIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImUiLCJnZXRQcm90b3R5cGVPZiIsIl9SZWFjdCRQdXJlQ29tcG9uZW50IiwiX3N1cGVyIiwiY2xpY2tIYW5kbGVyIiwib3B0aW9ucyIsInByZXZlbnREZWZhdWx0IiwicmVuZGVyIiwicHJldkNsYXNzZXMiLCJwcmV2SGFuZGxlciIsImJpbmQiLCJtZXNzYWdlIiwiaW5maW5pdGUiLCJjdXJyZW50U2xpZGUiLCJzbGlkZUNvdW50Iiwic2xpZGVzVG9TaG93IiwicHJldkFycm93UHJvcHMiLCJjbGFzc05hbWUiLCJzdHlsZSIsImRpc3BsYXkiLCJvbkNsaWNrIiwiY3VzdG9tUHJvcHMiLCJwcmV2QXJyb3ciLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsIlB1cmVDb21wb25lbnQiLCJfUmVhY3QkUHVyZUNvbXBvbmVudDIiLCJfc3VwZXIyIiwibmV4dENsYXNzZXMiLCJuZXh0SGFuZGxlciIsImNhbkdvTmV4dCIsIm5leHRBcnJvd1Byb3BzIiwibmV4dEFycm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/arrows.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/default-props.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/default-props.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar defaultProps = {\n    accessibility: true,\n    adaptiveHeight: false,\n    afterChange: null,\n    appendDots: function appendDots(dots) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n            style: {\n                display: \"block\"\n            }\n        }, dots);\n    },\n    arrows: true,\n    autoplay: false,\n    autoplaySpeed: 3000,\n    beforeChange: null,\n    centerMode: false,\n    centerPadding: \"50px\",\n    className: \"\",\n    cssEase: \"ease\",\n    customPaging: function customPaging(i) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"button\", null, i + 1);\n    },\n    dots: false,\n    dotsClass: \"slick-dots\",\n    draggable: true,\n    easing: \"linear\",\n    edgeFriction: 0.35,\n    fade: false,\n    focusOnSelect: false,\n    infinite: true,\n    initialSlide: 0,\n    lazyLoad: null,\n    nextArrow: null,\n    onEdge: null,\n    onInit: null,\n    onLazyLoadError: null,\n    onReInit: null,\n    pauseOnDotsHover: false,\n    pauseOnFocus: false,\n    pauseOnHover: true,\n    prevArrow: null,\n    responsive: null,\n    rows: 1,\n    rtl: false,\n    slide: \"div\",\n    slidesPerRow: 1,\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    speed: 500,\n    swipe: true,\n    swipeEvent: null,\n    swipeToSlide: false,\n    touchMove: true,\n    touchThreshold: 5,\n    useCSS: true,\n    useTransform: true,\n    variableWidth: false,\n    vertical: false,\n    waitForAnimate: true\n};\nvar _default = defaultProps;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZGVmYXVsdC1wcm9wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUUxQixJQUFJRSxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1GQUFPO0FBRW5ELFNBQVNELHVCQUF1QkUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUVoRyxJQUFJRSxlQUFlO0lBQ2pCQyxlQUFlO0lBQ2ZDLGdCQUFnQjtJQUNoQkMsYUFBYTtJQUNiQyxZQUFZLFNBQVNBLFdBQVdDLElBQUk7UUFDbEMsT0FBTyxXQUFXLEdBQUVWLE1BQU0sQ0FBQyxVQUFVLENBQUNXLGFBQWEsQ0FBQyxNQUFNO1lBQ3hEQyxPQUFPO2dCQUNMQyxTQUFTO1lBQ1g7UUFDRixHQUFHSDtJQUNMO0lBQ0FJLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxlQUFlO0lBQ2ZDLGNBQWM7SUFDZEMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxjQUFjLFNBQVNBLGFBQWFDLENBQUM7UUFDbkMsT0FBTyxXQUFXLEdBQUV2QixNQUFNLENBQUMsVUFBVSxDQUFDVyxhQUFhLENBQUMsVUFBVSxNQUFNWSxJQUFJO0lBQzFFO0lBQ0FiLE1BQU07SUFDTmMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFFBQVE7SUFDUkMsY0FBYztJQUNkQyxNQUFNO0lBQ05DLGVBQWU7SUFDZkMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsaUJBQWlCO0lBQ2pCQyxVQUFVO0lBQ1ZDLGtCQUFrQjtJQUNsQkMsY0FBYztJQUNkQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsWUFBWTtJQUNaQyxNQUFNO0lBQ05DLEtBQUs7SUFDTEMsT0FBTztJQUNQQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCQyxRQUFRO0lBQ1JDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxVQUFVO0lBQ1ZDLGdCQUFnQjtBQUNsQjtBQUNBLElBQUlDLFdBQVd2RDtBQUNmUCxrQkFBa0IsR0FBRzhEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZGVmYXVsdC1wcm9wcy5qcz9jOTU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFmdGVyQ2hhbmdlOiBudWxsLFxuICBhcHBlbmREb3RzOiBmdW5jdGlvbiBhcHBlbmREb3RzKGRvdHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgfVxuICAgIH0sIGRvdHMpO1xuICB9LFxuICBhcnJvd3M6IHRydWUsXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlTcGVlZDogMzAwMCxcbiAgYmVmb3JlQ2hhbmdlOiBudWxsLFxuICBjZW50ZXJNb2RlOiBmYWxzZSxcbiAgY2VudGVyUGFkZGluZzogXCI1MHB4XCIsXG4gIGNsYXNzTmFtZTogXCJcIixcbiAgY3NzRWFzZTogXCJlYXNlXCIsXG4gIGN1c3RvbVBhZ2luZzogZnVuY3Rpb24gY3VzdG9tUGFnaW5nKGkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBudWxsLCBpICsgMSk7XG4gIH0sXG4gIGRvdHM6IGZhbHNlLFxuICBkb3RzQ2xhc3M6IFwic2xpY2stZG90c1wiLFxuICBkcmFnZ2FibGU6IHRydWUsXG4gIGVhc2luZzogXCJsaW5lYXJcIixcbiAgZWRnZUZyaWN0aW9uOiAwLjM1LFxuICBmYWRlOiBmYWxzZSxcbiAgZm9jdXNPblNlbGVjdDogZmFsc2UsXG4gIGluZmluaXRlOiB0cnVlLFxuICBpbml0aWFsU2xpZGU6IDAsXG4gIGxhenlMb2FkOiBudWxsLFxuICBuZXh0QXJyb3c6IG51bGwsXG4gIG9uRWRnZTogbnVsbCxcbiAgb25Jbml0OiBudWxsLFxuICBvbkxhenlMb2FkRXJyb3I6IG51bGwsXG4gIG9uUmVJbml0OiBudWxsLFxuICBwYXVzZU9uRG90c0hvdmVyOiBmYWxzZSxcbiAgcGF1c2VPbkZvY3VzOiBmYWxzZSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICBwcmV2QXJyb3c6IG51bGwsXG4gIHJlc3BvbnNpdmU6IG51bGwsXG4gIHJvd3M6IDEsXG4gIHJ0bDogZmFsc2UsXG4gIHNsaWRlOiBcImRpdlwiLFxuICBzbGlkZXNQZXJSb3c6IDEsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBzbGlkZXNUb1Nob3c6IDEsXG4gIHNwZWVkOiA1MDAsXG4gIHN3aXBlOiB0cnVlLFxuICBzd2lwZUV2ZW50OiBudWxsLFxuICBzd2lwZVRvU2xpZGU6IGZhbHNlLFxuICB0b3VjaE1vdmU6IHRydWUsXG4gIHRvdWNoVGhyZXNob2xkOiA1LFxuICB1c2VDU1M6IHRydWUsXG4gIHVzZVRyYW5zZm9ybTogdHJ1ZSxcbiAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2FpdEZvckFuaW1hdGU6IHRydWVcbn07XG52YXIgX2RlZmF1bHQgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHRQcm9wcyIsImFjY2Vzc2liaWxpdHkiLCJhZGFwdGl2ZUhlaWdodCIsImFmdGVyQ2hhbmdlIiwiYXBwZW5kRG90cyIsImRvdHMiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYXJyb3dzIiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwiYmVmb3JlQ2hhbmdlIiwiY2VudGVyTW9kZSIsImNlbnRlclBhZGRpbmciLCJjbGFzc05hbWUiLCJjc3NFYXNlIiwiY3VzdG9tUGFnaW5nIiwiaSIsImRvdHNDbGFzcyIsImRyYWdnYWJsZSIsImVhc2luZyIsImVkZ2VGcmljdGlvbiIsImZhZGUiLCJmb2N1c09uU2VsZWN0IiwiaW5maW5pdGUiLCJpbml0aWFsU2xpZGUiLCJsYXp5TG9hZCIsIm5leHRBcnJvdyIsIm9uRWRnZSIsIm9uSW5pdCIsIm9uTGF6eUxvYWRFcnJvciIsIm9uUmVJbml0IiwicGF1c2VPbkRvdHNIb3ZlciIsInBhdXNlT25Gb2N1cyIsInBhdXNlT25Ib3ZlciIsInByZXZBcnJvdyIsInJlc3BvbnNpdmUiLCJyb3dzIiwicnRsIiwic2xpZGUiLCJzbGlkZXNQZXJSb3ciLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsInNwZWVkIiwic3dpcGUiLCJzd2lwZUV2ZW50Iiwic3dpcGVUb1NsaWRlIiwidG91Y2hNb3ZlIiwidG91Y2hUaHJlc2hvbGQiLCJ1c2VDU1MiLCJ1c2VUcmFuc2Zvcm0iLCJ2YXJpYWJsZVdpZHRoIiwidmVydGljYWwiLCJ3YWl0Rm9yQW5pbWF0ZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/dots.js":
/*!**********************************************!*\
  !*** ./node_modules/react-slick/lib/dots.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Dots = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nvar getDotCount = function getDotCount(spec) {\n    var dots;\n    if (spec.infinite) {\n        dots = Math.ceil(spec.slideCount / spec.slidesToScroll);\n    } else {\n        dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;\n    }\n    return dots;\n};\nvar Dots = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Dots, _React$PureComponent);\n    var _super = _createSuper(Dots);\n    function Dots() {\n        _classCallCheck(this, Dots);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Dots, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                // In Autoplay the focus stays on clicked button even after transition\n                // to next slide. That only goes away by click somewhere outside\n                e.preventDefault();\n                this.props.clickHandler(options);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;\n                var dotCount = getDotCount({\n                    slideCount: slideCount,\n                    slidesToScroll: slidesToScroll,\n                    slidesToShow: slidesToShow,\n                    infinite: infinite\n                });\n                var mouseEvents = {\n                    onMouseEnter: onMouseEnter,\n                    onMouseOver: onMouseOver,\n                    onMouseLeave: onMouseLeave\n                };\n                var dots = [];\n                for(var i = 0; i < dotCount; i++){\n                    var _rightBound = (i + 1) * slidesToScroll - 1;\n                    var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);\n                    var _leftBound = rightBound - (slidesToScroll - 1);\n                    var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);\n                    var className = (0, _classnames[\"default\"])({\n                        \"slick-active\": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound\n                    });\n                    var dotOptions = {\n                        message: \"dots\",\n                        index: i,\n                        slidesToScroll: slidesToScroll,\n                        currentSlide: currentSlide\n                    };\n                    var onClick = this.clickHandler.bind(this, dotOptions);\n                    dots = dots.concat(/*#__PURE__*/ _react[\"default\"].createElement(\"li\", {\n                        key: i,\n                        className: className\n                    }, /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.customPaging(i), {\n                        onClick: onClick\n                    })));\n                }\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.appendDots(dots), _objectSpread({\n                    className: this.props.dotsClass\n                }, mouseEvents));\n            }\n        }\n    ]);\n    return Dots;\n}(_react[\"default\"].PureComponent);\nexports.Dots = Dots;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZG90cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLEdBQUc7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixHQUFHO1FBQUksT0FBTyxPQUFPQTtJQUFLLElBQUksU0FBVUEsR0FBRztRQUFJLE9BQU9BLE9BQU8sY0FBYyxPQUFPQyxVQUFVRCxJQUFJRyxXQUFXLEtBQUtGLFVBQVVELFFBQVFDLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUssR0FBR0QsUUFBUUM7QUFBTTtBQUUvVUssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBRyxLQUFLO0FBRXBCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsbUZBQU87QUFFbkQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQywwRUFBWTtBQUU3RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLDhHQUEwQjtBQUUxRCxTQUFTRCx1QkFBdUJYLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJZSxVQUFVLEdBQUdmLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsU0FBU2dCLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9kLE9BQU9jLElBQUksQ0FBQ0Y7SUFBUyxJQUFJWixPQUFPZSxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVoQixPQUFPZSxxQkFBcUIsQ0FBQ0g7UUFBU0Msa0JBQW1CRyxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUFJLE9BQU9sQixPQUFPbUIsd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtFLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEtBQUtPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixN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ckVqRixLQUFLTDt3QkFDTCtFLFdBQVdBO29CQUNiLEdBQUcsV0FBVyxHQUFFbkcsTUFBTSxDQUFDLFVBQVUsQ0FBQzJHLFlBQVksQ0FBQyxJQUFJLENBQUN2RSxLQUFLLENBQUN3RSxZQUFZLENBQUN4RixJQUFJO3dCQUN6RW1GLFNBQVNBO29CQUNYO2dCQUNGO2dCQUVBLE9BQU8sV0FBVyxHQUFFdkcsTUFBTSxDQUFDLFVBQVUsQ0FBQzJHLFlBQVksQ0FBQyxJQUFJLENBQUN2RSxLQUFLLENBQUN5RSxVQUFVLENBQUNuQyxPQUFPeEQsY0FBYztvQkFDNUZpRixXQUFXLElBQUksQ0FBQy9ELEtBQUssQ0FBQzBFLFNBQVM7Z0JBQ2pDLEdBQUdqQjtZQUNMO1FBQ0Y7S0FBRTtJQUVGLE9BQU85RjtBQUNULEVBQUVDLE1BQU0sQ0FBQyxVQUFVLENBQUMrRyxhQUFhO0FBRWpDbEgsWUFBWSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2RvdHMuanM/ZWZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Eb3RzID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxudmFyIF9pbm5lclNsaWRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvaW5uZXJTbGlkZXJVdGlsc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgZ2V0RG90Q291bnQgPSBmdW5jdGlvbiBnZXREb3RDb3VudChzcGVjKSB7XG4gIHZhciBkb3RzO1xuXG4gIGlmIChzcGVjLmluZmluaXRlKSB7XG4gICAgZG90cyA9IE1hdGguY2VpbChzcGVjLnNsaWRlQ291bnQgLyBzcGVjLnNsaWRlc1RvU2Nyb2xsKTtcbiAgfSBlbHNlIHtcbiAgICBkb3RzID0gTWF0aC5jZWlsKChzcGVjLnNsaWRlQ291bnQgLSBzcGVjLnNsaWRlc1RvU2hvdykgLyBzcGVjLnNsaWRlc1RvU2Nyb2xsKSArIDE7XG4gIH1cblxuICByZXR1cm4gZG90cztcbn07XG5cbnZhciBEb3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRG90cywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG90cyk7XG5cbiAgZnVuY3Rpb24gRG90cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90cyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRG90cywgW3tcbiAgICBrZXk6IFwiY2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zLCBlKSB7XG4gICAgICAvLyBJbiBBdXRvcGxheSB0aGUgZm9jdXMgc3RheXMgb24gY2xpY2tlZCBidXR0b24gZXZlbiBhZnRlciB0cmFuc2l0aW9uXG4gICAgICAvLyB0byBuZXh0IHNsaWRlLiBUaGF0IG9ubHkgZ29lcyBhd2F5IGJ5IGNsaWNrIHNvbWV3aGVyZSBvdXRzaWRlXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnByb3BzLmNsaWNrSGFuZGxlcihvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICAgIG9uTW91c2VPdmVyID0gX3RoaXMkcHJvcHMub25Nb3VzZU92ZXIsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICAgIGluZmluaXRlID0gX3RoaXMkcHJvcHMuaW5maW5pdGUsXG4gICAgICAgICAgc2xpZGVzVG9TY3JvbGwgPSBfdGhpcyRwcm9wcy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICBzbGlkZXNUb1Nob3cgPSBfdGhpcyRwcm9wcy5zbGlkZXNUb1Nob3csXG4gICAgICAgICAgc2xpZGVDb3VudCA9IF90aGlzJHByb3BzLnNsaWRlQ291bnQsXG4gICAgICAgICAgY3VycmVudFNsaWRlID0gX3RoaXMkcHJvcHMuY3VycmVudFNsaWRlO1xuICAgICAgdmFyIGRvdENvdW50ID0gZ2V0RG90Q291bnQoe1xuICAgICAgICBzbGlkZUNvdW50OiBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbDogc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogc2xpZGVzVG9TaG93LFxuICAgICAgICBpbmZpbml0ZTogaW5maW5pdGVcbiAgICAgIH0pO1xuICAgICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXI6IG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICAgICAgfTtcbiAgICAgIHZhciBkb3RzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG90Q291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX3JpZ2h0Qm91bmQgPSAoaSArIDEpICogc2xpZGVzVG9TY3JvbGwgLSAxO1xuXG4gICAgICAgIHZhciByaWdodEJvdW5kID0gaW5maW5pdGUgPyBfcmlnaHRCb3VuZCA6ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5jbGFtcCkoX3JpZ2h0Qm91bmQsIDAsIHNsaWRlQ291bnQgLSAxKTtcblxuICAgICAgICB2YXIgX2xlZnRCb3VuZCA9IHJpZ2h0Qm91bmQgLSAoc2xpZGVzVG9TY3JvbGwgLSAxKTtcblxuICAgICAgICB2YXIgbGVmdEJvdW5kID0gaW5maW5pdGUgPyBfbGVmdEJvdW5kIDogKDAsIF9pbm5lclNsaWRlclV0aWxzLmNsYW1wKShfbGVmdEJvdW5kLCAwLCBzbGlkZUNvdW50IC0gMSk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgXCJzbGljay1hY3RpdmVcIjogaW5maW5pdGUgPyBjdXJyZW50U2xpZGUgPj0gbGVmdEJvdW5kICYmIGN1cnJlbnRTbGlkZSA8PSByaWdodEJvdW5kIDogY3VycmVudFNsaWRlID09PSBsZWZ0Qm91bmRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkb3RPcHRpb25zID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiZG90c1wiLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbGljayA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcywgZG90T3B0aW9ucyk7XG4gICAgICAgIGRvdHMgPSBkb3RzLmNvbmNhdCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY3VzdG9tUGFnaW5nKGkpLCB7XG4gICAgICAgICAgb25DbGljazogb25DbGlja1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuYXBwZW5kRG90cyhkb3RzKSwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5kb3RzQ2xhc3NcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvdHM7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydHMuRG90cyA9IERvdHM7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEb3RzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xhc3NuYW1lcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX19lc01vZHVsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXREb3RDb3VudCIsInNwZWMiLCJkb3RzIiwiaW5maW5pdGUiLCJNYXRoIiwiY2VpbCIsInNsaWRlQ291bnQiLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsIl9SZWFjdCRQdXJlQ29tcG9uZW50IiwiX3N1cGVyIiwiY2xpY2tIYW5kbGVyIiwib3B0aW9ucyIsInByZXZlbnREZWZhdWx0IiwicmVuZGVyIiwiX3RoaXMkcHJvcHMiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VMZWF2ZSIsImN1cnJlbnRTbGlkZSIsImRvdENvdW50IiwibW91c2VFdmVudHMiLCJfcmlnaHRCb3VuZCIsInJpZ2h0Qm91bmQiLCJjbGFtcCIsIl9sZWZ0Qm91bmQiLCJsZWZ0Qm91bmQiLCJjbGFzc05hbWUiLCJkb3RPcHRpb25zIiwibWVzc2FnZSIsImluZGV4Iiwib25DbGljayIsImJpbmQiLCJjb25jYXQiLCJjcmVhdGVFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3VzdG9tUGFnaW5nIiwiYXBwZW5kRG90cyIsImRvdHNDbGFzcyIsIlB1cmVDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/dots.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _slider = _interopRequireDefault(__webpack_require__(/*! ./slider */ \"(app-pages-browser)/./node_modules/react-slick/lib/slider.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar _default = _slider[\"default\"];\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHLEtBQUs7QUFFMUIsSUFBSUUsVUFBVUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyw4RUFBVTtBQUV2RCxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsSUFBSUUsV0FBV0wsT0FBTyxDQUFDLFVBQVU7QUFDakNGLGtCQUFrQixHQUFHTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2luZGV4LmpzP2EwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9zbGlkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NsaWRlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgX2RlZmF1bHQgPSBfc2xpZGVyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3NsaWRlciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/initial-state.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar initialState = {\n    animating: false,\n    autoplaying: null,\n    currentDirection: 0,\n    currentLeft: null,\n    currentSlide: 0,\n    direction: 1,\n    dragging: false,\n    edgeDragged: false,\n    initialized: false,\n    lazyLoadedList: [],\n    listHeight: null,\n    listWidth: null,\n    scrolling: false,\n    slideCount: null,\n    slideHeight: null,\n    slideWidth: null,\n    swipeLeft: null,\n    swiped: false,\n    // used by swipeEvent. differentites between touch and swipe.\n    swiping: false,\n    touchObject: {\n        startX: 0,\n        startY: 0,\n        curX: 0,\n        curY: 0\n    },\n    trackStyle: {},\n    trackWidth: 0,\n    targetSlide: 0\n};\nvar _default = initialState;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5pdGlhbC1zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixJQUFJRSxlQUFlO0lBQ2pCQyxXQUFXO0lBQ1hDLGFBQWE7SUFDYkMsa0JBQWtCO0lBQ2xCQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxnQkFBZ0IsRUFBRTtJQUNsQkMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxRQUFRO0lBQ1IsNkRBQTZEO0lBQzdEQyxTQUFTO0lBQ1RDLGFBQWE7UUFDWEMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLE1BQU07UUFDTkMsTUFBTTtJQUNSO0lBQ0FDLFlBQVksQ0FBQztJQUNiQyxZQUFZO0lBQ1pDLGFBQWE7QUFDZjtBQUNBLElBQUlDLFdBQVc1QjtBQUNmRixrQkFBa0IsR0FBRzhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5pdGlhbC1zdGF0ZS5qcz82MzU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBhbmltYXRpbmc6IGZhbHNlLFxuICBhdXRvcGxheWluZzogbnVsbCxcbiAgY3VycmVudERpcmVjdGlvbjogMCxcbiAgY3VycmVudExlZnQ6IG51bGwsXG4gIGN1cnJlbnRTbGlkZTogMCxcbiAgZGlyZWN0aW9uOiAxLFxuICBkcmFnZ2luZzogZmFsc2UsXG4gIGVkZ2VEcmFnZ2VkOiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBsYXp5TG9hZGVkTGlzdDogW10sXG4gIGxpc3RIZWlnaHQ6IG51bGwsXG4gIGxpc3RXaWR0aDogbnVsbCxcbiAgc2Nyb2xsaW5nOiBmYWxzZSxcbiAgc2xpZGVDb3VudDogbnVsbCxcbiAgc2xpZGVIZWlnaHQ6IG51bGwsXG4gIHNsaWRlV2lkdGg6IG51bGwsXG4gIHN3aXBlTGVmdDogbnVsbCxcbiAgc3dpcGVkOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzd2lwZUV2ZW50LiBkaWZmZXJlbnRpdGVzIGJldHdlZW4gdG91Y2ggYW5kIHN3aXBlLlxuICBzd2lwaW5nOiBmYWxzZSxcbiAgdG91Y2hPYmplY3Q6IHtcbiAgICBzdGFydFg6IDAsXG4gICAgc3RhcnRZOiAwLFxuICAgIGN1clg6IDAsXG4gICAgY3VyWTogMFxuICB9LFxuICB0cmFja1N0eWxlOiB7fSxcbiAgdHJhY2tXaWR0aDogMCxcbiAgdGFyZ2V0U2xpZGU6IDBcbn07XG52YXIgX2RlZmF1bHQgPSBpbml0aWFsU3RhdGU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxTdGF0ZSIsImFuaW1hdGluZyIsImF1dG9wbGF5aW5nIiwiY3VycmVudERpcmVjdGlvbiIsImN1cnJlbnRMZWZ0IiwiY3VycmVudFNsaWRlIiwiZGlyZWN0aW9uIiwiZHJhZ2dpbmciLCJlZGdlRHJhZ2dlZCIsImluaXRpYWxpemVkIiwibGF6eUxvYWRlZExpc3QiLCJsaXN0SGVpZ2h0IiwibGlzdFdpZHRoIiwic2Nyb2xsaW5nIiwic2xpZGVDb3VudCIsInNsaWRlSGVpZ2h0Iiwic2xpZGVXaWR0aCIsInN3aXBlTGVmdCIsInN3aXBlZCIsInN3aXBpbmciLCJ0b3VjaE9iamVjdCIsInN0YXJ0WCIsInN0YXJ0WSIsImN1clgiLCJjdXJZIiwidHJhY2tTdHlsZSIsInRyYWNrV2lkdGgiLCJ0YXJnZXRTbGlkZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js":
/*!******************************************************!*\
  !*** ./node_modules/react-slick/lib/inner-slider.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InnerSlider = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _initialState = _interopRequireDefault(__webpack_require__(/*! ./initial-state */ \"(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js\"));\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.debounce */ \"(app-pages-browser)/./node_modules/lodash.debounce/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nvar _track = __webpack_require__(/*! ./track */ \"(app-pages-browser)/./node_modules/react-slick/lib/track.js\");\nvar _dots = __webpack_require__(/*! ./dots */ \"(app-pages-browser)/./node_modules/react-slick/lib/dots.js\");\nvar _arrows = __webpack_require__(/*! ./arrows */ \"(app-pages-browser)/./node_modules/react-slick/lib/arrows.js\");\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar InnerSlider = /*#__PURE__*/ function(_React$Component) {\n    _inherits(InnerSlider, _React$Component);\n    var _super = _createSuper(InnerSlider);\n    function InnerSlider(props) {\n        var _this;\n        _classCallCheck(this, InnerSlider);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"listRefHandler\", function(ref) {\n            return _this.list = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"trackRefHandler\", function(ref) {\n            return _this.track = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"adaptHeight\", function() {\n            if (_this.props.adaptiveHeight && _this.list) {\n                var elem = _this.list.querySelector('[data-index=\"'.concat(_this.state.currentSlide, '\"]'));\n                _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + \"px\";\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function() {\n            _this.props.onInit && _this.props.onInit();\n            if (_this.props.lazyLoad) {\n                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n                if (slidesToLoad.length > 0) {\n                    _this.setState(function(prevState) {\n                        return {\n                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                        };\n                    });\n                    if (_this.props.onLazyLoad) {\n                        _this.props.onLazyLoad(slidesToLoad);\n                    }\n                }\n            }\n            var spec = _objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props);\n            _this.updateState(spec, true, function() {\n                _this.adaptHeight();\n                _this.props.autoplay && _this.autoPlay(\"update\");\n            });\n            if (_this.props.lazyLoad === \"progressive\") {\n                _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1000);\n            }\n            _this.ro = new _resizeObserverPolyfill[\"default\"](function() {\n                if (_this.state.animating) {\n                    _this.onWindowResized(false); // don't set trackStyle hence don't break animation\n                    _this.callbackTimers.push(setTimeout(function() {\n                        return _this.onWindowResized();\n                    }, _this.props.speed));\n                } else {\n                    _this.onWindowResized();\n                }\n            });\n            _this.ro.observe(_this.list);\n            document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), function(slide) {\n                slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;\n                slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;\n            });\n            if (window.addEventListener) {\n                window.addEventListener(\"resize\", _this.onWindowResized);\n            } else {\n                window.attachEvent(\"onresize\", _this.onWindowResized);\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function() {\n            if (_this.animationEndCallback) {\n                clearTimeout(_this.animationEndCallback);\n            }\n            if (_this.lazyLoadTimer) {\n                clearInterval(_this.lazyLoadTimer);\n            }\n            if (_this.callbackTimers.length) {\n                _this.callbackTimers.forEach(function(timer) {\n                    return clearTimeout(timer);\n                });\n                _this.callbackTimers = [];\n            }\n            if (window.addEventListener) {\n                window.removeEventListener(\"resize\", _this.onWindowResized);\n            } else {\n                window.detachEvent(\"onresize\", _this.onWindowResized);\n            }\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n            }\n            _this.ro.disconnect();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function(prevProps) {\n            _this.checkImagesLoad();\n            _this.props.onReInit && _this.props.onReInit();\n            if (_this.props.lazyLoad) {\n                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n                if (slidesToLoad.length > 0) {\n                    _this.setState(function(prevState) {\n                        return {\n                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                        };\n                    });\n                    if (_this.props.onLazyLoad) {\n                        _this.props.onLazyLoad(slidesToLoad);\n                    }\n                }\n            } // if (this.props.onLazyLoad) {\n            //   this.props.onLazyLoad([leftMostSlide])\n            // }\n            _this.adaptHeight();\n            var spec = _objectSpread(_objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props), _this.state);\n            var setTrackStyle = _this.didPropsChange(prevProps);\n            setTrackStyle && _this.updateState(spec, setTrackStyle, function() {\n                if (_this.state.currentSlide >= _react[\"default\"].Children.count(_this.props.children)) {\n                    _this.changeSlide({\n                        message: \"index\",\n                        index: _react[\"default\"].Children.count(_this.props.children) - _this.props.slidesToShow,\n                        currentSlide: _this.state.currentSlide\n                    });\n                }\n                if (_this.props.autoplay) {\n                    _this.autoPlay(\"update\");\n                } else {\n                    _this.pause(\"paused\");\n                }\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onWindowResized\", function(setTrackStyle) {\n            if (_this.debouncedResize) _this.debouncedResize.cancel();\n            _this.debouncedResize = (0, _lodash[\"default\"])(function() {\n                return _this.resizeWindow(setTrackStyle);\n            }, 50);\n            _this.debouncedResize();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"resizeWindow\", function() {\n            var setTrackStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            var isTrackMounted = Boolean(_this.track && _this.track.node); // prevent warning: setting state on unmounted component (server side rendering)\n            if (!isTrackMounted) return;\n            var spec = _objectSpread(_objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props), _this.state);\n            _this.updateState(spec, setTrackStyle, function() {\n                if (_this.props.autoplay) _this.autoPlay(\"update\");\n                else _this.pause(\"paused\");\n            }); // animating state should be cleared while resizing, otherwise autoplay stops working\n            _this.setState({\n                animating: false\n            });\n            clearTimeout(_this.animationEndCallback);\n            delete _this.animationEndCallback;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"updateState\", function(spec, setTrackStyle, callback) {\n            var updatedState = (0, _innerSliderUtils.initializedState)(spec);\n            spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n                slideIndex: updatedState.currentSlide\n            });\n            var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);\n            spec = _objectSpread(_objectSpread({}, spec), {}, {\n                left: targetLeft\n            });\n            var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);\n            if (setTrackStyle || _react[\"default\"].Children.count(_this.props.children) !== _react[\"default\"].Children.count(spec.children)) {\n                updatedState[\"trackStyle\"] = trackStyle;\n            }\n            _this.setState(updatedState, callback);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"ssrInit\", function() {\n            if (_this.props.variableWidth) {\n                var _trackWidth = 0, _trackLeft = 0;\n                var childrenWidths = [];\n                var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                    slideCount: _this.props.children.length\n                }));\n                var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                    slideCount: _this.props.children.length\n                }));\n                _this.props.children.forEach(function(child) {\n                    childrenWidths.push(child.props.style.width);\n                    _trackWidth += child.props.style.width;\n                });\n                for(var i = 0; i < preClones; i++){\n                    _trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n                    _trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n                }\n                for(var _i = 0; _i < postClones; _i++){\n                    _trackWidth += childrenWidths[_i];\n                }\n                for(var _i2 = 0; _i2 < _this.state.currentSlide; _i2++){\n                    _trackLeft += childrenWidths[_i2];\n                }\n                var _trackStyle = {\n                    width: _trackWidth + \"px\",\n                    left: -_trackLeft + \"px\"\n                };\n                if (_this.props.centerMode) {\n                    var currentWidth = \"\".concat(childrenWidths[_this.state.currentSlide], \"px\");\n                    _trackStyle.left = \"calc(\".concat(_trackStyle.left, \" + (100% - \").concat(currentWidth, \") / 2 ) \");\n                }\n                return {\n                    trackStyle: _trackStyle\n                };\n            }\n            var childrenCount = _react[\"default\"].Children.count(_this.props.children);\n            var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                slideCount: childrenCount\n            });\n            var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;\n            var trackWidth = 100 / _this.props.slidesToShow * slideCount;\n            var slideWidth = 100 / slideCount;\n            var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;\n            if (_this.props.centerMode) {\n                trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n            }\n            var trackStyle = {\n                width: trackWidth + \"%\",\n                left: trackLeft + \"%\"\n            };\n            return {\n                slideWidth: slideWidth + \"%\",\n                trackStyle: trackStyle\n            };\n        });\n        _defineProperty(_assertThisInitialized(_this), \"checkImagesLoad\", function() {\n            var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(\".slick-slide img\") || [];\n            var imagesCount = images.length, loadedCount = 0;\n            Array.prototype.forEach.call(images, function(image) {\n                var handler = function handler() {\n                    return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();\n                };\n                if (!image.onclick) {\n                    image.onclick = function() {\n                        return image.parentNode.focus();\n                    };\n                } else {\n                    var prevClickHandler = image.onclick;\n                    image.onclick = function(e) {\n                        prevClickHandler(e);\n                        image.parentNode.focus();\n                    };\n                }\n                if (!image.onload) {\n                    if (_this.props.lazyLoad) {\n                        image.onload = function() {\n                            _this.adaptHeight();\n                            _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));\n                        };\n                    } else {\n                        image.onload = handler;\n                        image.onerror = function() {\n                            handler();\n                            _this.props.onLazyLoadError && _this.props.onLazyLoadError();\n                        };\n                    }\n                }\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"progressiveLazyLoad\", function() {\n            var slidesToLoad = [];\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            for(var index = _this.state.currentSlide; index < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index++){\n                if (_this.state.lazyLoadedList.indexOf(index) < 0) {\n                    slidesToLoad.push(index);\n                    break;\n                }\n            }\n            for(var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--){\n                if (_this.state.lazyLoadedList.indexOf(_index) < 0) {\n                    slidesToLoad.push(_index);\n                    break;\n                }\n            }\n            if (slidesToLoad.length > 0) {\n                _this.setState(function(state) {\n                    return {\n                        lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n                    };\n                });\n                if (_this.props.onLazyLoad) {\n                    _this.props.onLazyLoad(slidesToLoad);\n                }\n            } else {\n                if (_this.lazyLoadTimer) {\n                    clearInterval(_this.lazyLoadTimer);\n                    delete _this.lazyLoadTimer;\n                }\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slideHandler\", function(index) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange; // capture currentslide before state is updated\n            var currentSlide = _this.state.currentSlide;\n            var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({\n                index: index\n            }, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                useCSS: _this.props.useCSS && !dontAnimate\n            })), state = _slideHandler.state, nextState = _slideHandler.nextState;\n            if (!state) return;\n            beforeChange && beforeChange(currentSlide, state.currentSlide);\n            var slidesToLoad = state.lazyLoadedList.filter(function(value) {\n                return _this.state.lazyLoadedList.indexOf(value) < 0;\n            });\n            onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n            if (!_this.props.waitForAnimate && _this.animationEndCallback) {\n                clearTimeout(_this.animationEndCallback);\n                afterChange && afterChange(currentSlide);\n                delete _this.animationEndCallback;\n            }\n            _this.setState(state, function() {\n                // asNavForIndex check is to avoid recursive calls of slideHandler in waitForAnimate=false mode\n                if (asNavFor && _this.asNavForIndex !== index) {\n                    _this.asNavForIndex = index;\n                    asNavFor.innerSlider.slideHandler(index);\n                }\n                if (!nextState) return;\n                _this.animationEndCallback = setTimeout(function() {\n                    var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, [\n                        \"animating\"\n                    ]);\n                    _this.setState(firstBatch, function() {\n                        _this.callbackTimers.push(setTimeout(function() {\n                            return _this.setState({\n                                animating: animating\n                            });\n                        }, 10));\n                        afterChange && afterChange(state.currentSlide);\n                        delete _this.animationEndCallback;\n                    });\n                }, speed);\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"changeSlide\", function(options) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);\n            if (targetSlide !== 0 && !targetSlide) return;\n            if (dontAnimate === true) {\n                _this.slideHandler(targetSlide, dontAnimate);\n            } else {\n                _this.slideHandler(targetSlide);\n            }\n            _this.props.autoplay && _this.autoPlay(\"update\");\n            if (_this.props.focusOnSelect) {\n                var nodes = _this.list.querySelectorAll(\".slick-current\");\n                nodes[0] && nodes[0].focus();\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"clickHandler\", function(e) {\n            if (_this.clickable === false) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"keyHandler\", function(e) {\n            var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);\n            dir !== \"\" && _this.changeSlide({\n                message: dir\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"selectHandler\", function(options) {\n            _this.changeSlide(options);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"disableBodyScroll\", function() {\n            var preventDefault = function preventDefault(e) {\n                e = e || window.event;\n                if (e.preventDefault) e.preventDefault();\n                e.returnValue = false;\n            };\n            window.ontouchmove = preventDefault;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"enableBodyScroll\", function() {\n            window.ontouchmove = null;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeStart\", function(e) {\n            if (_this.props.verticalSwiping) {\n                _this.disableBodyScroll();\n            }\n            var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);\n            state !== \"\" && _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeMove\", function(e) {\n            var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                listRef: _this.list,\n                slideIndex: _this.state.currentSlide\n            }));\n            if (!state) return;\n            if (state[\"swiping\"]) {\n                _this.clickable = false;\n            }\n            _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeEnd\", function(e) {\n            var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                listRef: _this.list,\n                slideIndex: _this.state.currentSlide\n            }));\n            if (!state) return;\n            var triggerSlideHandler = state[\"triggerSlideHandler\"];\n            delete state[\"triggerSlideHandler\"];\n            _this.setState(state);\n            if (triggerSlideHandler === undefined) return;\n            _this.slideHandler(triggerSlideHandler);\n            if (_this.props.verticalSwiping) {\n                _this.enableBodyScroll();\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"touchEnd\", function(e) {\n            _this.swipeEnd(e);\n            _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n            // this and fellow methods are wrapped in setTimeout\n            // to make sure initialize setState has happened before\n            // any of such methods are called\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"previous\"\n                });\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"next\"\n                });\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            slide = Number(slide);\n            if (isNaN(slide)) return \"\";\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"index\",\n                    index: slide,\n                    currentSlide: _this.state.currentSlide\n                }, dontAnimate);\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"play\", function() {\n            var nextIndex;\n            if (_this.props.rtl) {\n                nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;\n            } else {\n                if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {\n                    nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;\n                } else {\n                    return false;\n                }\n            }\n            _this.slideHandler(nextIndex);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function(playType) {\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n            }\n            var autoplaying = _this.state.autoplaying;\n            if (playType === \"update\") {\n                if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n                    return;\n                }\n            } else if (playType === \"leave\") {\n                if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n                    return;\n                }\n            } else if (playType === \"blur\") {\n                if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n                    return;\n                }\n            }\n            _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);\n            _this.setState({\n                autoplaying: \"playing\"\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"pause\", function(pauseType) {\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n                _this.autoplayTimer = null;\n            }\n            var autoplaying = _this.state.autoplaying;\n            if (pauseType === \"paused\") {\n                _this.setState({\n                    autoplaying: \"paused\"\n                });\n            } else if (pauseType === \"focused\") {\n                if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n                    _this.setState({\n                        autoplaying: \"focused\"\n                    });\n                }\n            } else {\n                // pauseType  is 'hovered'\n                if (autoplaying === \"playing\") {\n                    _this.setState({\n                        autoplaying: \"hovered\"\n                    });\n                }\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsOver\", function() {\n            return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsLeave\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackOver\", function() {\n            return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackLeave\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideFocus\", function() {\n            return _this.props.autoplay && _this.pause(\"focused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideBlur\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"focused\" && _this.autoPlay(\"blur\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"render\", function() {\n            var className = (0, _classnames[\"default\"])(\"slick-slider\", _this.props.className, {\n                \"slick-vertical\": _this.props.vertical,\n                \"slick-initialized\": true\n            });\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            var trackProps = (0, _innerSliderUtils.extractObject)(spec, [\n                \"fade\",\n                \"cssEase\",\n                \"speed\",\n                \"infinite\",\n                \"centerMode\",\n                \"focusOnSelect\",\n                \"currentSlide\",\n                \"lazyLoad\",\n                \"lazyLoadedList\",\n                \"rtl\",\n                \"slideWidth\",\n                \"slideHeight\",\n                \"listHeight\",\n                \"vertical\",\n                \"slidesToShow\",\n                \"slidesToScroll\",\n                \"slideCount\",\n                \"trackStyle\",\n                \"variableWidth\",\n                \"unslick\",\n                \"centerPadding\",\n                \"targetSlide\",\n                \"useCSS\"\n            ]);\n            var pauseOnHover = _this.props.pauseOnHover;\n            trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n                onMouseEnter: pauseOnHover ? _this.onTrackOver : null,\n                onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,\n                onMouseOver: pauseOnHover ? _this.onTrackOver : null,\n                focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null\n            });\n            var dots;\n            if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {\n                var dotProps = (0, _innerSliderUtils.extractObject)(spec, [\n                    \"dotsClass\",\n                    \"slideCount\",\n                    \"slidesToShow\",\n                    \"currentSlide\",\n                    \"slidesToScroll\",\n                    \"clickHandler\",\n                    \"children\",\n                    \"customPaging\",\n                    \"infinite\",\n                    \"appendDots\"\n                ]);\n                var pauseOnDotsHover = _this.props.pauseOnDotsHover;\n                dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n                    clickHandler: _this.changeSlide,\n                    onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,\n                    onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,\n                    onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null\n                });\n                dots = /*#__PURE__*/ _react[\"default\"].createElement(_dots.Dots, dotProps);\n            }\n            var prevArrow, nextArrow;\n            var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [\n                \"infinite\",\n                \"centerMode\",\n                \"currentSlide\",\n                \"slideCount\",\n                \"slidesToShow\",\n                \"prevArrow\",\n                \"nextArrow\"\n            ]);\n            arrowProps.clickHandler = _this.changeSlide;\n            if (_this.props.arrows) {\n                prevArrow = /*#__PURE__*/ _react[\"default\"].createElement(_arrows.PrevArrow, arrowProps);\n                nextArrow = /*#__PURE__*/ _react[\"default\"].createElement(_arrows.NextArrow, arrowProps);\n            }\n            var verticalHeightStyle = null;\n            if (_this.props.vertical) {\n                verticalHeightStyle = {\n                    height: _this.state.listHeight\n                };\n            }\n            var centerPaddingStyle = null;\n            if (_this.props.vertical === false) {\n                if (_this.props.centerMode === true) {\n                    centerPaddingStyle = {\n                        padding: \"0px \" + _this.props.centerPadding\n                    };\n                }\n            } else {\n                if (_this.props.centerMode === true) {\n                    centerPaddingStyle = {\n                        padding: _this.props.centerPadding + \" 0px\"\n                    };\n                }\n            }\n            var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n            var touchMove = _this.props.touchMove;\n            var listProps = {\n                className: \"slick-list\",\n                style: listStyle,\n                onClick: _this.clickHandler,\n                onMouseDown: touchMove ? _this.swipeStart : null,\n                onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n                onMouseUp: touchMove ? _this.swipeEnd : null,\n                onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n                onTouchStart: touchMove ? _this.swipeStart : null,\n                onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n                onTouchEnd: touchMove ? _this.touchEnd : null,\n                onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n                onKeyDown: _this.props.accessibility ? _this.keyHandler : null\n            };\n            var innerSliderProps = {\n                className: className,\n                dir: \"ltr\",\n                style: _this.props.style\n            };\n            if (_this.props.unslick) {\n                listProps = {\n                    className: \"slick-list\"\n                };\n                innerSliderProps = {\n                    className: className\n                };\n            }\n            return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", innerSliderProps, !_this.props.unslick ? prevArrow : \"\", /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                ref: _this.listRefHandler\n            }, listProps), /*#__PURE__*/ _react[\"default\"].createElement(_track.Track, _extends({\n                ref: _this.trackRefHandler\n            }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : \"\", !_this.props.unslick ? dots : \"\");\n        });\n        _this.list = null;\n        _this.track = null;\n        _this.state = _objectSpread(_objectSpread({}, _initialState[\"default\"]), {}, {\n            currentSlide: _this.props.initialSlide,\n            targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,\n            slideCount: _react[\"default\"].Children.count(_this.props.children)\n        });\n        _this.callbackTimers = [];\n        _this.clickable = true;\n        _this.debouncedResize = null;\n        var ssrState = _this.ssrInit();\n        _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);\n        return _this;\n    }\n    _createClass(InnerSlider, [\n        {\n            key: \"didPropsChange\",\n            value: function didPropsChange(prevProps) {\n                var setTrackStyle = false;\n                for(var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++){\n                    var key = _Object$keys[_i3];\n                    if (!prevProps.hasOwnProperty(key)) {\n                        setTrackStyle = true;\n                        break;\n                    }\n                    if (_typeof(prevProps[key]) === \"object\" || typeof prevProps[key] === \"function\" || isNaN(prevProps[key])) {\n                        continue;\n                    }\n                    if (prevProps[key] !== this.props[key]) {\n                        setTrackStyle = true;\n                        break;\n                    }\n                }\n                return setTrackStyle || _react[\"default\"].Children.count(this.props.children) !== _react[\"default\"].Children.count(prevProps.children);\n            }\n        }\n    ]);\n    return InnerSlider;\n}(_react[\"default\"].Component);\nexports.InnerSlider = InnerSlider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5uZXItc2xpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBRyxLQUFLO0FBRTNCLElBQUlHLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsbUZBQU87QUFFbkQsSUFBSUMsZ0JBQWdCRix1QkFBdUJDLG1CQUFPQSxDQUFDLDRGQUFpQjtBQUVwRSxJQUFJRSxVQUFVSCx1QkFBdUJDLG1CQUFPQSxDQUFDLG9GQUFpQjtBQUU5RCxJQUFJRyxjQUFjSix1QkFBdUJDLG1CQUFPQSxDQUFDLDBFQUFZO0FBRTdELElBQUlJLG9CQUFvQkosbUJBQU9BLENBQUMsOEdBQTBCO0FBRTFELElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDLDRFQUFTO0FBRTlCLElBQUlNLFFBQVFOLG1CQUFPQSxDQUFDLDBFQUFRO0FBRTVCLElBQUlPLFVBQVVQLG1CQUFPQSxDQUFDLDhFQUFVO0FBRWhDLElBQUlRLDBCQUEwQlQsdUJBQXVCQyxtQkFBT0EsQ0FBQyx1SEFBMEI7QUFFdkYsU0FBU0QsdUJBQXVCVSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLFNBQVNFLFFBQVFGLEdBQUc7SUFBSTtJQUEyQixPQUFPRSxVQUFVLGNBQWMsT0FBT0MsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVSixHQUFHO1FBQUksT0FBTyxPQUFPQTtJQUFLLElBQUksU0FBVUEsR0FBRztRQUFJLE9BQU9BLE9BQU8sY0FBYyxPQUFPRyxVQUFVSCxJQUFJSyxXQUFXLEtBQUtGLFVBQVVILFFBQVFHLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9OO0lBQUssR0FBR0UsUUFBUUY7QUFBTTtBQUUvVSxTQUFTTztJQUFhQSxXQUFXdkIs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QUVDLE1BQU0sQ0FBQyxVQUFVLENBQUMyVCxTQUFTO0FBRTdCOVQsbUJBQW1CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5uZXItc2xpZGVyLmpzP2U4YWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLklubmVyU2xpZGVyID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2luaXRpYWxTdGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5pdGlhbC1zdGF0ZVwiKSk7XG5cbnZhciBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoLmRlYm91bmNlXCIpKTtcblxudmFyIF9jbGFzc25hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSk7XG5cbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5cbnZhciBfdHJhY2sgPSByZXF1aXJlKFwiLi90cmFja1wiKTtcblxudmFyIF9kb3RzID0gcmVxdWlyZShcIi4vZG90c1wiKTtcblxudmFyIF9hcnJvd3MgPSByZXF1aXJlKFwiLi9hcnJvd3NcIik7XG5cbnZhciBfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgSW5uZXJTbGlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKElubmVyU2xpZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKElubmVyU2xpZGVyKTtcblxuICBmdW5jdGlvbiBJbm5lclNsaWRlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbm5lclNsaWRlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsaXN0UmVmSGFuZGxlclwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICByZXR1cm4gX3RoaXMubGlzdCA9IHJlZjtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0cmFja1JlZkhhbmRsZXJcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIF90aGlzLnRyYWNrID0gcmVmO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFkYXB0SGVpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGFwdGl2ZUhlaWdodCAmJiBfdGhpcy5saXN0KSB7XG4gICAgICAgIHZhciBlbGVtID0gX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtaW5kZXg9XFxcIlwiLmNvbmNhdChfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUsIFwiXFxcIl1cIikpO1xuXG4gICAgICAgIF90aGlzLmxpc3Quc3R5bGUuaGVpZ2h0ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldEhlaWdodCkoZWxlbSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY29tcG9uZW50RGlkTW91bnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucHJvcHMub25Jbml0ICYmIF90aGlzLnByb3BzLm9uSW5pdCgpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMubGF6eUxvYWQpIHtcbiAgICAgICAgdmFyIHNsaWRlc1RvTG9hZCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRPbkRlbWFuZExhenlTbGlkZXMpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSkpO1xuXG4gICAgICAgIGlmIChzbGlkZXNUb0xvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxhenlMb2FkZWRMaXN0OiBwcmV2U3RhdGUubGF6eUxvYWRlZExpc3QuY29uY2F0KHNsaWRlc1RvTG9hZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25MYXp5TG9hZCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25MYXp5TG9hZChzbGlkZXNUb0xvYWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICB0cmFja1JlZjogX3RoaXMudHJhY2tcbiAgICAgIH0sIF90aGlzLnByb3BzKTtcblxuICAgICAgX3RoaXMudXBkYXRlU3RhdGUoc3BlYywgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hZGFwdEhlaWdodCgpO1xuXG4gICAgICAgIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLmF1dG9QbGF5KFwidXBkYXRlXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5sYXp5TG9hZCA9PT0gXCJwcm9ncmVzc2l2ZVwiKSB7XG4gICAgICAgIF90aGlzLmxhenlMb2FkVGltZXIgPSBzZXRJbnRlcnZhbChfdGhpcy5wcm9ncmVzc2l2ZUxhenlMb2FkLCAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucm8gPSBuZXcgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGxbXCJkZWZhdWx0XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmFuaW1hdGluZykge1xuICAgICAgICAgIF90aGlzLm9uV2luZG93UmVzaXplZChmYWxzZSk7IC8vIGRvbid0IHNldCB0cmFja1N0eWxlIGhlbmNlIGRvbid0IGJyZWFrIGFuaW1hdGlvblxuXG5cbiAgICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uV2luZG93UmVzaXplZCgpO1xuICAgICAgICAgIH0sIF90aGlzLnByb3BzLnNwZWVkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMub25XaW5kb3dSZXNpemVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5yby5vYnNlcnZlKF90aGlzLmxpc3QpO1xuXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICYmIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zbGljay1zbGlkZVwiKSwgZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHNsaWRlLm9uZm9jdXMgPSBfdGhpcy5wcm9wcy5wYXVzZU9uRm9jdXMgPyBfdGhpcy5vblNsaWRlRm9jdXMgOiBudWxsO1xuICAgICAgICBzbGlkZS5vbmJsdXIgPSBfdGhpcy5wcm9wcy5wYXVzZU9uRm9jdXMgPyBfdGhpcy5vblNsaWRlQmx1ciA6IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF90aGlzLm9uV2luZG93UmVzaXplZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjaykge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMubGF6eUxvYWRUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmxhenlMb2FkVGltZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuY2FsbGJhY2tUaW1lcnMubGVuZ3RoKSB7XG4gICAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLmZvckVhY2goZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmRldGFjaEV2ZW50KFwib25yZXNpemVcIiwgX3RoaXMub25XaW5kb3dSZXNpemVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmF1dG9wbGF5VGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChfdGhpcy5hdXRvcGxheVRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucm8uZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvbXBvbmVudERpZFVwZGF0ZVwiLCBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICBfdGhpcy5jaGVja0ltYWdlc0xvYWQoKTtcblxuICAgICAgX3RoaXMucHJvcHMub25SZUluaXQgJiYgX3RoaXMucHJvcHMub25SZUluaXQoKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmxhenlMb2FkKSB7XG4gICAgICAgIHZhciBzbGlkZXNUb0xvYWQgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0T25EZW1hbmRMYXp5U2xpZGVzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpKTtcblxuICAgICAgICBpZiAoc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBsYXp5TG9hZGVkTGlzdDogcHJldlN0YXRlLmxhenlMb2FkZWRMaXN0LmNvbmNhdChzbGlkZXNUb0xvYWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTGF6eUxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTGF6eUxvYWQoc2xpZGVzVG9Mb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgKHRoaXMucHJvcHMub25MYXp5TG9hZCkge1xuICAgICAgLy8gICB0aGlzLnByb3BzLm9uTGF6eUxvYWQoW2xlZnRNb3N0U2xpZGVdKVxuICAgICAgLy8gfVxuXG5cbiAgICAgIF90aGlzLmFkYXB0SGVpZ2h0KCk7XG5cbiAgICAgIHZhciBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgbGlzdFJlZjogX3RoaXMubGlzdCxcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrXG4gICAgICB9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKTtcblxuICAgICAgdmFyIHNldFRyYWNrU3R5bGUgPSBfdGhpcy5kaWRQcm9wc0NoYW5nZShwcmV2UHJvcHMpO1xuXG4gICAgICBzZXRUcmFja1N0eWxlICYmIF90aGlzLnVwZGF0ZVN0YXRlKHNwZWMsIHNldFRyYWNrU3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZSA+PSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKSkge1xuICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiaW5kZXhcIixcbiAgICAgICAgICAgIGluZGV4OiBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKSAtIF90aGlzLnByb3BzLnNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMucHJvcHMuYXV0b3BsYXkpIHtcbiAgICAgICAgICBfdGhpcy5hdXRvUGxheShcInVwZGF0ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5wYXVzZShcInBhdXNlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25XaW5kb3dSZXNpemVkXCIsIGZ1bmN0aW9uIChzZXRUcmFja1N0eWxlKSB7XG4gICAgICBpZiAoX3RoaXMuZGVib3VuY2VkUmVzaXplKSBfdGhpcy5kZWJvdW5jZWRSZXNpemUuY2FuY2VsKCk7XG4gICAgICBfdGhpcy5kZWJvdW5jZWRSZXNpemUgPSAoMCwgX2xvZGFzaFtcImRlZmF1bHRcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlc2l6ZVdpbmRvdyhzZXRUcmFja1N0eWxlKTtcbiAgICAgIH0sIDUwKTtcblxuICAgICAgX3RoaXMuZGVib3VuY2VkUmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVzaXplV2luZG93XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZXRUcmFja1N0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdmFyIGlzVHJhY2tNb3VudGVkID0gQm9vbGVhbihfdGhpcy50cmFjayAmJiBfdGhpcy50cmFjay5ub2RlKTsgLy8gcHJldmVudCB3YXJuaW5nOiBzZXR0aW5nIHN0YXRlIG9uIHVubW91bnRlZCBjb21wb25lbnQgKHNlcnZlciBzaWRlIHJlbmRlcmluZylcblxuICAgICAgaWYgKCFpc1RyYWNrTW91bnRlZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGxpc3RSZWY6IF90aGlzLmxpc3QsXG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFja1xuICAgICAgfSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKHNwZWMsIHNldFRyYWNrU3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmF1dG9wbGF5KSBfdGhpcy5hdXRvUGxheShcInVwZGF0ZVwiKTtlbHNlIF90aGlzLnBhdXNlKFwicGF1c2VkXCIpO1xuICAgICAgfSk7IC8vIGFuaW1hdGluZyBzdGF0ZSBzaG91bGQgYmUgY2xlYXJlZCB3aGlsZSByZXNpemluZywgb3RoZXJ3aXNlIGF1dG9wbGF5IHN0b3BzIHdvcmtpbmdcblxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFuaW1hdGluZzogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spO1xuICAgICAgZGVsZXRlIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInVwZGF0ZVN0YXRlXCIsIGZ1bmN0aW9uIChzcGVjLCBzZXRUcmFja1N0eWxlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHVwZGF0ZWRTdGF0ZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5pbml0aWFsaXplZFN0YXRlKShzcGVjKTtcbiAgICAgIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHVwZGF0ZWRTdGF0ZSksIHt9LCB7XG4gICAgICAgIHNsaWRlSW5kZXg6IHVwZGF0ZWRTdGF0ZS5jdXJyZW50U2xpZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHRhcmdldExlZnQgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0VHJhY2tMZWZ0KShzcGVjKTtcbiAgICAgIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0XG4gICAgICB9KTtcbiAgICAgIHZhciB0cmFja1N0eWxlID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFRyYWNrQ1NTKShzcGVjKTtcblxuICAgICAgaWYgKHNldFRyYWNrU3R5bGUgfHwgX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbikgIT09IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoc3BlYy5jaGlsZHJlbikpIHtcbiAgICAgICAgdXBkYXRlZFN0YXRlW1widHJhY2tTdHlsZVwiXSA9IHRyYWNrU3R5bGU7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHVwZGF0ZWRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNzckluaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLnZhcmlhYmxlV2lkdGgpIHtcbiAgICAgICAgdmFyIF90cmFja1dpZHRoID0gMCxcbiAgICAgICAgICAgIF90cmFja0xlZnQgPSAwO1xuICAgICAgICB2YXIgY2hpbGRyZW5XaWR0aHMgPSBbXTtcbiAgICAgICAgdmFyIHByZUNsb25lcyA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgICBzbGlkZUNvdW50OiBfdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcG9zdENsb25lcyA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQb3N0Q2xvbmVzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgICAgc2xpZGVDb3VudDogX3RoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIH0pKTtcblxuICAgICAgICBfdGhpcy5wcm9wcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkcmVuV2lkdGhzLnB1c2goY2hpbGQucHJvcHMuc3R5bGUud2lkdGgpO1xuICAgICAgICAgIF90cmFja1dpZHRoICs9IGNoaWxkLnByb3BzLnN0eWxlLndpZHRoO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZUNsb25lczsgaSsrKSB7XG4gICAgICAgICAgX3RyYWNrTGVmdCArPSBjaGlsZHJlbldpZHRoc1tjaGlsZHJlbldpZHRocy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgICAgX3RyYWNrV2lkdGggKz0gY2hpbGRyZW5XaWR0aHNbY2hpbGRyZW5XaWR0aHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvc3RDbG9uZXM7IF9pKyspIHtcbiAgICAgICAgICBfdHJhY2tXaWR0aCArPSBjaGlsZHJlbldpZHRoc1tfaV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGU7IF9pMisrKSB7XG4gICAgICAgICAgX3RyYWNrTGVmdCArPSBjaGlsZHJlbldpZHRoc1tfaTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF90cmFja1N0eWxlID0ge1xuICAgICAgICAgIHdpZHRoOiBfdHJhY2tXaWR0aCArIFwicHhcIixcbiAgICAgICAgICBsZWZ0OiAtX3RyYWNrTGVmdCArIFwicHhcIlxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5jZW50ZXJNb2RlKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IFwiXCIuY29uY2F0KGNoaWxkcmVuV2lkdGhzW190aGlzLnN0YXRlLmN1cnJlbnRTbGlkZV0sIFwicHhcIik7XG4gICAgICAgICAgX3RyYWNrU3R5bGUubGVmdCA9IFwiY2FsYyhcIi5jb25jYXQoX3RyYWNrU3R5bGUubGVmdCwgXCIgKyAoMTAwJSAtIFwiKS5jb25jYXQoY3VycmVudFdpZHRoLCBcIikgLyAyICkgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFja1N0eWxlOiBfdHJhY2tTdHlsZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW5Db3VudCA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgc2xpZGVDb3VudDogY2hpbGRyZW5Db3VudFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzbGlkZUNvdW50ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFByZUNsb25lcykoc3BlYykgKyAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UG9zdENsb25lcykoc3BlYykgKyBjaGlsZHJlbkNvdW50O1xuICAgICAgdmFyIHRyYWNrV2lkdGggPSAxMDAgLyBfdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cgKiBzbGlkZUNvdW50O1xuICAgICAgdmFyIHNsaWRlV2lkdGggPSAxMDAgLyBzbGlkZUNvdW50O1xuICAgICAgdmFyIHRyYWNrTGVmdCA9IC1zbGlkZVdpZHRoICogKCgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKHNwZWMpICsgX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlKSAqIHRyYWNrV2lkdGggLyAxMDA7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5jZW50ZXJNb2RlKSB7XG4gICAgICAgIHRyYWNrTGVmdCArPSAoMTAwIC0gc2xpZGVXaWR0aCAqIHRyYWNrV2lkdGggLyAxMDApIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYWNrU3R5bGUgPSB7XG4gICAgICAgIHdpZHRoOiB0cmFja1dpZHRoICsgXCIlXCIsXG4gICAgICAgIGxlZnQ6IHRyYWNrTGVmdCArIFwiJVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2xpZGVXaWR0aDogc2xpZGVXaWR0aCArIFwiJVwiLFxuICAgICAgICB0cmFja1N0eWxlOiB0cmFja1N0eWxlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNoZWNrSW1hZ2VzTG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1hZ2VzID0gX3RoaXMubGlzdCAmJiBfdGhpcy5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLXNsaWRlIGltZ1wiKSB8fCBbXTtcbiAgICAgIHZhciBpbWFnZXNDb3VudCA9IGltYWdlcy5sZW5ndGgsXG4gICAgICAgICAgbG9hZGVkQ291bnQgPSAwO1xuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChpbWFnZXMsIGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgcmV0dXJuICsrbG9hZGVkQ291bnQgJiYgbG9hZGVkQ291bnQgPj0gaW1hZ2VzQ291bnQgJiYgX3RoaXMub25XaW5kb3dSZXNpemVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFpbWFnZS5vbmNsaWNrKSB7XG4gICAgICAgICAgaW1hZ2Uub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZS5wYXJlbnROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkNsaWNrSGFuZGxlciA9IGltYWdlLm9uY2xpY2s7XG5cbiAgICAgICAgICBpbWFnZS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHByZXZDbGlja0hhbmRsZXIoZSk7XG4gICAgICAgICAgICBpbWFnZS5wYXJlbnROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW1hZ2Uub25sb2FkKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzLmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFkYXB0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KF90aGlzLm9uV2luZG93UmVzaXplZCwgX3RoaXMucHJvcHMuc3BlZWQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGhhbmRsZXI7XG5cbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25MYXp5TG9hZEVycm9yICYmIF90aGlzLnByb3BzLm9uTGF6eUxvYWRFcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInByb2dyZXNzaXZlTGF6eUxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNsaWRlc1RvTG9hZCA9IFtdO1xuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlOyBpbmRleCA8IF90aGlzLnN0YXRlLnNsaWRlQ291bnQgKyAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UG9zdENsb25lcykoc3BlYyk7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmxhenlMb2FkZWRMaXN0LmluZGV4T2YoaW5kZXgpIDwgMCkge1xuICAgICAgICAgIHNsaWRlc1RvTG9hZC5wdXNoKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaW5kZXggPSBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUgLSAxOyBfaW5kZXggPj0gLSgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKHNwZWMpOyBfaW5kZXgtLSkge1xuICAgICAgICBpZiAoX3RoaXMuc3RhdGUubGF6eUxvYWRlZExpc3QuaW5kZXhPZihfaW5kZXgpIDwgMCkge1xuICAgICAgICAgIHNsaWRlc1RvTG9hZC5wdXNoKF9pbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWRlc1RvTG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXp5TG9hZGVkTGlzdDogc3RhdGUubGF6eUxvYWRlZExpc3QuY29uY2F0KHNsaWRlc1RvTG9hZClcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3RoaXMucHJvcHMub25MYXp5TG9hZCkge1xuICAgICAgICAgIF90aGlzLnByb3BzLm9uTGF6eUxvYWQoc2xpZGVzVG9Mb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLmxhenlMb2FkVGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmxhenlMb2FkVGltZXIpO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5sYXp5TG9hZFRpbWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpZGVIYW5kbGVyXCIsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGRvbnRBbmltYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGFzTmF2Rm9yID0gX3RoaXMkcHJvcHMuYXNOYXZGb3IsXG4gICAgICAgICAgYmVmb3JlQ2hhbmdlID0gX3RoaXMkcHJvcHMuYmVmb3JlQ2hhbmdlLFxuICAgICAgICAgIG9uTGF6eUxvYWQgPSBfdGhpcyRwcm9wcy5vbkxhenlMb2FkLFxuICAgICAgICAgIHNwZWVkID0gX3RoaXMkcHJvcHMuc3BlZWQsXG4gICAgICAgICAgYWZ0ZXJDaGFuZ2UgPSBfdGhpcyRwcm9wcy5hZnRlckNoYW5nZTsgLy8gY2FwdHVyZSBjdXJyZW50c2xpZGUgYmVmb3JlIHN0YXRlIGlzIHVwZGF0ZWRcblxuICAgICAgdmFyIGN1cnJlbnRTbGlkZSA9IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZTtcblxuICAgICAgdmFyIF9zbGlkZUhhbmRsZXIgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuc2xpZGVIYW5kbGVyKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFjayxcbiAgICAgICAgdXNlQ1NTOiBfdGhpcy5wcm9wcy51c2VDU1MgJiYgIWRvbnRBbmltYXRlXG4gICAgICB9KSksXG4gICAgICAgICAgc3RhdGUgPSBfc2xpZGVIYW5kbGVyLnN0YXRlLFxuICAgICAgICAgIG5leHRTdGF0ZSA9IF9zbGlkZUhhbmRsZXIubmV4dFN0YXRlO1xuXG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgICBiZWZvcmVDaGFuZ2UgJiYgYmVmb3JlQ2hhbmdlKGN1cnJlbnRTbGlkZSwgc3RhdGUuY3VycmVudFNsaWRlKTtcbiAgICAgIHZhciBzbGlkZXNUb0xvYWQgPSBzdGF0ZS5sYXp5TG9hZGVkTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZS5sYXp5TG9hZGVkTGlzdC5pbmRleE9mKHZhbHVlKSA8IDA7XG4gICAgICB9KTtcbiAgICAgIG9uTGF6eUxvYWQgJiYgc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDAgJiYgb25MYXp5TG9hZChzbGlkZXNUb0xvYWQpO1xuXG4gICAgICBpZiAoIV90aGlzLnByb3BzLndhaXRGb3JBbmltYXRlICYmIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjayk7XG4gICAgICAgIGFmdGVyQ2hhbmdlICYmIGFmdGVyQ2hhbmdlKGN1cnJlbnRTbGlkZSk7XG4gICAgICAgIGRlbGV0ZSBfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXNOYXZGb3JJbmRleCBjaGVjayBpcyB0byBhdm9pZCByZWN1cnNpdmUgY2FsbHMgb2Ygc2xpZGVIYW5kbGVyIGluIHdhaXRGb3JBbmltYXRlPWZhbHNlIG1vZGVcbiAgICAgICAgaWYgKGFzTmF2Rm9yICYmIF90aGlzLmFzTmF2Rm9ySW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgX3RoaXMuYXNOYXZGb3JJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFzTmF2Rm9yLmlubmVyU2xpZGVyLnNsaWRlSGFuZGxlcihpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5leHRTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjayA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhbmltYXRpbmcgPSBuZXh0U3RhdGUuYW5pbWF0aW5nLFxuICAgICAgICAgICAgICBmaXJzdEJhdGNoID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5leHRTdGF0ZSwgW1wiYW5pbWF0aW5nXCJdKTtcblxuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZpcnN0QmF0Y2gsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nOiBhbmltYXRpbmdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMCkpO1xuXG4gICAgICAgICAgICBhZnRlckNoYW5nZSAmJiBhZnRlckNoYW5nZShzdGF0ZS5jdXJyZW50U2xpZGUpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzcGVlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjaGFuZ2VTbGlkZVwiLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGRvbnRBbmltYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpO1xuXG4gICAgICB2YXIgdGFyZ2V0U2xpZGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2hhbmdlU2xpZGUpKHNwZWMsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRhcmdldFNsaWRlICE9PSAwICYmICF0YXJnZXRTbGlkZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoZG9udEFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgICAgX3RoaXMuc2xpZGVIYW5kbGVyKHRhcmdldFNsaWRlLCBkb250QW5pbWF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zbGlkZUhhbmRsZXIodGFyZ2V0U2xpZGUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5hdXRvcGxheSAmJiBfdGhpcy5hdXRvUGxheShcInVwZGF0ZVwiKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLWN1cnJlbnRcIik7XG5cbiAgICAgICAgbm9kZXNbMF0gJiYgbm9kZXNbMF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGlja0hhbmRsZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfdGhpcy5jbGlja2FibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2xpY2thYmxlID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJrZXlIYW5kbGVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGlyID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmtleUhhbmRsZXIpKGUsIF90aGlzLnByb3BzLmFjY2Vzc2liaWxpdHksIF90aGlzLnByb3BzLnJ0bCk7XG4gICAgICBkaXIgIT09IFwiXCIgJiYgX3RoaXMuY2hhbmdlU2xpZGUoe1xuICAgICAgICBtZXNzYWdlOiBkaXJcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNlbGVjdEhhbmRsZXJcIiwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIF90aGlzLmNoYW5nZVNsaWRlKG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRpc2FibGVCb2R5U2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cub250b3VjaG1vdmUgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJlbmFibGVCb2R5U2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5vbnRvdWNobW92ZSA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3dpcGVTdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLnZlcnRpY2FsU3dpcGluZykge1xuICAgICAgICBfdGhpcy5kaXNhYmxlQm9keVNjcm9sbCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuc3dpcGVTdGFydCkoZSwgX3RoaXMucHJvcHMuc3dpcGUsIF90aGlzLnByb3BzLmRyYWdnYWJsZSk7XG4gICAgICBzdGF0ZSAhPT0gXCJcIiAmJiBfdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3dpcGVNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuc3dpcGVNb3ZlKShlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFjayxcbiAgICAgICAgbGlzdFJlZjogX3RoaXMubGlzdCxcbiAgICAgICAgc2xpZGVJbmRleDogX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm47XG5cbiAgICAgIGlmIChzdGF0ZVtcInN3aXBpbmdcIl0pIHtcbiAgICAgICAgX3RoaXMuY2xpY2thYmxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzd2lwZUVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHN0YXRlID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLnN3aXBlRW5kKShlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFjayxcbiAgICAgICAgbGlzdFJlZjogX3RoaXMubGlzdCxcbiAgICAgICAgc2xpZGVJbmRleDogX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgICB2YXIgdHJpZ2dlclNsaWRlSGFuZGxlciA9IHN0YXRlW1widHJpZ2dlclNsaWRlSGFuZGxlclwiXTtcbiAgICAgIGRlbGV0ZSBzdGF0ZVtcInRyaWdnZXJTbGlkZUhhbmRsZXJcIl07XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlKTtcblxuICAgICAgaWYgKHRyaWdnZXJTbGlkZUhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5zbGlkZUhhbmRsZXIodHJpZ2dlclNsaWRlSGFuZGxlcik7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy52ZXJ0aWNhbFN3aXBpbmcpIHtcbiAgICAgICAgX3RoaXMuZW5hYmxlQm9keVNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInRvdWNoRW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5zd2lwZUVuZChlKTtcblxuICAgICAgX3RoaXMuY2xpY2thYmxlID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja1ByZXZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcyBhbmQgZmVsbG93IG1ldGhvZHMgYXJlIHdyYXBwZWQgaW4gc2V0VGltZW91dFxuICAgICAgLy8gdG8gbWFrZSBzdXJlIGluaXRpYWxpemUgc2V0U3RhdGUgaGFzIGhhcHBlbmVkIGJlZm9yZVxuICAgICAgLy8gYW55IG9mIHN1Y2ggbWV0aG9kcyBhcmUgY2FsbGVkXG4gICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlU2xpZGUoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwicHJldmlvdXNcIlxuICAgICAgICB9KTtcbiAgICAgIH0sIDApKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja05leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIm5leHRcIlxuICAgICAgICB9KTtcbiAgICAgIH0sIDApKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja0dvVG9cIiwgZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICB2YXIgZG9udEFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgc2xpZGUgPSBOdW1iZXIoc2xpZGUpO1xuICAgICAgaWYgKGlzTmFOKHNsaWRlKSkgcmV0dXJuIFwiXCI7XG5cbiAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgbWVzc2FnZTogXCJpbmRleFwiLFxuICAgICAgICAgIGluZGV4OiBzbGlkZSxcbiAgICAgICAgICBjdXJyZW50U2xpZGU6IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZVxuICAgICAgICB9LCBkb250QW5pbWF0ZSk7XG4gICAgICB9LCAwKSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicGxheVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dEluZGV4O1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMucnRsKSB7XG4gICAgICAgIG5leHRJbmRleCA9IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZSAtIF90aGlzLnByb3BzLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCgwLCBfaW5uZXJTbGlkZXJVdGlscy5jYW5Hb05leHQpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSkpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlICsgX3RoaXMucHJvcHMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNsaWRlSGFuZGxlcihuZXh0SW5kZXgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImF1dG9QbGF5XCIsIGZ1bmN0aW9uIChwbGF5VHlwZSkge1xuICAgICAgaWYgKF90aGlzLmF1dG9wbGF5VGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChfdGhpcy5hdXRvcGxheVRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF1dG9wbGF5aW5nID0gX3RoaXMuc3RhdGUuYXV0b3BsYXlpbmc7XG5cbiAgICAgIGlmIChwbGF5VHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICBpZiAoYXV0b3BsYXlpbmcgPT09IFwiaG92ZXJlZFwiIHx8IGF1dG9wbGF5aW5nID09PSBcImZvY3VzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwbGF5VHlwZSA9PT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJmb2N1c2VkXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGxheVR5cGUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJob3ZlcmVkXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuYXV0b3BsYXlUaW1lciA9IHNldEludGVydmFsKF90aGlzLnBsYXksIF90aGlzLnByb3BzLmF1dG9wbGF5U3BlZWQgKyA1MCk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYXV0b3BsYXlpbmc6IFwicGxheWluZ1wiXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwYXVzZVwiLCBmdW5jdGlvbiAocGF1c2VUeXBlKSB7XG4gICAgICBpZiAoX3RoaXMuYXV0b3BsYXlUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmF1dG9wbGF5VGltZXIpO1xuICAgICAgICBfdGhpcy5hdXRvcGxheVRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGF1dG9wbGF5aW5nID0gX3RoaXMuc3RhdGUuYXV0b3BsYXlpbmc7XG5cbiAgICAgIGlmIChwYXVzZVR5cGUgPT09IFwicGF1c2VkXCIpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGF1dG9wbGF5aW5nOiBcInBhdXNlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwYXVzZVR5cGUgPT09IFwiZm9jdXNlZFwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJob3ZlcmVkXCIgfHwgYXV0b3BsYXlpbmcgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYXV0b3BsYXlpbmc6IFwiZm9jdXNlZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhdXNlVHlwZSAgaXMgJ2hvdmVyZWQnXG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBhdXRvcGxheWluZzogXCJob3ZlcmVkXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRG90c092ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnBhdXNlKFwiaG92ZXJlZFwiKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkRvdHNMZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMuc3RhdGUuYXV0b3BsYXlpbmcgPT09IFwiaG92ZXJlZFwiICYmIF90aGlzLmF1dG9QbGF5KFwibGVhdmVcIik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25UcmFja092ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnBhdXNlKFwiaG92ZXJlZFwiKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRyYWNrTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIiAmJiBfdGhpcy5hdXRvUGxheShcImxlYXZlXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU2xpZGVGb2N1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMucGF1c2UoXCJmb2N1c2VkXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU2xpZGVCbHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5hdXRvcGxheSAmJiBfdGhpcy5zdGF0ZS5hdXRvcGxheWluZyA9PT0gXCJmb2N1c2VkXCIgJiYgX3RoaXMuYXV0b1BsYXkoXCJibHVyXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkoXCJzbGljay1zbGlkZXJcIiwgX3RoaXMucHJvcHMuY2xhc3NOYW1lLCB7XG4gICAgICAgIFwic2xpY2stdmVydGljYWxcIjogX3RoaXMucHJvcHMudmVydGljYWwsXG4gICAgICAgIFwic2xpY2staW5pdGlhbGl6ZWRcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKTtcblxuICAgICAgdmFyIHRyYWNrUHJvcHMgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZXh0cmFjdE9iamVjdCkoc3BlYywgW1wiZmFkZVwiLCBcImNzc0Vhc2VcIiwgXCJzcGVlZFwiLCBcImluZmluaXRlXCIsIFwiY2VudGVyTW9kZVwiLCBcImZvY3VzT25TZWxlY3RcIiwgXCJjdXJyZW50U2xpZGVcIiwgXCJsYXp5TG9hZFwiLCBcImxhenlMb2FkZWRMaXN0XCIsIFwicnRsXCIsIFwic2xpZGVXaWR0aFwiLCBcInNsaWRlSGVpZ2h0XCIsIFwibGlzdEhlaWdodFwiLCBcInZlcnRpY2FsXCIsIFwic2xpZGVzVG9TaG93XCIsIFwic2xpZGVzVG9TY3JvbGxcIiwgXCJzbGlkZUNvdW50XCIsIFwidHJhY2tTdHlsZVwiLCBcInZhcmlhYmxlV2lkdGhcIiwgXCJ1bnNsaWNrXCIsIFwiY2VudGVyUGFkZGluZ1wiLCBcInRhcmdldFNsaWRlXCIsIFwidXNlQ1NTXCJdKTtcbiAgICAgIHZhciBwYXVzZU9uSG92ZXIgPSBfdGhpcy5wcm9wcy5wYXVzZU9uSG92ZXI7XG4gICAgICB0cmFja1Byb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0cmFja1Byb3BzKSwge30sIHtcbiAgICAgICAgb25Nb3VzZUVudGVyOiBwYXVzZU9uSG92ZXIgPyBfdGhpcy5vblRyYWNrT3ZlciA6IG51bGwsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogcGF1c2VPbkhvdmVyID8gX3RoaXMub25UcmFja0xlYXZlIDogbnVsbCxcbiAgICAgICAgb25Nb3VzZU92ZXI6IHBhdXNlT25Ib3ZlciA/IF90aGlzLm9uVHJhY2tPdmVyIDogbnVsbCxcbiAgICAgICAgZm9jdXNPblNlbGVjdDogX3RoaXMucHJvcHMuZm9jdXNPblNlbGVjdCAmJiBfdGhpcy5jbGlja2FibGUgPyBfdGhpcy5zZWxlY3RIYW5kbGVyIDogbnVsbFxuICAgICAgfSk7XG4gICAgICB2YXIgZG90cztcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmRvdHMgPT09IHRydWUgJiYgX3RoaXMuc3RhdGUuc2xpZGVDb3VudCA+PSBfdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgdmFyIGRvdFByb3BzID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmV4dHJhY3RPYmplY3QpKHNwZWMsIFtcImRvdHNDbGFzc1wiLCBcInNsaWRlQ291bnRcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJjdXJyZW50U2xpZGVcIiwgXCJzbGlkZXNUb1Njcm9sbFwiLCBcImNsaWNrSGFuZGxlclwiLCBcImNoaWxkcmVuXCIsIFwiY3VzdG9tUGFnaW5nXCIsIFwiaW5maW5pdGVcIiwgXCJhcHBlbmREb3RzXCJdKTtcbiAgICAgICAgdmFyIHBhdXNlT25Eb3RzSG92ZXIgPSBfdGhpcy5wcm9wcy5wYXVzZU9uRG90c0hvdmVyO1xuICAgICAgICBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZG90UHJvcHMpLCB7fSwge1xuICAgICAgICAgIGNsaWNrSGFuZGxlcjogX3RoaXMuY2hhbmdlU2xpZGUsXG4gICAgICAgICAgb25Nb3VzZUVudGVyOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzTGVhdmUgOiBudWxsLFxuICAgICAgICAgIG9uTW91c2VPdmVyOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzT3ZlciA6IG51bGwsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzTGVhdmUgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBkb3RzID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfZG90cy5Eb3RzLCBkb3RQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2QXJyb3csIG5leHRBcnJvdztcbiAgICAgIHZhciBhcnJvd1Byb3BzID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmV4dHJhY3RPYmplY3QpKHNwZWMsIFtcImluZmluaXRlXCIsIFwiY2VudGVyTW9kZVwiLCBcImN1cnJlbnRTbGlkZVwiLCBcInNsaWRlQ291bnRcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJwcmV2QXJyb3dcIiwgXCJuZXh0QXJyb3dcIl0pO1xuICAgICAgYXJyb3dQcm9wcy5jbGlja0hhbmRsZXIgPSBfdGhpcy5jaGFuZ2VTbGlkZTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmFycm93cykge1xuICAgICAgICBwcmV2QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9hcnJvd3MuUHJldkFycm93LCBhcnJvd1Byb3BzKTtcbiAgICAgICAgbmV4dEFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfYXJyb3dzLk5leHRBcnJvdywgYXJyb3dQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2ZXJ0aWNhbEhlaWdodFN0eWxlID0gbnVsbDtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLnZlcnRpY2FsKSB7XG4gICAgICAgIHZlcnRpY2FsSGVpZ2h0U3R5bGUgPSB7XG4gICAgICAgICAgaGVpZ2h0OiBfdGhpcy5zdGF0ZS5saXN0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXJQYWRkaW5nU3R5bGUgPSBudWxsO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgY2VudGVyUGFkZGluZ1N0eWxlID0ge1xuICAgICAgICAgICAgcGFkZGluZzogXCIwcHggXCIgKyBfdGhpcy5wcm9wcy5jZW50ZXJQYWRkaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjZW50ZXJQYWRkaW5nU3R5bGUgPSB7XG4gICAgICAgICAgICBwYWRkaW5nOiBfdGhpcy5wcm9wcy5jZW50ZXJQYWRkaW5nICsgXCIgMHB4XCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0U3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZlcnRpY2FsSGVpZ2h0U3R5bGUpLCBjZW50ZXJQYWRkaW5nU3R5bGUpO1xuXG4gICAgICB2YXIgdG91Y2hNb3ZlID0gX3RoaXMucHJvcHMudG91Y2hNb3ZlO1xuICAgICAgdmFyIGxpc3RQcm9wcyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLWxpc3RcIixcbiAgICAgICAgc3R5bGU6IGxpc3RTdHlsZSxcbiAgICAgICAgb25DbGljazogX3RoaXMuY2xpY2tIYW5kbGVyLFxuICAgICAgICBvbk1vdXNlRG93bjogdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVTdGFydCA6IG51bGwsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBfdGhpcy5zdGF0ZS5kcmFnZ2luZyAmJiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZU1vdmUgOiBudWxsLFxuICAgICAgICBvbk1vdXNlVXA6IHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlRW5kIDogbnVsbCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBfdGhpcy5zdGF0ZS5kcmFnZ2luZyAmJiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZUVuZCA6IG51bGwsXG4gICAgICAgIG9uVG91Y2hTdGFydDogdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVTdGFydCA6IG51bGwsXG4gICAgICAgIG9uVG91Y2hNb3ZlOiBfdGhpcy5zdGF0ZS5kcmFnZ2luZyAmJiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZU1vdmUgOiBudWxsLFxuICAgICAgICBvblRvdWNoRW5kOiB0b3VjaE1vdmUgPyBfdGhpcy50b3VjaEVuZCA6IG51bGwsXG4gICAgICAgIG9uVG91Y2hDYW5jZWw6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlRW5kIDogbnVsbCxcbiAgICAgICAgb25LZXlEb3duOiBfdGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5ID8gX3RoaXMua2V5SGFuZGxlciA6IG51bGxcbiAgICAgIH07XG4gICAgICB2YXIgaW5uZXJTbGlkZXJQcm9wcyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGRpcjogXCJsdHJcIixcbiAgICAgICAgc3R5bGU6IF90aGlzLnByb3BzLnN0eWxlXG4gICAgICB9O1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMudW5zbGljaykge1xuICAgICAgICBsaXN0UHJvcHMgPSB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLWxpc3RcIlxuICAgICAgICB9O1xuICAgICAgICBpbm5lclNsaWRlclByb3BzID0ge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIGlubmVyU2xpZGVyUHJvcHMsICFfdGhpcy5wcm9wcy51bnNsaWNrID8gcHJldkFycm93IDogXCJcIiwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlZjogX3RoaXMubGlzdFJlZkhhbmRsZXJcbiAgICAgIH0sIGxpc3RQcm9wcyksIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3RyYWNrLlRyYWNrLCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlZjogX3RoaXMudHJhY2tSZWZIYW5kbGVyXG4gICAgICB9LCB0cmFja1Byb3BzKSwgX3RoaXMucHJvcHMuY2hpbGRyZW4pKSwgIV90aGlzLnByb3BzLnVuc2xpY2sgPyBuZXh0QXJyb3cgOiBcIlwiLCAhX3RoaXMucHJvcHMudW5zbGljayA/IGRvdHMgOiBcIlwiKTtcbiAgICB9KTtcblxuICAgIF90aGlzLmxpc3QgPSBudWxsO1xuICAgIF90aGlzLnRyYWNrID0gbnVsbDtcbiAgICBfdGhpcy5zdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX2luaXRpYWxTdGF0ZVtcImRlZmF1bHRcIl0pLCB7fSwge1xuICAgICAgY3VycmVudFNsaWRlOiBfdGhpcy5wcm9wcy5pbml0aWFsU2xpZGUsXG4gICAgICB0YXJnZXRTbGlkZTogX3RoaXMucHJvcHMuaW5pdGlhbFNsaWRlID8gX3RoaXMucHJvcHMuaW5pdGlhbFNsaWRlIDogMCxcbiAgICAgIHNsaWRlQ291bnQ6IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgfSk7XG4gICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMgPSBbXTtcbiAgICBfdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgIF90aGlzLmRlYm91bmNlZFJlc2l6ZSA9IG51bGw7XG5cbiAgICB2YXIgc3NyU3RhdGUgPSBfdGhpcy5zc3JJbml0KCk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMuc3RhdGUpLCBzc3JTdGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElubmVyU2xpZGVyLCBbe1xuICAgIGtleTogXCJkaWRQcm9wc0NoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWRQcm9wc0NoYW5nZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBzZXRUcmFja1N0eWxlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpOyBfaTMgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pM107XG5cbiAgICAgICAgaWYgKCFwcmV2UHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHNldFRyYWNrU3R5bGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90eXBlb2YocHJldlByb3BzW2tleV0pID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwcmV2UHJvcHNba2V5XSA9PT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKHByZXZQcm9wc1trZXldKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZQcm9wc1trZXldICE9PSB0aGlzLnByb3BzW2tleV0pIHtcbiAgICAgICAgICBzZXRUcmFja1N0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0VHJhY2tTdHlsZSB8fCBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pICE9PSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHByZXZQcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElubmVyU2xpZGVyO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuSW5uZXJTbGlkZXIgPSBJbm5lclNsaWRlcjsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbm5lclNsaWRlciIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2luaXRpYWxTdGF0ZSIsIl9sb2Rhc2giLCJfY2xhc3NuYW1lcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX3RyYWNrIiwiX2RvdHMiLCJfYXJyb3dzIiwiX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsImtleXMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImUiLCJnZXRQcm90b3R5cGVPZiIsIl9SZWFjdCRDb21wb25lbnQiLCJfc3VwZXIiLCJfdGhpcyIsInJlZiIsImxpc3QiLCJ0cmFjayIsImFkYXB0aXZlSGVpZ2h0IiwiZWxlbSIsInF1ZXJ5U2VsZWN0b3IiLCJjb25jYXQiLCJzdGF0ZSIsImN1cnJlbnRTbGlkZSIsInN0eWxlIiwiaGVpZ2h0IiwiZ2V0SGVpZ2h0Iiwib25Jbml0IiwibGF6eUxvYWQiLCJzbGlkZXNUb0xvYWQiLCJnZXRPbkRlbWFuZExhenlTbGlkZXMiLCJzZXRTdGF0ZSIsInByZXZTdGF0ZSIsImxhenlMb2FkZWRMaXN0Iiwib25MYXp5TG9hZCIsInNwZWMiLCJsaXN0UmVmIiwidHJhY2tSZWYiLCJ1cGRhdGVTdGF0ZSIsImFkYXB0SGVpZ2h0IiwiYXV0b3BsYXkiLCJhdXRvUGxheSIsImxhenlMb2FkVGltZXIiLCJzZXRJbnRlcnZhbCIsInByb2dyZXNzaXZlTGF6eUxvYWQiLCJybyIsImFuaW1hdGluZyIsIm9uV2luZG93UmVzaXplZCIsImNhbGxiYWNrVGltZXJzIiwic2V0VGltZW91dCIsInNwZWVkIiwib2JzZXJ2ZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIkFycmF5Iiwic2xpZGUiLCJvbmZvY3VzIiwicGF1c2VPbkZvY3VzIiwib25TbGlkZUZvY3VzIiwib25ibHVyIiwib25TbGlkZUJsdXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJhbmltYXRpb25FbmRDYWxsYmFjayIsImNsZWFyVGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJ0aW1lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImF1dG9wbGF5VGltZXIiLCJkaXNjb25uZWN0IiwicHJldlByb3BzIiwiY2hlY2tJbWFnZXNMb2FkIiwib25SZUluaXQiLCJzZXRUcmFja1N0eWxlIiwiZGlkUHJvcHNDaGFuZ2UiLCJDaGlsZHJlbiIsImNvdW50IiwiY2hpbGRyZW4iLCJjaGFuZ2VTbGlkZSIsIm1lc3NhZ2UiLCJpbmRleCIsInNsaWRlc1RvU2hvdyIsInBhdXNlIiwiZGVib3VuY2VkUmVzaXplIiwiY2FuY2VsIiwicmVzaXplV2luZG93IiwidW5kZWZpbmVkIiwiaXNUcmFja01vdW50ZWQiLCJub2RlIiwiY2FsbGJhY2siLCJ1cGRhdGVkU3RhdGUiLCJpbml0aWFsaXplZFN0YXRlIiwic2xpZGVJbmRleCIsInRhcmdldExlZnQiLCJnZXRUcmFja0xlZnQiLCJsZWZ0IiwidHJhY2tTdHlsZSIsImdldFRyYWNrQ1NTIiwidmFyaWFibGVXaWR0aCIsIl90cmFja1dpZHRoIiwiX3RyYWNrTGVmdCIsImNoaWxkcmVuV2lkdGhzIiwicHJlQ2xvbmVzIiwiZ2V0UHJlQ2xvbmVzIiwic2xpZGVDb3VudCIsInBvc3RDbG9uZXMiLCJnZXRQb3N0Q2xvbmVzIiwiY2hpbGQiLCJ3aWR0aCIsIl9pIiwiX2kyIiwiX3RyYWNrU3R5bGUiLCJjZW50ZXJNb2RlIiwiY3VycmVudFdpZHRoIiwiY2hpbGRyZW5Db3VudCIsInRyYWNrV2lkdGgiLCJzbGlkZVdpZHRoIiwidHJhY2tMZWZ0IiwiaW1hZ2VzIiwiaW1hZ2VzQ291bnQiLCJsb2FkZWRDb3VudCIsImltYWdlIiwiaGFuZGxlciIsIm9uY2xpY2siLCJwYXJlbnROb2RlIiwiZm9jdXMiLCJwcmV2Q2xpY2tIYW5kbGVyIiwib25sb2FkIiwib25lcnJvciIsIm9uTGF6eUxvYWRFcnJvciIsIl9pbmRleCIsImRvbnRBbmltYXRlIiwiX3RoaXMkcHJvcHMiLCJhc05hdkZvciIsImJlZm9yZUNoYW5nZSIsImFmdGVyQ2hhbmdlIiwiX3NsaWRlSGFuZGxlciIsInNsaWRlSGFuZGxlciIsInVzZUNTUyIsIm5leHRTdGF0ZSIsIndhaXRGb3JBbmltYXRlIiwiYXNOYXZGb3JJbmRleCIsImlubmVyU2xpZGVyIiwiZmlyc3RCYXRjaCIsIm9wdGlvbnMiLCJ0YXJnZXRTbGlkZSIsImZvY3VzT25TZWxlY3QiLCJub2RlcyIsImNsaWNrYWJsZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGlyIiwia2V5SGFuZGxlciIsImFjY2Vzc2liaWxpdHkiLCJydGwiLCJldmVudCIsInJldHVyblZhbHVlIiwib250b3VjaG1vdmUiLCJ2ZXJ0aWNhbFN3aXBpbmciLCJkaXNhYmxlQm9keVNjcm9sbCIsInN3aXBlU3RhcnQiLCJzd2lwZSIsImRyYWdnYWJsZSIsInN3aXBlTW92ZSIsInN3aXBlRW5kIiwidHJpZ2dlclNsaWRlSGFuZGxlciIsImVuYWJsZUJvZHlTY3JvbGwiLCJOdW1iZXIiLCJpc05hTiIsIm5leHRJbmRleCIsInNsaWRlc1RvU2Nyb2xsIiwiY2FuR29OZXh0IiwicGxheVR5cGUiLCJhdXRvcGxheWluZyIsInBsYXkiLCJhdXRvcGxheVNwZWVkIiwicGF1c2VUeXBlIiwiY2xhc3NOYW1lIiwidmVydGljYWwiLCJ0cmFja1Byb3BzIiwiZXh0cmFjdE9iamVjdCIsInBhdXNlT25Ib3ZlciIsIm9uTW91c2VFbnRlciIsIm9uVHJhY2tPdmVyIiwib25Nb3VzZUxlYXZlIiwib25UcmFja0xlYXZlIiwib25Nb3VzZU92ZXIiLCJzZWxlY3RIYW5kbGVyIiwiZG90cyIsImRvdFByb3BzIiwicGF1c2VPbkRvdHNIb3ZlciIsImNsaWNrSGFuZGxlciIsIm9uRG90c0xlYXZlIiwib25Eb3RzT3ZlciIsImNyZWF0ZUVsZW1lbnQiLCJEb3RzIiwicHJldkFycm93IiwibmV4dEFycm93IiwiYXJyb3dQcm9wcyIsImFycm93cyIsIlByZXZBcnJvdyIsIk5leHRBcnJvdyIsInZlcnRpY2FsSGVpZ2h0U3R5bGUiLCJsaXN0SGVpZ2h0IiwiY2VudGVyUGFkZGluZ1N0eWxlIiwicGFkZGluZyIsImNlbnRlclBhZGRpbmciLCJsaXN0U3R5bGUiLCJ0b3VjaE1vdmUiLCJsaXN0UHJvcHMiLCJvbkNsaWNrIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsImRyYWdnaW5nIiwib25Nb3VzZVVwIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwidG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwib25LZXlEb3duIiwiaW5uZXJTbGlkZXJQcm9wcyIsInVuc2xpY2siLCJsaXN0UmVmSGFuZGxlciIsIlRyYWNrIiwidHJhY2tSZWZIYW5kbGVyIiwiaW5pdGlhbFNsaWRlIiwic3NyU3RhdGUiLCJzc3JJbml0IiwiX2kzIiwiX09iamVjdCRrZXlzIiwiQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/slider.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/slider.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _innerSlider = __webpack_require__(/*! ./inner-slider */ \"(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js\");\nvar _json2mq = _interopRequireDefault(__webpack_require__(/*! json2mq */ \"(app-pages-browser)/./node_modules/json2mq/index.js\"));\nvar _defaultProps = _interopRequireDefault(__webpack_require__(/*! ./default-props */ \"(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar enquire = (0, _innerSliderUtils.canUseDOM)() && __webpack_require__(/*! enquire.js */ \"(app-pages-browser)/./node_modules/enquire.js/src/index.js\");\nvar Slider = /*#__PURE__*/ function(_React$Component) {\n    _inherits(Slider, _React$Component);\n    var _super = _createSuper(Slider);\n    function Slider(props) {\n        var _this;\n        _classCallCheck(this, Slider);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"innerSliderRefHandler\", function(ref) {\n            return _this.innerSlider = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n            return _this.innerSlider.slickPrev();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n            return _this.innerSlider.slickNext();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            return _this.innerSlider.slickGoTo(slide, dontAnimate);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPause\", function() {\n            return _this.innerSlider.pause(\"paused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPlay\", function() {\n            return _this.innerSlider.autoPlay(\"play\");\n        });\n        _this.state = {\n            breakpoint: null\n        };\n        _this._responsiveMediaHandlers = [];\n        return _this;\n    }\n    _createClass(Slider, [\n        {\n            key: \"media\",\n            value: function media(query, handler) {\n                // javascript handler for  css media query\n                enquire.register(query, handler);\n                this._responsiveMediaHandlers.push({\n                    query: query,\n                    handler: handler\n                });\n            } // handles responsive breakpoints\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                var _this2 = this;\n                // performance monitoring\n                //if (process.env.NODE_ENV !== 'production') {\n                //const { whyDidYouUpdate } = require('why-did-you-update')\n                //whyDidYouUpdate(React)\n                //}\n                if (this.props.responsive) {\n                    var breakpoints = this.props.responsive.map(function(breakpt) {\n                        return breakpt.breakpoint;\n                    }); // sort them in increasing order of their numerical value\n                    breakpoints.sort(function(x, y) {\n                        return x - y;\n                    });\n                    breakpoints.forEach(function(breakpoint, index) {\n                        // media query for each breakpoint\n                        var bQuery;\n                        if (index === 0) {\n                            bQuery = (0, _json2mq[\"default\"])({\n                                minWidth: 0,\n                                maxWidth: breakpoint\n                            });\n                        } else {\n                            bQuery = (0, _json2mq[\"default\"])({\n                                minWidth: breakpoints[index - 1] + 1,\n                                maxWidth: breakpoint\n                            });\n                        } // when not using server side rendering\n                        (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function() {\n                            _this2.setState({\n                                breakpoint: breakpoint\n                            });\n                        });\n                    }); // Register media query for full screen. Need to support resize from small to large\n                    // convert javascript object to media query string\n                    var query = (0, _json2mq[\"default\"])({\n                        minWidth: breakpoints.slice(-1)[0]\n                    });\n                    (0, _innerSliderUtils.canUseDOM)() && this.media(query, function() {\n                        _this2.setState({\n                            breakpoint: null\n                        });\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this._responsiveMediaHandlers.forEach(function(obj) {\n                    enquire.unregister(obj.query, obj.handler);\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var settings;\n                var newProps;\n                if (this.state.breakpoint) {\n                    newProps = this.props.responsive.filter(function(resp) {\n                        return resp.breakpoint === _this3.state.breakpoint;\n                    });\n                    settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props), newProps[0].settings);\n                } else {\n                    settings = _objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props);\n                } // force scrolling by one if centerMode is on\n                if (settings.centerMode) {\n                    if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToScroll should be equal to 1 in centerMode, you are using \".concat(settings.slidesToScroll));\n                    }\n                    settings.slidesToScroll = 1;\n                } // force showing one slide and scrolling by one if the fade mode is on\n                if (settings.fade) {\n                    if (settings.slidesToShow > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToShow should be equal to 1 when fade is true, you're using \".concat(settings.slidesToShow));\n                    }\n                    if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToScroll should be equal to 1 when fade is true, you're using \".concat(settings.slidesToScroll));\n                    }\n                    settings.slidesToShow = 1;\n                    settings.slidesToScroll = 1;\n                } // makes sure that children is an array, even when there is only 1 child\n                var children = _react[\"default\"].Children.toArray(this.props.children); // Children may contain false or null, so we should filter them\n                // children may also contain string filled with spaces (in certain cases where we use jsx strings)\n                children = children.filter(function(child) {\n                    if (typeof child === \"string\") {\n                        return !!child.trim();\n                    }\n                    return !!child;\n                }); // rows and slidesPerRow logic is handled here\n                if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n                    console.warn(\"variableWidth is not supported in case of rows > 1 or slidesPerRow > 1\");\n                    settings.variableWidth = false;\n                }\n                var newChildren = [];\n                var currentWidth = null;\n                for(var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow){\n                    var newSlide = [];\n                    for(var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow){\n                        var row = [];\n                        for(var k = j; k < j + settings.slidesPerRow; k += 1){\n                            if (settings.variableWidth && children[k].props.style) {\n                                currentWidth = children[k].props.style.width;\n                            }\n                            if (k >= children.length) break;\n                            row.push(/*#__PURE__*/ _react[\"default\"].cloneElement(children[k], {\n                                key: 100 * i + 10 * j + k,\n                                tabIndex: -1,\n                                style: {\n                                    width: \"\".concat(100 / settings.slidesPerRow, \"%\"),\n                                    display: \"inline-block\"\n                                }\n                            }));\n                        }\n                        newSlide.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: 10 * i + j\n                        }, row));\n                    }\n                    if (settings.variableWidth) {\n                        newChildren.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: i,\n                            style: {\n                                width: currentWidth\n                            }\n                        }, newSlide));\n                    } else {\n                        newChildren.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: i\n                        }, newSlide));\n                    }\n                }\n                if (settings === \"unslick\") {\n                    var className = \"regular slider \" + (this.props.className || \"\");\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                        className: className\n                    }, children);\n                } else if (newChildren.length <= settings.slidesToShow && !settings.infinite) {\n                    settings.unslick = true;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_innerSlider.InnerSlider, _extends({\n                    style: this.props.style,\n                    ref: this.innerSliderRefHandler\n                }, (0, _innerSliderUtils.filterSettings)(settings)), newChildren);\n            }\n        }\n    ]);\n    return Slider;\n}(_react[\"default\"].Component);\nexports[\"default\"] = Slider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvc2xpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsR0FBRztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLEdBQUc7UUFBSSxPQUFPLE9BQU9BO0lBQUssSUFBSSxTQUFVQSxHQUFHO1FBQUksT0FBT0EsT0FBTyxjQUFjLE9BQU9DLFVBQVVELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBSyxHQUFHRCxRQUFRQztBQUFNO0FBRS9VSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUUxQixJQUFJRSxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1GQUFPO0FBRW5ELElBQUlDLGVBQWVELG1CQUFPQSxDQUFDLDBGQUFnQjtBQUUzQyxJQUFJRSxXQUFXSCx1QkFBdUJDLG1CQUFPQSxDQUFDLG9FQUFTO0FBRXZELElBQUlHLGdCQUFnQkosdUJBQXVCQyxtQkFBT0EsQ0FBQyw0RkFBaUI7QUFFcEUsSUFBSUksb0JBQW9CSixtQkFBT0EsQ0FBQyw4R0FBMEI7QUFFMUQsU0FBU0QsdUJBQXVCVixHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSWdCLFVBQVUsR0FBR2hCLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsU0FBU2lCO0lBQWFBLFdBQVdaLE9BQU9hLE1BQU0sSUFBSSxTQUFVQyxNQUFNO1FBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUFFLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUFFLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFBRSxJQUFJbEIsT0FBT0QsU0FBUyxD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NEJBQ1Q7d0JBQ0YsR0FBR0M7b0JBQ0wsT0FBTzt3QkFDTEYsWUFBWTdHLElBQUksQ0FBRSxXQUFXLEdBQUU3QixNQUFNLENBQUMsVUFBVSxDQUFDcUosYUFBYSxDQUFDLE9BQU87NEJBQ3BFdEksS0FBS0o7d0JBQ1AsR0FBR2lJO29CQUNMO2dCQUNGO2dCQUVBLElBQUlyQixhQUFhLFdBQVc7b0JBQzFCLElBQUkrQixZQUFZLG9CQUFxQixLQUFJLENBQUM5RyxLQUFLLENBQUM4RyxTQUFTLElBQUksRUFBQztvQkFDOUQsT0FBTyxXQUFXLEdBQUV0SixNQUFNLENBQUMsVUFBVSxDQUFDcUosYUFBYSxDQUFDLE9BQU87d0JBQ3pEQyxXQUFXQTtvQkFDYixHQUFHcEI7Z0JBQ0wsT0FBTyxJQUFJUSxZQUFZN0gsTUFBTSxJQUFJMEcsU0FBU1UsWUFBWSxJQUFJLENBQUNWLFNBQVNnQyxRQUFRLEVBQUU7b0JBQzVFaEMsU0FBU2lDLE9BQU8sR0FBRztnQkFDckI7Z0JBRUEsT0FBTyxXQUFXLEdBQUV4SixNQUFNLENBQUMsVUFBVSxDQUFDcUosYUFBYSxDQUFDbEosYUFBYXNKLFdBQVcsRUFBRWpKLFNBQVM7b0JBQ3JGd0ksT0FBTyxJQUFJLENBQUN4RyxLQUFLLENBQUN3RyxLQUFLO29CQUN2QjdELEtBQUssSUFBSSxDQUFDdUUscUJBQXFCO2dCQUNqQyxHQUFHLENBQUMsR0FBR3BKLGtCQUFrQnFKLGNBQWMsRUFBRXBDLFlBQVltQjtZQUN2RDtRQUNGO0tBQUU7SUFFRixPQUFPM0Q7QUFDVCxFQUFFL0UsTUFBTSxDQUFDLFVBQVUsQ0FBQzRKLFNBQVM7QUFFN0I5SixrQkFBa0IsR0FBR2lGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvc2xpZGVyLmpzP2Q0YWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2lubmVyU2xpZGVyID0gcmVxdWlyZShcIi4vaW5uZXItc2xpZGVyXCIpO1xuXG52YXIgX2pzb24ybXEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqc29uMm1xXCIpKTtcblxudmFyIF9kZWZhdWx0UHJvcHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RlZmF1bHQtcHJvcHNcIikpO1xuXG52YXIgX2lubmVyU2xpZGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy9pbm5lclNsaWRlclV0aWxzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBlbnF1aXJlID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhblVzZURPTSkoKSAmJiByZXF1aXJlKFwiZW5xdWlyZS5qc1wiKTtcblxudmFyIFNsaWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU2xpZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNsaWRlcik7XG5cbiAgZnVuY3Rpb24gU2xpZGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpbm5lclNsaWRlclJlZkhhbmRsZXJcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIF90aGlzLmlubmVyU2xpZGVyID0gcmVmO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrUHJldlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIuc2xpY2tQcmV2KCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5zbGlja05leHQoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja0dvVG9cIiwgZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICB2YXIgZG9udEFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzLmlubmVyU2xpZGVyLnNsaWNrR29UbyhzbGlkZSwgZG9udEFuaW1hdGUpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrUGF1c2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmlubmVyU2xpZGVyLnBhdXNlKFwicGF1c2VkXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrUGxheVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIuYXV0b1BsYXkoXCJwbGF5XCIpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBicmVha3BvaW50OiBudWxsXG4gICAgfTtcbiAgICBfdGhpcy5fcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgIGtleTogXCJtZWRpYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYShxdWVyeSwgaGFuZGxlcikge1xuICAgICAgLy8gamF2YXNjcmlwdCBoYW5kbGVyIGZvciAgY3NzIG1lZGlhIHF1ZXJ5XG4gICAgICBlbnF1aXJlLnJlZ2lzdGVyKHF1ZXJ5LCBoYW5kbGVyKTtcblxuICAgICAgdGhpcy5fcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMucHVzaCh7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgfSk7XG4gICAgfSAvLyBoYW5kbGVzIHJlc3BvbnNpdmUgYnJlYWtwb2ludHNcblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICAgIC8vaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vY29uc3QgeyB3aHlEaWRZb3VVcGRhdGUgfSA9IHJlcXVpcmUoJ3doeS1kaWQteW91LXVwZGF0ZScpXG4gICAgICAvL3doeURpZFlvdVVwZGF0ZShSZWFjdClcbiAgICAgIC8vfVxuICAgICAgaWYgKHRoaXMucHJvcHMucmVzcG9uc2l2ZSkge1xuICAgICAgICB2YXIgYnJlYWtwb2ludHMgPSB0aGlzLnByb3BzLnJlc3BvbnNpdmUubWFwKGZ1bmN0aW9uIChicmVha3B0KSB7XG4gICAgICAgICAgcmV0dXJuIGJyZWFrcHQuYnJlYWtwb2ludDtcbiAgICAgICAgfSk7IC8vIHNvcnQgdGhlbSBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIHRoZWlyIG51bWVyaWNhbCB2YWx1ZVxuXG4gICAgICAgIGJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICByZXR1cm4geCAtIHk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVha3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChicmVha3BvaW50LCBpbmRleCkge1xuICAgICAgICAgIC8vIG1lZGlhIHF1ZXJ5IGZvciBlYWNoIGJyZWFrcG9pbnRcbiAgICAgICAgICB2YXIgYlF1ZXJ5O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBiUXVlcnkgPSAoMCwgX2pzb24ybXFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICAgICAgICBtYXhXaWR0aDogYnJlYWtwb2ludFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJRdWVyeSA9ICgwLCBfanNvbjJtcVtcImRlZmF1bHRcIl0pKHtcbiAgICAgICAgICAgICAgbWluV2lkdGg6IGJyZWFrcG9pbnRzW2luZGV4IC0gMV0gKyAxLFxuICAgICAgICAgICAgICBtYXhXaWR0aDogYnJlYWtwb2ludFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmdcblxuXG4gICAgICAgICAgKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhblVzZURPTSkoKSAmJiBfdGhpczIubWVkaWEoYlF1ZXJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBicmVha3BvaW50OiBicmVha3BvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IC8vIFJlZ2lzdGVyIG1lZGlhIHF1ZXJ5IGZvciBmdWxsIHNjcmVlbi4gTmVlZCB0byBzdXBwb3J0IHJlc2l6ZSBmcm9tIHNtYWxsIHRvIGxhcmdlXG4gICAgICAgIC8vIGNvbnZlcnQgamF2YXNjcmlwdCBvYmplY3QgdG8gbWVkaWEgcXVlcnkgc3RyaW5nXG5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gKDAsIF9qc29uMm1xW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgIG1pbldpZHRoOiBicmVha3BvaW50cy5zbGljZSgtMSlbMF1cbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfaW5uZXJTbGlkZXJVdGlscy5jYW5Vc2VET00pKCkgJiYgdGhpcy5tZWRpYShxdWVyeSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBicmVha3BvaW50OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVNZWRpYUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBlbnF1aXJlLnVucmVnaXN0ZXIob2JqLnF1ZXJ5LCBvYmouaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgc2V0dGluZ3M7XG4gICAgICB2YXIgbmV3UHJvcHM7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmJyZWFrcG9pbnQpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB0aGlzLnByb3BzLnJlc3BvbnNpdmUuZmlsdGVyKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3AuYnJlYWtwb2ludCA9PT0gX3RoaXMzLnN0YXRlLmJyZWFrcG9pbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXR0aW5ncyA9IG5ld1Byb3BzWzBdLnNldHRpbmdzID09PSBcInVuc2xpY2tcIiA/IFwidW5zbGlja1wiIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9kZWZhdWx0UHJvcHNbXCJkZWZhdWx0XCJdKSwgdGhpcy5wcm9wcyksIG5ld1Byb3BzWzBdLnNldHRpbmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfZGVmYXVsdFByb3BzW1wiZGVmYXVsdFwiXSksIHRoaXMucHJvcHMpO1xuICAgICAgfSAvLyBmb3JjZSBzY3JvbGxpbmcgYnkgb25lIGlmIGNlbnRlck1vZGUgaXMgb25cblxuXG4gICAgICBpZiAoc2V0dGluZ3MuY2VudGVyTW9kZSkge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwgPiAxICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNsaWRlc1RvU2Nyb2xsIHNob3VsZCBiZSBlcXVhbCB0byAxIGluIGNlbnRlck1vZGUsIHlvdSBhcmUgdXNpbmcgXCIuY29uY2F0KHNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA9IDE7XG4gICAgICB9IC8vIGZvcmNlIHNob3dpbmcgb25lIHNsaWRlIGFuZCBzY3JvbGxpbmcgYnkgb25lIGlmIHRoZSBmYWRlIG1vZGUgaXMgb25cblxuXG4gICAgICBpZiAoc2V0dGluZ3MuZmFkZSkge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2xpZGVzVG9TaG93ID4gMSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzbGlkZXNUb1Nob3cgc2hvdWxkIGJlIGVxdWFsIHRvIDEgd2hlbiBmYWRlIGlzIHRydWUsIHlvdSdyZSB1c2luZyBcIi5jb25jYXQoc2V0dGluZ3Muc2xpZGVzVG9TaG93KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwgPiAxICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNsaWRlc1RvU2Nyb2xsIHNob3VsZCBiZSBlcXVhbCB0byAxIHdoZW4gZmFkZSBpcyB0cnVlLCB5b3UncmUgdXNpbmcgXCIuY29uY2F0KHNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5zbGlkZXNUb1Nob3cgPSAxO1xuICAgICAgICBzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA9IDE7XG4gICAgICB9IC8vIG1ha2VzIHN1cmUgdGhhdCBjaGlsZHJlbiBpcyBhbiBhcnJheSwgZXZlbiB3aGVuIHRoZXJlIGlzIG9ubHkgMSBjaGlsZFxuXG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4udG9BcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKTsgLy8gQ2hpbGRyZW4gbWF5IGNvbnRhaW4gZmFsc2Ugb3IgbnVsbCwgc28gd2Ugc2hvdWxkIGZpbHRlciB0aGVtXG4gICAgICAvLyBjaGlsZHJlbiBtYXkgYWxzbyBjb250YWluIHN0cmluZyBmaWxsZWQgd2l0aCBzcGFjZXMgKGluIGNlcnRhaW4gY2FzZXMgd2hlcmUgd2UgdXNlIGpzeCBzdHJpbmdzKVxuXG5cbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuICEhY2hpbGQudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhY2hpbGQ7XG4gICAgICB9KTsgLy8gcm93cyBhbmQgc2xpZGVzUGVyUm93IGxvZ2ljIGlzIGhhbmRsZWQgaGVyZVxuXG4gICAgICBpZiAoc2V0dGluZ3MudmFyaWFibGVXaWR0aCAmJiAoc2V0dGluZ3Mucm93cyA+IDEgfHwgc2V0dGluZ3Muc2xpZGVzUGVyUm93ID4gMSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidmFyaWFibGVXaWR0aCBpcyBub3Qgc3VwcG9ydGVkIGluIGNhc2Ugb2Ygcm93cyA+IDEgb3Igc2xpZGVzUGVyUm93ID4gMVwiKTtcbiAgICAgICAgc2V0dGluZ3MudmFyaWFibGVXaWR0aCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciBjdXJyZW50V2lkdGggPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSBzZXR0aW5ncy5yb3dzICogc2V0dGluZ3Muc2xpZGVzUGVyUm93KSB7XG4gICAgICAgIHZhciBuZXdTbGlkZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgaSArIHNldHRpbmdzLnJvd3MgKiBzZXR0aW5ncy5zbGlkZXNQZXJSb3c7IGogKz0gc2V0dGluZ3Muc2xpZGVzUGVyUm93KSB7XG4gICAgICAgICAgdmFyIHJvdyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgayA9IGo7IGsgPCBqICsgc2V0dGluZ3Muc2xpZGVzUGVyUm93OyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy52YXJpYWJsZVdpZHRoICYmIGNoaWxkcmVuW2tdLnByb3BzLnN0eWxlKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IGNoaWxkcmVuW2tdLnByb3BzLnN0eWxlLndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoayA+PSBjaGlsZHJlbi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgcm93LnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjaGlsZHJlbltrXSwge1xuICAgICAgICAgICAgICBrZXk6IDEwMCAqIGkgKyAxMCAqIGogKyBrLFxuICAgICAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KDEwMCAvIHNldHRpbmdzLnNsaWRlc1BlclJvdywgXCIlXCIpLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1NsaWRlLnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAga2V5OiAxMCAqIGkgKyBqXG4gICAgICAgICAgfSwgcm93KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MudmFyaWFibGVXaWR0aCkge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAga2V5OiBpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG5ld1NsaWRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBrZXk6IGlcbiAgICAgICAgICB9LCBuZXdTbGlkZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncyA9PT0gXCJ1bnNsaWNrXCIpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwicmVndWxhciBzbGlkZXIgXCIgKyAodGhpcy5wcm9wcy5jbGFzc05hbWUgfHwgXCJcIik7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA8PSBzZXR0aW5ncy5zbGlkZXNUb1Nob3cgJiYgIXNldHRpbmdzLmluZmluaXRlKSB7XG4gICAgICAgIHNldHRpbmdzLnVuc2xpY2sgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfaW5uZXJTbGlkZXIuSW5uZXJTbGlkZXIsIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHRoaXMucHJvcHMuc3R5bGUsXG4gICAgICAgIHJlZjogdGhpcy5pbm5lclNsaWRlclJlZkhhbmRsZXJcbiAgICAgIH0sICgwLCBfaW5uZXJTbGlkZXJVdGlscy5maWx0ZXJTZXR0aW5ncykoc2V0dGluZ3MpKSwgbmV3Q2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGlkZXI7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTbGlkZXI7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9pbm5lclNsaWRlciIsIl9qc29uMm1xIiwiX2RlZmF1bHRQcm9wcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZSIsImdldFByb3RvdHlwZU9mIiwiZW5xdWlyZSIsImNhblVzZURPTSIsIlNsaWRlciIsIl9SZWFjdCRDb21wb25lbnQiLCJfc3VwZXIiLCJfdGhpcyIsInJlZiIsImlubmVyU2xpZGVyIiwic2xpY2tQcmV2Iiwic2xpY2tOZXh0Iiwic2xpZGUiLCJkb250QW5pbWF0ZSIsInVuZGVmaW5lZCIsInNsaWNrR29UbyIsInBhdXNlIiwiYXV0b1BsYXkiLCJzdGF0ZSIsImJyZWFrcG9pbnQiLCJfcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMiLCJtZWRpYSIsInF1ZXJ5IiwiaGFuZGxlciIsInJlZ2lzdGVyIiwiY29tcG9uZW50RGlkTW91bnQiLCJfdGhpczIiLCJyZXNwb25zaXZlIiwiYnJlYWtwb2ludHMiLCJtYXAiLCJicmVha3B0Iiwic29ydCIsIngiLCJ5IiwiaW5kZXgiLCJiUXVlcnkiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwic2V0U3RhdGUiLCJzbGljZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidW5yZWdpc3RlciIsInJlbmRlciIsIl90aGlzMyIsInNldHRpbmdzIiwibmV3UHJvcHMiLCJyZXNwIiwiY2VudGVyTW9kZSIsInNsaWRlc1RvU2Nyb2xsIiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiY29uY2F0IiwiZmFkZSIsInNsaWRlc1RvU2hvdyIsImNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiY2hpbGQiLCJ0cmltIiwidmFyaWFibGVXaWR0aCIsInJvd3MiLCJzbGlkZXNQZXJSb3ciLCJuZXdDaGlsZHJlbiIsImN1cnJlbnRXaWR0aCIsIm5ld1NsaWRlIiwiaiIsInJvdyIsImsiLCJzdHlsZSIsIndpZHRoIiwiY2xvbmVFbGVtZW50IiwidGFiSW5kZXgiLCJkaXNwbGF5IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImluZmluaXRlIiwidW5zbGljayIsIklubmVyU2xpZGVyIiwiaW5uZXJTbGlkZXJSZWZIYW5kbGVyIiwiZmlsdGVyU2V0dGluZ3MiLCJDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/slider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/track.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/track.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Track = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n// given specifications/props for a slide, fetch all the classes that need to be applied to the slide\nvar getSlideClasses = function getSlideClasses(spec) {\n    var slickActive, slickCenter, slickCloned;\n    var centerOffset, index;\n    if (spec.rtl) {\n        index = spec.slideCount - 1 - spec.index;\n    } else {\n        index = spec.index;\n    }\n    slickCloned = index < 0 || index >= spec.slideCount;\n    if (spec.centerMode) {\n        centerOffset = Math.floor(spec.slidesToShow / 2);\n        slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;\n        if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) {\n            slickActive = true;\n        }\n    } else {\n        slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;\n    }\n    var focusedSlide;\n    if (spec.targetSlide < 0) {\n        focusedSlide = spec.targetSlide + spec.slideCount;\n    } else if (spec.targetSlide >= spec.slideCount) {\n        focusedSlide = spec.targetSlide - spec.slideCount;\n    } else {\n        focusedSlide = spec.targetSlide;\n    }\n    var slickCurrent = index === focusedSlide;\n    return {\n        \"slick-slide\": true,\n        \"slick-active\": slickActive,\n        \"slick-center\": slickCenter,\n        \"slick-cloned\": slickCloned,\n        \"slick-current\": slickCurrent // dubious in case of RTL\n    };\n};\nvar getSlideStyle = function getSlideStyle(spec) {\n    var style = {};\n    if (spec.variableWidth === undefined || spec.variableWidth === false) {\n        style.width = spec.slideWidth;\n    }\n    if (spec.fade) {\n        style.position = \"relative\";\n        if (spec.vertical) {\n            style.top = -spec.index * parseInt(spec.slideHeight);\n        } else {\n            style.left = -spec.index * parseInt(spec.slideWidth);\n        }\n        style.opacity = spec.currentSlide === spec.index ? 1 : 0;\n        if (spec.useCSS) {\n            style.transition = \"opacity \" + spec.speed + \"ms \" + spec.cssEase + \", \" + \"visibility \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n    }\n    return style;\n};\nvar getKey = function getKey(child, fallbackKey) {\n    return child.key || fallbackKey;\n};\nvar renderSlides = function renderSlides(spec) {\n    var key;\n    var slides = [];\n    var preCloneSlides = [];\n    var postCloneSlides = [];\n    var childrenCount = _react[\"default\"].Children.count(spec.children);\n    var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);\n    var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);\n    _react[\"default\"].Children.forEach(spec.children, function(elem, index) {\n        var child;\n        var childOnClickOptions = {\n            message: \"children\",\n            index: index,\n            slidesToScroll: spec.slidesToScroll,\n            currentSlide: spec.currentSlide\n        }; // in case of lazyLoad, whether or not we want to fetch the slide\n        if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) {\n            child = elem;\n        } else {\n            child = /*#__PURE__*/ _react[\"default\"].createElement(\"div\", null);\n        }\n        var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {\n            index: index\n        }));\n        var slideClass = child.props.className || \"\";\n        var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n            index: index\n        })); // push a cloned element of the desired slide\n        slides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n            key: \"original\" + getKey(child, index),\n            \"data-index\": index,\n            className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n            tabIndex: \"-1\",\n            \"aria-hidden\": !slideClasses[\"slick-active\"],\n            style: _objectSpread(_objectSpread({\n                outline: \"none\"\n            }, child.props.style || {}), childStyle),\n            onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                    spec.focusOnSelect(childOnClickOptions);\n                }\n            }\n        })); // if slide needs to be precloned or postcloned\n        if (spec.infinite && spec.fade === false) {\n            var preCloneNo = childrenCount - index;\n            if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec)) {\n                key = -preCloneNo;\n                if (key >= startIndex) {\n                    child = elem;\n                }\n                slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n                    index: key\n                }));\n                preCloneSlides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n                    key: \"precloned\" + getKey(child, key),\n                    \"data-index\": key,\n                    tabIndex: \"-1\",\n                    className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n                    \"aria-hidden\": !slideClasses[\"slick-active\"],\n                    style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n                    onClick: function onClick(e) {\n                        child.props && child.props.onClick && child.props.onClick(e);\n                        if (spec.focusOnSelect) {\n                            spec.focusOnSelect(childOnClickOptions);\n                        }\n                    }\n                }));\n            }\n            key = childrenCount + index;\n            if (key < endIndex) {\n                child = elem;\n            }\n            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n                index: key\n            }));\n            postCloneSlides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n                key: \"postcloned\" + getKey(child, key),\n                \"data-index\": key,\n                tabIndex: \"-1\",\n                className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n                \"aria-hidden\": !slideClasses[\"slick-active\"],\n                style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n                onClick: function onClick(e) {\n                    child.props && child.props.onClick && child.props.onClick(e);\n                    if (spec.focusOnSelect) {\n                        spec.focusOnSelect(childOnClickOptions);\n                    }\n                }\n            }));\n        }\n    });\n    if (spec.rtl) {\n        return preCloneSlides.concat(slides, postCloneSlides).reverse();\n    } else {\n        return preCloneSlides.concat(slides, postCloneSlides);\n    }\n};\nvar Track = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Track, _React$PureComponent);\n    var _super = _createSuper(Track);\n    function Track() {\n        var _this;\n        _classCallCheck(this, Track);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [\n            this\n        ].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"node\", null);\n        _defineProperty(_assertThisInitialized(_this), \"handleRef\", function(ref) {\n            _this.node = ref;\n        });\n        return _this;\n    }\n    _createClass(Track, [\n        {\n            key: \"render\",\n            value: function render() {\n                var slides = renderSlides(this.props);\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;\n                var mouseEvents = {\n                    onMouseEnter: onMouseEnter,\n                    onMouseOver: onMouseOver,\n                    onMouseLeave: onMouseLeave\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                    ref: this.handleRef,\n                    className: \"slick-track\",\n                    style: this.props.trackStyle\n                }, mouseEvents), slides);\n            }\n        }\n    ]);\n    return Track;\n}(_react[\"default\"].PureComponent);\nexports.Track = Track;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvdHJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxHQUFHO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsR0FBRztRQUFJLE9BQU8sT0FBT0E7SUFBSyxJQUFJLFNBQVVBLEdBQUc7UUFBSSxPQUFPQSxPQUFPLGNBQWMsT0FBT0MsVUFBVUQsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFLLEdBQUdELFFBQVFDO0FBQU07QUFFL1VLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUcsS0FBSztBQUVyQixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1GQUFPO0FBRW5ELElBQUlDLGNBQWNGLHVCQUF1QkMsbUJBQU9BLENBQUMsMEVBQVk7QUFFN0QsSUFBSUUsb0JBQW9CRixtQkFBT0EsQ0FBQyw4R0FBMEI7QUFFMUQsU0FBU0QsdUJBQXVCWCxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSWUsVUFBVSxHQUFHZixNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLFNBQVNnQjtJQUFhQSxXQUFXWCxPQUFPWSxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSWpCLE9BQU9ELFNBQVMsQ0FBQ29CLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFF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T3JJLElBQUksQ0FBQ0MsS0FBSyxDQUFDb0ksUUFBUTtZQUFDLElBQUk7U0FBQyxDQUFDSCxNQUFNLENBQUNNO1FBRWhEL0UsZ0JBQWdCcEIsdUJBQXVCaUcsUUFBUSxRQUFRO1FBRXZEN0UsZ0JBQWdCcEIsdUJBQXVCaUcsUUFBUSxhQUFhLFNBQVVLLEdBQUc7WUFDdkVMLE1BQU1NLElBQUksR0FBR0Q7UUFDZjtRQUVBLE9BQU9MO0lBQ1Q7SUFFQTFILGFBQWE1QixPQUFPO1FBQUM7WUFDbkJjLEtBQUs7WUFDTGYsT0FBTyxTQUFTOEo7Z0JBQ2QsSUFBSTFDLFNBQVNELGFBQWEsSUFBSSxDQUFDM0YsS0FBSztnQkFDcEMsSUFBSXVJLGNBQWMsSUFBSSxDQUFDdkksS0FBSyxFQUN4QndJLGVBQWVELFlBQVlDLFlBQVksRUFDdkNDLGNBQWNGLFlBQVlFLFdBQVcsRUFDckNDLGVBQWVILFlBQVlHLFlBQVk7Z0JBQzNDLElBQUlDLGNBQWM7b0JBQ2hCSCxjQUFjQTtvQkFDZEMsYUFBYUE7b0JBQ2JDLGNBQWNBO2dCQUNoQjtnQkFDQSxPQUFPLFdBQVcsR0FBRWhLLE1BQU0sQ0FBQyxVQUFVLENBQUNvSSxhQUFhLENBQUMsT0FBTzlILFNBQVM7b0JBQ2xFb0osS0FBSyxJQUFJLENBQUNRLFNBQVM7b0JBQ25CM0IsV0FBVztvQkFDWDFDLE9BQU8sSUFBSSxDQUFDdkUsS0FBSyxDQUFDNkksVUFBVTtnQkFDOUIsR0FBR0YsY0FBYy9DO1lBQ25CO1FBQ0Y7S0FBRTtJQUVGLE9BQU9uSDtBQUNULEVBQUVDLE1BQU0sQ0FBQyxVQUFVLENBQUNvSyxhQUFhO0FBRWpDdkssYUFBYSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL3RyYWNrLmpzP2MwZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVHJhY2sgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsYXNzbmFtZXNcIikpO1xuXG52YXIgX2lubmVyU2xpZGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy9pbm5lclNsaWRlclV0aWxzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIGdpdmVuIHNwZWNpZmljYXRpb25zL3Byb3BzIGZvciBhIHNsaWRlLCBmZXRjaCBhbGwgdGhlIGNsYXNzZXMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNsaWRlXG52YXIgZ2V0U2xpZGVDbGFzc2VzID0gZnVuY3Rpb24gZ2V0U2xpZGVDbGFzc2VzKHNwZWMpIHtcbiAgdmFyIHNsaWNrQWN0aXZlLCBzbGlja0NlbnRlciwgc2xpY2tDbG9uZWQ7XG4gIHZhciBjZW50ZXJPZmZzZXQsIGluZGV4O1xuXG4gIGlmIChzcGVjLnJ0bCkge1xuICAgIGluZGV4ID0gc3BlYy5zbGlkZUNvdW50IC0gMSAtIHNwZWMuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggPSBzcGVjLmluZGV4O1xuICB9XG5cbiAgc2xpY2tDbG9uZWQgPSBpbmRleCA8IDAgfHwgaW5kZXggPj0gc3BlYy5zbGlkZUNvdW50O1xuXG4gIGlmIChzcGVjLmNlbnRlck1vZGUpIHtcbiAgICBjZW50ZXJPZmZzZXQgPSBNYXRoLmZsb29yKHNwZWMuc2xpZGVzVG9TaG93IC8gMik7XG4gICAgc2xpY2tDZW50ZXIgPSAoaW5kZXggLSBzcGVjLmN1cnJlbnRTbGlkZSkgJSBzcGVjLnNsaWRlQ291bnQgPT09IDA7XG5cbiAgICBpZiAoaW5kZXggPiBzcGVjLmN1cnJlbnRTbGlkZSAtIGNlbnRlck9mZnNldCAtIDEgJiYgaW5kZXggPD0gc3BlYy5jdXJyZW50U2xpZGUgKyBjZW50ZXJPZmZzZXQpIHtcbiAgICAgIHNsaWNrQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2xpY2tBY3RpdmUgPSBzcGVjLmN1cnJlbnRTbGlkZSA8PSBpbmRleCAmJiBpbmRleCA8IHNwZWMuY3VycmVudFNsaWRlICsgc3BlYy5zbGlkZXNUb1Nob3c7XG4gIH1cblxuICB2YXIgZm9jdXNlZFNsaWRlO1xuXG4gIGlmIChzcGVjLnRhcmdldFNsaWRlIDwgMCkge1xuICAgIGZvY3VzZWRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGUgKyBzcGVjLnNsaWRlQ291bnQ7XG4gIH0gZWxzZSBpZiAoc3BlYy50YXJnZXRTbGlkZSA+PSBzcGVjLnNsaWRlQ291bnQpIHtcbiAgICBmb2N1c2VkU2xpZGUgPSBzcGVjLnRhcmdldFNsaWRlIC0gc3BlYy5zbGlkZUNvdW50O1xuICB9IGVsc2Uge1xuICAgIGZvY3VzZWRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGU7XG4gIH1cblxuICB2YXIgc2xpY2tDdXJyZW50ID0gaW5kZXggPT09IGZvY3VzZWRTbGlkZTtcbiAgcmV0dXJuIHtcbiAgICBcInNsaWNrLXNsaWRlXCI6IHRydWUsXG4gICAgXCJzbGljay1hY3RpdmVcIjogc2xpY2tBY3RpdmUsXG4gICAgXCJzbGljay1jZW50ZXJcIjogc2xpY2tDZW50ZXIsXG4gICAgXCJzbGljay1jbG9uZWRcIjogc2xpY2tDbG9uZWQsXG4gICAgXCJzbGljay1jdXJyZW50XCI6IHNsaWNrQ3VycmVudCAvLyBkdWJpb3VzIGluIGNhc2Ugb2YgUlRMXG5cbiAgfTtcbn07XG5cbnZhciBnZXRTbGlkZVN0eWxlID0gZnVuY3Rpb24gZ2V0U2xpZGVTdHlsZShzcGVjKSB7XG4gIHZhciBzdHlsZSA9IHt9O1xuXG4gIGlmIChzcGVjLnZhcmlhYmxlV2lkdGggPT09IHVuZGVmaW5lZCB8fCBzcGVjLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSB7XG4gICAgc3R5bGUud2lkdGggPSBzcGVjLnNsaWRlV2lkdGg7XG4gIH1cblxuICBpZiAoc3BlYy5mYWRlKSB7XG4gICAgc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cbiAgICBpZiAoc3BlYy52ZXJ0aWNhbCkge1xuICAgICAgc3R5bGUudG9wID0gLXNwZWMuaW5kZXggKiBwYXJzZUludChzcGVjLnNsaWRlSGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUubGVmdCA9IC1zcGVjLmluZGV4ICogcGFyc2VJbnQoc3BlYy5zbGlkZVdpZHRoKTtcbiAgICB9XG5cbiAgICBzdHlsZS5vcGFjaXR5ID0gc3BlYy5jdXJyZW50U2xpZGUgPT09IHNwZWMuaW5kZXggPyAxIDogMDtcblxuICAgIGlmIChzcGVjLnVzZUNTUykge1xuICAgICAgc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSBcIiArIHNwZWMuc3BlZWQgKyBcIm1zIFwiICsgc3BlYy5jc3NFYXNlICsgXCIsIFwiICsgXCJ2aXNpYmlsaXR5IFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShjaGlsZCwgZmFsbGJhY2tLZXkpIHtcbiAgcmV0dXJuIGNoaWxkLmtleSB8fCBmYWxsYmFja0tleTtcbn07XG5cbnZhciByZW5kZXJTbGlkZXMgPSBmdW5jdGlvbiByZW5kZXJTbGlkZXMoc3BlYykge1xuICB2YXIga2V5O1xuICB2YXIgc2xpZGVzID0gW107XG4gIHZhciBwcmVDbG9uZVNsaWRlcyA9IFtdO1xuICB2YXIgcG9zdENsb25lU2xpZGVzID0gW107XG5cbiAgdmFyIGNoaWxkcmVuQ291bnQgPSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHNwZWMuY2hpbGRyZW4pO1xuXG4gIHZhciBzdGFydEluZGV4ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmxhenlTdGFydEluZGV4KShzcGVjKTtcbiAgdmFyIGVuZEluZGV4ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmxhenlFbmRJbmRleCkoc3BlYyk7XG5cbiAgX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5mb3JFYWNoKHNwZWMuY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtLCBpbmRleCkge1xuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgY2hpbGRPbkNsaWNrT3B0aW9ucyA9IHtcbiAgICAgIG1lc3NhZ2U6IFwiY2hpbGRyZW5cIixcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsOiBzcGVjLnNsaWRlc1RvU2Nyb2xsLFxuICAgICAgY3VycmVudFNsaWRlOiBzcGVjLmN1cnJlbnRTbGlkZVxuICAgIH07IC8vIGluIGNhc2Ugb2YgbGF6eUxvYWQsIHdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gZmV0Y2ggdGhlIHNsaWRlXG5cbiAgICBpZiAoIXNwZWMubGF6eUxvYWQgfHwgc3BlYy5sYXp5TG9hZCAmJiBzcGVjLmxhenlMb2FkZWRMaXN0LmluZGV4T2YoaW5kZXgpID49IDApIHtcbiAgICAgIGNoaWxkID0gZWxlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0eWxlID0gZ2V0U2xpZGVTdHlsZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSkpO1xuICAgIHZhciBzbGlkZUNsYXNzID0gY2hpbGQucHJvcHMuY2xhc3NOYW1lIHx8IFwiXCI7XG4gICAgdmFyIHNsaWRlQ2xhc3NlcyA9IGdldFNsaWRlQ2xhc3Nlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSkpOyAvLyBwdXNoIGEgY2xvbmVkIGVsZW1lbnQgb2YgdGhlIGRlc2lyZWQgc2xpZGVcblxuICAgIHNsaWRlcy5wdXNoKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIGtleTogXCJvcmlnaW5hbFwiICsgZ2V0S2V5KGNoaWxkLCBpbmRleCksXG4gICAgICBcImRhdGEtaW5kZXhcIjogaW5kZXgsXG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKHNsaWRlQ2xhc3Nlcywgc2xpZGVDbGFzcyksXG4gICAgICB0YWJJbmRleDogXCItMVwiLFxuICAgICAgXCJhcmlhLWhpZGRlblwiOiAhc2xpZGVDbGFzc2VzW1wic2xpY2stYWN0aXZlXCJdLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiXG4gICAgICB9LCBjaGlsZC5wcm9wcy5zdHlsZSB8fCB7fSksIGNoaWxkU3R5bGUpLFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLm9uQ2xpY2sgJiYgY2hpbGQucHJvcHMub25DbGljayhlKTtcblxuICAgICAgICBpZiAoc3BlYy5mb2N1c09uU2VsZWN0KSB7XG4gICAgICAgICAgc3BlYy5mb2N1c09uU2VsZWN0KGNoaWxkT25DbGlja09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpOyAvLyBpZiBzbGlkZSBuZWVkcyB0byBiZSBwcmVjbG9uZWQgb3IgcG9zdGNsb25lZFxuXG4gICAgaWYgKHNwZWMuaW5maW5pdGUgJiYgc3BlYy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgdmFyIHByZUNsb25lTm8gPSBjaGlsZHJlbkNvdW50IC0gaW5kZXg7XG5cbiAgICAgIGlmIChwcmVDbG9uZU5vIDw9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKHNwZWMpKSB7XG4gICAgICAgIGtleSA9IC1wcmVDbG9uZU5vO1xuXG4gICAgICAgIGlmIChrZXkgPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIGNoaWxkID0gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlQ2xhc3NlcyA9IGdldFNsaWRlQ2xhc3Nlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGluZGV4OiBrZXlcbiAgICAgICAgfSkpO1xuICAgICAgICBwcmVDbG9uZVNsaWRlcy5wdXNoKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICBrZXk6IFwicHJlY2xvbmVkXCIgKyBnZXRLZXkoY2hpbGQsIGtleSksXG4gICAgICAgICAgXCJkYXRhLWluZGV4XCI6IGtleSxcbiAgICAgICAgICB0YWJJbmRleDogXCItMVwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkoc2xpZGVDbGFzc2VzLCBzbGlkZUNsYXNzKSxcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6ICFzbGlkZUNsYXNzZXNbXCJzbGljay1hY3RpdmVcIl0sXG4gICAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQucHJvcHMuc3R5bGUgfHwge30pLCBjaGlsZFN0eWxlKSxcbiAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLm9uQ2xpY2sgJiYgY2hpbGQucHJvcHMub25DbGljayhlKTtcblxuICAgICAgICAgICAgaWYgKHNwZWMuZm9jdXNPblNlbGVjdCkge1xuICAgICAgICAgICAgICBzcGVjLmZvY3VzT25TZWxlY3QoY2hpbGRPbkNsaWNrT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGNoaWxkcmVuQ291bnQgKyBpbmRleDtcblxuICAgICAgaWYgKGtleSA8IGVuZEluZGV4KSB7XG4gICAgICAgIGNoaWxkID0gZWxlbTtcbiAgICAgIH1cblxuICAgICAgc2xpZGVDbGFzc2VzID0gZ2V0U2xpZGVDbGFzc2VzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICAgIGluZGV4OiBrZXlcbiAgICAgIH0pKTtcbiAgICAgIHBvc3RDbG9uZVNsaWRlcy5wdXNoKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAga2V5OiBcInBvc3RjbG9uZWRcIiArIGdldEtleShjaGlsZCwga2V5KSxcbiAgICAgICAgXCJkYXRhLWluZGV4XCI6IGtleSxcbiAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShzbGlkZUNsYXNzZXMsIHNsaWRlQ2xhc3MpLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6ICFzbGlkZUNsYXNzZXNbXCJzbGljay1hY3RpdmVcIl0sXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnByb3BzLnN0eWxlIHx8IHt9KSwgY2hpbGRTdHlsZSksXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAgIGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLm9uQ2xpY2sgJiYgY2hpbGQucHJvcHMub25DbGljayhlKTtcblxuICAgICAgICAgIGlmIChzcGVjLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgICAgIHNwZWMuZm9jdXNPblNlbGVjdChjaGlsZE9uQ2xpY2tPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzcGVjLnJ0bCkge1xuICAgIHJldHVybiBwcmVDbG9uZVNsaWRlcy5jb25jYXQoc2xpZGVzLCBwb3N0Q2xvbmVTbGlkZXMpLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlQ2xvbmVTbGlkZXMuY29uY2F0KHNsaWRlcywgcG9zdENsb25lU2xpZGVzKTtcbiAgfVxufTtcblxudmFyIFRyYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVHJhY2ssIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRyYWNrKTtcblxuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZVJlZlwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBfdGhpcy5ub2RlID0gcmVmO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYWNrLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHNsaWRlcyA9IHJlbmRlclNsaWRlcyh0aGlzLnByb3BzKTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICAgIG9uTW91c2VPdmVyID0gX3RoaXMkcHJvcHMub25Nb3VzZU92ZXIsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlO1xuICAgICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXI6IG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZVJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLXRyYWNrXCIsXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnRyYWNrU3R5bGVcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSwgc2xpZGVzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhY2s7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydHMuVHJhY2sgPSBUcmFjazsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRyYWNrIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xhc3NuYW1lcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0U2xpZGVDbGFzc2VzIiwic3BlYyIsInNsaWNrQWN0aXZlIiwic2xpY2tDZW50ZXIiLCJzbGlja0Nsb25lZCIsImNlbnRlck9mZnNldCIsImluZGV4IiwicnRsIiwic2xpZGVDb3VudCIsImNlbnRlck1vZGUiLCJNYXRoIiwiZmxvb3IiLCJzbGlkZXNUb1Nob3ciLCJjdXJyZW50U2xpZGUiLCJmb2N1c2VkU2xpZGUiLCJ0YXJnZXRTbGlkZSIsInNsaWNrQ3VycmVudCIsImdldFNsaWRlU3R5bGUiLCJzdHlsZSIsInZhcmlhYmxlV2lkdGgiLCJ1bmRlZmluZWQiLCJ3aWR0aCIsInNsaWRlV2lkdGgiLCJmYWRlIiwicG9zaXRpb24iLCJ2ZXJ0aWNhbCIsInRvcCIsInBhcnNlSW50Iiwic2xpZGVIZWlnaHQiLCJsZWZ0Iiwib3BhY2l0eSIsInVzZUNTUyIsInRyYW5zaXRpb24iLCJzcGVlZCIsImNzc0Vhc2UiLCJnZXRLZXkiLCJjaGlsZCIsImZhbGxiYWNrS2V5IiwicmVuZGVyU2xpZGVzIiwic2xpZGVzIiwicHJlQ2xvbmVTbGlkZXMiLCJwb3N0Q2xvbmVTbGlkZXMiLCJjaGlsZHJlbkNvdW50IiwiQ2hpbGRyZW4iLCJjb3VudCIsImNoaWxkcmVuIiwic3RhcnRJbmRleCIsImxhenlTdGFydEluZGV4IiwiZW5kSW5kZXgiLCJsYXp5RW5kSW5kZXgiLCJlbGVtIiwiY2hpbGRPbkNsaWNrT3B0aW9ucyIsIm1lc3NhZ2UiLCJzbGlkZXNUb1Njcm9sbCIsImxhenlMb2FkIiwibGF6eUxvYWRlZExpc3QiLCJpbmRleE9mIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkU3R5bGUiLCJzbGlkZUNsYXNzIiwiY2xhc3NOYW1lIiwic2xpZGVDbGFzc2VzIiwiY2xvbmVFbGVtZW50IiwidGFiSW5kZXgiLCJvdXRsaW5lIiwib25DbGljayIsImZvY3VzT25TZWxlY3QiLCJpbmZpbml0ZSIsInByZUNsb25lTm8iLCJnZXRQcmVDbG9uZXMiLCJjb25jYXQiLCJyZXZlcnNlIiwiX1JlYWN0JFB1cmVDb21wb25lbnQiLCJfc3VwZXIiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicmVmIiwibm9kZSIsInJlbmRlciIsIl90aGlzJHByb3BzIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlTGVhdmUiLCJtb3VzZUV2ZW50cyIsImhhbmRsZVJlZiIsInRyYWNrU3R5bGUiLCJQdXJlQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/track.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-slick/lib/utils/innerSliderUtils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;\nexports.clamp = clamp;\nexports.extractObject = void 0;\nexports.filterSettings = filterSettings;\nexports.validSettings = exports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _defaultProps = _interopRequireDefault(__webpack_require__(/*! ../default-props */ \"(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction clamp(number, lowerBound, upperBound) {\n    return Math.max(lowerBound, Math.min(number, upperBound));\n}\nvar safePreventDefault = function safePreventDefault(event) {\n    var passiveEvents = [\n        \"onTouchStart\",\n        \"onTouchMove\",\n        \"onWheel\"\n    ];\n    if (!passiveEvents.includes(event._reactName)) {\n        event.preventDefault();\n    }\n};\nexports.safePreventDefault = safePreventDefault;\nvar getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n    var onDemandSlides = [];\n    var startIndex = lazyStartIndex(spec);\n    var endIndex = lazyEndIndex(spec);\n    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){\n        if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n            onDemandSlides.push(slideIndex);\n        }\n    }\n    return onDemandSlides;\n}; // return list of slides that need to be present\nexports.getOnDemandLazySlides = getOnDemandLazySlides;\nvar getRequiredLazySlides = function getRequiredLazySlides(spec) {\n    var requiredSlides = [];\n    var startIndex = lazyStartIndex(spec);\n    var endIndex = lazyEndIndex(spec);\n    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){\n        requiredSlides.push(slideIndex);\n    }\n    return requiredSlides;\n}; // startIndex that needs to be present\nexports.getRequiredLazySlides = getRequiredLazySlides;\nvar lazyStartIndex = function lazyStartIndex(spec) {\n    return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nexports.lazyStartIndex = lazyStartIndex;\nvar lazyEndIndex = function lazyEndIndex(spec) {\n    return spec.currentSlide + lazySlidesOnRight(spec);\n};\nexports.lazyEndIndex = lazyEndIndex;\nvar lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n    return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nexports.lazySlidesOnLeft = lazySlidesOnLeft;\nvar lazySlidesOnRight = function lazySlidesOnRight(spec) {\n    return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n}; // get width of an element\nexports.lazySlidesOnRight = lazySlidesOnRight;\nvar getWidth = function getWidth(elem) {\n    return elem && elem.offsetWidth || 0;\n};\nexports.getWidth = getWidth;\nvar getHeight = function getHeight(elem) {\n    return elem && elem.offsetHeight || 0;\n};\nexports.getHeight = getHeight;\nvar getSwipeDirection = function getSwipeDirection(touchObject) {\n    var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var xDist, yDist, r, swipeAngle;\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n    swipeAngle = Math.round(r * 180 / Math.PI);\n    if (swipeAngle < 0) {\n        swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n        return \"left\";\n    }\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n        return \"right\";\n    }\n    if (verticalSwiping === true) {\n        if (swipeAngle >= 35 && swipeAngle <= 135) {\n            return \"up\";\n        } else {\n            return \"down\";\n        }\n    }\n    return \"vertical\";\n}; // whether or not we can go next\nexports.getSwipeDirection = getSwipeDirection;\nvar canGoNext = function canGoNext(spec) {\n    var canGo = true;\n    if (!spec.infinite) {\n        if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n            canGo = false;\n        } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n            canGo = false;\n        }\n    }\n    return canGo;\n}; // given an object and a list of keys, return new object with given keys\nexports.canGoNext = canGoNext;\nvar extractObject = function extractObject(spec, keys) {\n    var newObject = {};\n    keys.forEach(function(key) {\n        return newObject[key] = spec[key];\n    });\n    return newObject;\n}; // get initialized state\nexports.extractObject = extractObject;\nvar initializedState = function initializedState(spec) {\n    // spec also contains listRef, trackRef\n    var slideCount = _react[\"default\"].Children.count(spec.children);\n    var listNode = spec.listRef;\n    var listWidth = Math.ceil(getWidth(listNode));\n    var trackNode = spec.trackRef && spec.trackRef.node;\n    var trackWidth = Math.ceil(getWidth(trackNode));\n    var slideWidth;\n    if (!spec.vertical) {\n        var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n        if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n            centerPaddingAdj *= listWidth / 100;\n        }\n        slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n    } else {\n        slideWidth = listWidth;\n    }\n    var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * spec.slidesToShow;\n    var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n    if (spec.rtl && spec.currentSlide === undefined) {\n        currentSlide = slideCount - 1 - spec.initialSlide;\n    }\n    var lazyLoadedList = spec.lazyLoadedList || [];\n    var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n        currentSlide: currentSlide,\n        lazyLoadedList: lazyLoadedList\n    }));\n    lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n    var state = {\n        slideCount: slideCount,\n        slideWidth: slideWidth,\n        listWidth: listWidth,\n        trackWidth: trackWidth,\n        currentSlide: currentSlide,\n        slideHeight: slideHeight,\n        listHeight: listHeight,\n        lazyLoadedList: lazyLoadedList\n    };\n    if (spec.autoplaying === null && spec.autoplay) {\n        state[\"autoplaying\"] = \"playing\";\n    }\n    return state;\n};\nexports.initializedState = initializedState;\nvar slideHandler = function slideHandler(spec) {\n    var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;\n    var lazyLoadedList = spec.lazyLoadedList;\n    if (waitForAnimate && animating) return {};\n    var animationSlide = index, finalSlide, animationLeft, finalLeft;\n    var state = {}, nextState = {};\n    var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n    if (fade) {\n        if (!infinite && (index < 0 || index >= slideCount)) return {};\n        if (index < 0) {\n            animationSlide = index + slideCount;\n        } else if (index >= slideCount) {\n            animationSlide = index - slideCount;\n        }\n        if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n            lazyLoadedList = lazyLoadedList.concat(animationSlide);\n        }\n        state = {\n            animating: true,\n            currentSlide: animationSlide,\n            lazyLoadedList: lazyLoadedList,\n            targetSlide: animationSlide\n        };\n        nextState = {\n            animating: false,\n            targetSlide: animationSlide\n        };\n    } else {\n        finalSlide = animationSlide;\n        if (animationSlide < 0) {\n            finalSlide = animationSlide + slideCount;\n            if (!infinite) finalSlide = 0;\n            else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;\n        } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n            animationSlide = finalSlide = currentSlide;\n        } else if (centerMode && animationSlide >= slideCount) {\n            animationSlide = infinite ? slideCount : slideCount - 1;\n            finalSlide = infinite ? 0 : slideCount - 1;\n        } else if (animationSlide >= slideCount) {\n            finalSlide = animationSlide - slideCount;\n            if (!infinite) finalSlide = slideCount - slidesToShow;\n            else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n        }\n        if (!infinite && animationSlide + slidesToShow >= slideCount) {\n            finalSlide = slideCount - slidesToShow;\n        }\n        animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n            slideIndex: animationSlide\n        }));\n        finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n            slideIndex: finalSlide\n        }));\n        if (!infinite) {\n            if (animationLeft === finalLeft) animationSlide = finalSlide;\n            animationLeft = finalLeft;\n        }\n        if (lazyLoad) {\n            lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n                currentSlide: animationSlide\n            })));\n        }\n        if (!useCSS) {\n            state = {\n                currentSlide: finalSlide,\n                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: finalLeft\n                })),\n                lazyLoadedList: lazyLoadedList,\n                targetSlide: targetSlide\n            };\n        } else {\n            state = {\n                animating: true,\n                currentSlide: finalSlide,\n                trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: animationLeft\n                })),\n                lazyLoadedList: lazyLoadedList,\n                targetSlide: targetSlide\n            };\n            nextState = {\n                animating: false,\n                currentSlide: finalSlide,\n                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: finalLeft\n                })),\n                swipeLeft: null,\n                targetSlide: targetSlide\n            };\n        }\n    }\n    return {\n        state: state,\n        nextState: nextState\n    };\n};\nexports.slideHandler = slideHandler;\nvar changeSlide = function changeSlide(spec, options) {\n    var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n    var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;\n    unevenOffset = slideCount % slidesToScroll !== 0;\n    indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n    if (options.message === \"previous\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n        targetSlide = currentSlide - slideOffset;\n        if (lazyLoad && !infinite) {\n            previousInt = currentSlide - slideOffset;\n            targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n        }\n        if (!infinite) {\n            targetSlide = previousTargetSlide - slidesToScroll;\n        }\n    } else if (options.message === \"next\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n        targetSlide = currentSlide + slideOffset;\n        if (lazyLoad && !infinite) {\n            targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n        }\n        if (!infinite) {\n            targetSlide = previousTargetSlide + slidesToScroll;\n        }\n    } else if (options.message === \"dots\") {\n        // Click on dots\n        targetSlide = options.index * options.slidesToScroll;\n    } else if (options.message === \"children\") {\n        // Click on the slides\n        targetSlide = options.index;\n        if (infinite) {\n            var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n                targetSlide: targetSlide\n            }));\n            if (targetSlide > options.currentSlide && direction === \"left\") {\n                targetSlide = targetSlide - slideCount;\n            } else if (targetSlide < options.currentSlide && direction === \"right\") {\n                targetSlide = targetSlide + slideCount;\n            }\n        }\n    } else if (options.message === \"index\") {\n        targetSlide = Number(options.index);\n    }\n    return targetSlide;\n};\nexports.changeSlide = changeSlide;\nvar keyHandler = function keyHandler(e, accessibility, rtl) {\n    if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\";\n    if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n    if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n    return \"\";\n};\nexports.keyHandler = keyHandler;\nvar swipeStart = function swipeStart(e, swipe, draggable) {\n    e.target.tagName === \"IMG\" && safePreventDefault(e);\n    if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1) return \"\";\n    return {\n        dragging: true,\n        touchObject: {\n            startX: e.touches ? e.touches[0].pageX : e.clientX,\n            startY: e.touches ? e.touches[0].pageY : e.clientY,\n            curX: e.touches ? e.touches[0].pageX : e.clientX,\n            curY: e.touches ? e.touches[0].pageY : e.clientY\n        }\n    };\n};\nexports.swipeStart = swipeStart;\nvar swipeMove = function swipeMove(e, spec) {\n    // spec also contains, trackRef and slideIndex\n    var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;\n    if (scrolling) return;\n    if (animating) return safePreventDefault(e);\n    if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);\n    var swipeLeft, state = {};\n    var curLeft = getTrackLeft(spec);\n    touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n    touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n    touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n    var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n    if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n        return {\n            scrolling: true\n        };\n    }\n    if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n    var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n    if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n    var dotCount = Math.ceil(slideCount / slidesToScroll);\n    var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n    var touchSwipeLength = touchObject.swipeLength;\n    if (!infinite) {\n        if (currentSlide === 0 && (swipeDirection === \"right\" || swipeDirection === \"down\") || currentSlide + 1 >= dotCount && (swipeDirection === \"left\" || swipeDirection === \"up\") || !canGoNext(spec) && (swipeDirection === \"left\" || swipeDirection === \"up\")) {\n            touchSwipeLength = touchObject.swipeLength * edgeFriction;\n            if (edgeDragged === false && onEdge) {\n                onEdge(swipeDirection);\n                state[\"edgeDragged\"] = true;\n            }\n        }\n    }\n    if (!swiped && swipeEvent) {\n        swipeEvent(swipeDirection);\n        state[\"swiped\"] = true;\n    }\n    if (!vertical) {\n        if (!rtl) {\n            swipeLeft = curLeft + touchSwipeLength * positionOffset;\n        } else {\n            swipeLeft = curLeft - touchSwipeLength * positionOffset;\n        }\n    } else {\n        swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n    }\n    if (verticalSwiping) {\n        swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    }\n    state = _objectSpread(_objectSpread({}, state), {}, {\n        touchObject: touchObject,\n        swipeLeft: swipeLeft,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n            left: swipeLeft\n        }))\n    });\n    if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n        return state;\n    }\n    if (touchObject.swipeLength > 10) {\n        state[\"swiping\"] = true;\n        safePreventDefault(e);\n    }\n    return state;\n};\nexports.swipeMove = swipeMove;\nvar swipeEnd = function swipeEnd(e, spec) {\n    var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;\n    if (!dragging) {\n        if (swipe) safePreventDefault(e);\n        return {};\n    }\n    var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n    var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n    var state = {\n        dragging: false,\n        edgeDragged: false,\n        scrolling: false,\n        swiping: false,\n        swiped: false,\n        swipeLeft: null,\n        touchObject: {}\n    };\n    if (scrolling) {\n        return state;\n    }\n    if (!touchObject.swipeLength) {\n        return state;\n    }\n    if (touchObject.swipeLength > minSwipe) {\n        safePreventDefault(e);\n        if (onSwipe) {\n            onSwipe(swipeDirection);\n        }\n        var slideCount, newSlide;\n        var activeSlide = infinite ? currentSlide : targetSlide;\n        switch(swipeDirection){\n            case \"left\":\n            case \"up\":\n                newSlide = activeSlide + getSlideCount(spec);\n                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n                state[\"currentDirection\"] = 0;\n                break;\n            case \"right\":\n            case \"down\":\n                newSlide = activeSlide - getSlideCount(spec);\n                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n                state[\"currentDirection\"] = 1;\n                break;\n            default:\n                slideCount = activeSlide;\n        }\n        state[\"triggerSlideHandler\"] = slideCount;\n    } else {\n        // Adjust the track back to it's original position.\n        var currentLeft = getTrackLeft(spec);\n        state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n            left: currentLeft\n        }));\n    }\n    return state;\n};\nexports.swipeEnd = swipeEnd;\nvar getNavigableIndexes = function getNavigableIndexes(spec) {\n    var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n    var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n    var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n    var indexes = [];\n    while(breakpoint < max){\n        indexes.push(breakpoint);\n        breakpoint = counter + spec.slidesToScroll;\n        counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n    }\n    return indexes;\n};\nexports.getNavigableIndexes = getNavigableIndexes;\nvar checkNavigable = function checkNavigable(spec, index) {\n    var navigables = getNavigableIndexes(spec);\n    var prevNavigable = 0;\n    if (index > navigables[navigables.length - 1]) {\n        index = navigables[navigables.length - 1];\n    } else {\n        for(var n in navigables){\n            if (index < navigables[n]) {\n                index = prevNavigable;\n                break;\n            }\n            prevNavigable = navigables[n];\n        }\n    }\n    return index;\n};\nexports.checkNavigable = checkNavigable;\nvar getSlideCount = function getSlideCount(spec) {\n    var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n    if (spec.swipeToSlide) {\n        var swipedSlide;\n        var slickList = spec.listRef;\n        var slides = slickList.querySelectorAll && slickList.querySelectorAll(\".slick-slide\") || [];\n        Array.from(slides).every(function(slide) {\n            if (!spec.vertical) {\n                if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            } else {\n                if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            }\n            return true;\n        });\n        if (!swipedSlide) {\n            return 0;\n        }\n        var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n        var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n        return slidesTraversed;\n    } else {\n        return spec.slidesToScroll;\n    }\n};\nexports.getSlideCount = getSlideCount;\nvar checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n    return keysArray.reduce(function(value, key) {\n        return value && spec.hasOwnProperty(key);\n    }, true) ? null : console.error(\"Keys Missing:\", spec);\n};\nexports.checkSpecKeys = checkSpecKeys;\nvar getTrackCSS = function getTrackCSS(spec) {\n    checkSpecKeys(spec, [\n        \"left\",\n        \"variableWidth\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slideWidth\"\n    ]);\n    var trackWidth, trackHeight;\n    var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n    if (!spec.vertical) {\n        trackWidth = getTotalSlides(spec) * spec.slideWidth;\n    } else {\n        trackHeight = trackChildren * spec.slideHeight;\n    }\n    var style = {\n        opacity: 1,\n        transition: \"\",\n        WebkitTransition: \"\"\n    };\n    if (spec.useTransform) {\n        var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n        style = _objectSpread(_objectSpread({}, style), {}, {\n            WebkitTransform: WebkitTransform,\n            transform: transform,\n            msTransform: msTransform\n        });\n    } else {\n        if (spec.vertical) {\n            style[\"top\"] = spec.left;\n        } else {\n            style[\"left\"] = spec.left;\n        }\n    }\n    if (spec.fade) style = {\n        opacity: 1\n    };\n    if (trackWidth) style.width = trackWidth;\n    if (trackHeight) style.height = trackHeight; // Fallback for IE8\n    if (window && !window.addEventListener && window.attachEvent) {\n        if (!spec.vertical) {\n            style.marginLeft = spec.left + \"px\";\n        } else {\n            style.marginTop = spec.left + \"px\";\n        }\n    }\n    return style;\n};\nexports.getTrackCSS = getTrackCSS;\nvar getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n    checkSpecKeys(spec, [\n        \"left\",\n        \"variableWidth\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slideWidth\",\n        \"speed\",\n        \"cssEase\"\n    ]);\n    var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n    if (spec.useTransform) {\n        style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n        style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n        if (spec.vertical) {\n            style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n        } else {\n            style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n    }\n    return style;\n};\nexports.getTrackAnimateCSS = getTrackAnimateCSS;\nvar getTrackLeft = function getTrackLeft(spec) {\n    if (spec.unslick) {\n        return 0;\n    }\n    checkSpecKeys(spec, [\n        \"slideIndex\",\n        \"trackRef\",\n        \"infinite\",\n        \"centerMode\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slidesToScroll\",\n        \"slideWidth\",\n        \"listWidth\",\n        \"variableWidth\",\n        \"slideHeight\"\n    ]);\n    var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;\n    var slideOffset = 0;\n    var targetLeft;\n    var targetSlide;\n    var verticalOffset = 0;\n    if (fade || spec.slideCount === 1) {\n        return 0;\n    }\n    var slidesToOffset = 0;\n    if (infinite) {\n        slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n        // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n            slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n        } // shift current slide to center of the frame\n        if (centerMode) {\n            slidesToOffset += parseInt(slidesToShow / 2);\n        }\n    } else {\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n            slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n        }\n        if (centerMode) {\n            slidesToOffset = parseInt(slidesToShow / 2);\n        }\n    }\n    slideOffset = slidesToOffset * slideWidth;\n    verticalOffset = slidesToOffset * slideHeight;\n    if (!vertical) {\n        targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n    } else {\n        targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n    }\n    if (variableWidth === true) {\n        var targetSlideIndex;\n        var trackElem = trackRef && trackRef.node;\n        targetSlideIndex = slideIndex + getPreClones(spec);\n        targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n        targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n        if (centerMode === true) {\n            targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n            targetSlide = trackElem && trackElem.children[targetSlideIndex];\n            targetLeft = 0;\n            for(var slide = 0; slide < targetSlideIndex; slide++){\n                targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n            }\n            targetLeft -= parseInt(spec.centerPadding);\n            targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n        }\n    }\n    return targetLeft;\n};\nexports.getTrackLeft = getTrackLeft;\nvar getPreClones = function getPreClones(spec) {\n    if (spec.unslick || !spec.infinite) {\n        return 0;\n    }\n    if (spec.variableWidth) {\n        return spec.slideCount;\n    }\n    return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexports.getPreClones = getPreClones;\nvar getPostClones = function getPostClones(spec) {\n    if (spec.unslick || !spec.infinite) {\n        return 0;\n    }\n    return spec.slideCount;\n};\nexports.getPostClones = getPostClones;\nvar getTotalSlides = function getTotalSlides(spec) {\n    return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nexports.getTotalSlides = getTotalSlides;\nvar siblingDirection = function siblingDirection(spec) {\n    if (spec.targetSlide > spec.currentSlide) {\n        if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n            return \"left\";\n        }\n        return \"right\";\n    } else {\n        if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n            return \"right\";\n        }\n        return \"left\";\n    }\n};\nexports.siblingDirection = siblingDirection;\nvar slidesOnRight = function slidesOnRight(_ref) {\n    var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;\n    // returns no of slides on the right of active slide\n    if (centerMode) {\n        var right = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0) right += 1;\n        if (rtl && slidesToShow % 2 === 0) right += 1;\n        return right;\n    }\n    if (rtl) {\n        return 0;\n    }\n    return slidesToShow - 1;\n};\nexports.slidesOnRight = slidesOnRight;\nvar slidesOnLeft = function slidesOnLeft(_ref2) {\n    var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;\n    // returns no of slides on the left of active slide\n    if (centerMode) {\n        var left = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0) left += 1;\n        if (!rtl && slidesToShow % 2 === 0) left += 1;\n        return left;\n    }\n    if (rtl) {\n        return slidesToShow - 1;\n    }\n    return 0;\n};\nexports.slidesOnLeft = slidesOnLeft;\nvar canUseDOM = function canUseDOM() {\n    return !!( true && window.document && window.document.createElement);\n};\nexports.canUseDOM = canUseDOM;\nvar validSettings = Object.keys(_defaultProps[\"default\"]);\nexports.validSettings = validSettings;\nfunction filterSettings(settings) {\n    return validSettings.reduce(function(acc, settingName) {\n        if (settings.hasOwnProperty(settingName)) {\n            acc[settingName] = settings[settingName];\n        }\n        return acc;\n    }, {});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvdXRpbHMvaW5uZXJTbGlkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDcEhBLGFBQWEsR0FBR087QUFDaEJQLHFCQUFxQixHQUFHLEtBQUs7QUFDN0JBLHNCQUFzQixHQUFHUztBQUN6QlQscUJBQXFCLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHFCQUFxQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLHdCQUF3QixHQUFHQSwwQkFBMEIsR0FBR0Esc0JBQXNCLEdBQUdBLHlCQUF5QixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSx3QkFBd0IsR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0EsMEJBQTBCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBR0EscUJBQXFCLEdBQUdBLDZCQUE2QixHQUFHQSxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLDZCQUE2QixHQUFHQSwyQkFBMkIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUV6ckIsSUFBSXNDLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsbUZBQU87QUFFbkQsSUFBSUMsZ0JBQWdCRix1QkFBdUJDLG1CQUFPQSxDQUFDLDZGQUFrQjtBQUVyRSxTQUFTRCx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsU0FBU0UsUUFBUUMsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBT2pELE9B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QWF3SyxNQUFNeEssVUFBVSxFQUM3QjhDLE1BQU0wSCxNQUFNMUgsR0FBRyxFQUNmMUMsZ0JBQWdCb0ssTUFBTXBLLGFBQWE7SUFFdkMsbURBQW1EO0lBQ25ELElBQUlKLFlBQVk7UUFDZCxJQUFJa0UsT0FBTyxDQUFDaEUsZUFBZSxLQUFLLElBQUk7UUFDcEMsSUFBSUMsU0FBU0MsaUJBQWlCLEdBQUc4RCxRQUFRO1FBQ3pDLElBQUksQ0FBQ3BCLE9BQU81QyxlQUFlLE1BQU0sR0FBR2dFLFFBQVE7UUFDNUMsT0FBT0E7SUFDVDtJQUVBLElBQUlwQixLQUFLO1FBQ1AsT0FBTzVDLGVBQWU7SUFDeEI7SUFFQSxPQUFPO0FBQ1Q7QUFFQTNGLG9CQUFvQixHQUFHZTtBQUV2QixJQUFJVixZQUFZLFNBQVNBO0lBQ3ZCLE9BQU8sQ0FBQyxDQUFFLE1BQTZCLElBQUkyTyxPQUFPa0IsUUFBUSxJQUFJbEIsT0FBT2tCLFFBQVEsQ0FBQ0MsYUFBYTtBQUM3RjtBQUVBblEsaUJBQWlCLEdBQUdLO0FBQ3BCLElBQUlLLGdCQUFnQlosT0FBT2lELElBQUksQ0FBQ04sYUFBYSxDQUFDLFVBQVU7QUFDeER6QyxxQkFBcUIsR0FBR1U7QUFFeEIsU0FBU0QsZUFBZTJQLFFBQVE7SUFDOUIsT0FBTzFQLGNBQWNzTixNQUFNLENBQUMsU0FBVXFDLEdBQUcsRUFBRUMsV0FBVztRQUNwRCxJQUFJRixTQUFTbkMsY0FBYyxDQUFDcUMsY0FBYztZQUN4Q0QsR0FBRyxDQUFDQyxZQUFZLEdBQUdGLFFBQVEsQ0FBQ0UsWUFBWTtRQUMxQztRQUVBLE9BQU9EO0lBQ1QsR0FBRyxDQUFDO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi91dGlscy9pbm5lclNsaWRlclV0aWxzLmpzP2E5OWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNoZWNrU3BlY0tleXMgPSBleHBvcnRzLmNoZWNrTmF2aWdhYmxlID0gZXhwb3J0cy5jaGFuZ2VTbGlkZSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Hb05leHQgPSB2b2lkIDA7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5leHBvcnRzLmV4dHJhY3RPYmplY3QgPSB2b2lkIDA7XG5leHBvcnRzLmZpbHRlclNldHRpbmdzID0gZmlsdGVyU2V0dGluZ3M7XG5leHBvcnRzLnZhbGlkU2V0dGluZ3MgPSBleHBvcnRzLnN3aXBlU3RhcnQgPSBleHBvcnRzLnN3aXBlTW92ZSA9IGV4cG9ydHMuc3dpcGVFbmQgPSBleHBvcnRzLnNsaWRlc09uUmlnaHQgPSBleHBvcnRzLnNsaWRlc09uTGVmdCA9IGV4cG9ydHMuc2xpZGVIYW5kbGVyID0gZXhwb3J0cy5zaWJsaW5nRGlyZWN0aW9uID0gZXhwb3J0cy5zYWZlUHJldmVudERlZmF1bHQgPSBleHBvcnRzLmxhenlTdGFydEluZGV4ID0gZXhwb3J0cy5sYXp5U2xpZGVzT25SaWdodCA9IGV4cG9ydHMubGF6eVNsaWRlc09uTGVmdCA9IGV4cG9ydHMubGF6eUVuZEluZGV4ID0gZXhwb3J0cy5rZXlIYW5kbGVyID0gZXhwb3J0cy5pbml0aWFsaXplZFN0YXRlID0gZXhwb3J0cy5nZXRXaWR0aCA9IGV4cG9ydHMuZ2V0VHJhY2tMZWZ0ID0gZXhwb3J0cy5nZXRUcmFja0NTUyA9IGV4cG9ydHMuZ2V0VHJhY2tBbmltYXRlQ1NTID0gZXhwb3J0cy5nZXRUb3RhbFNsaWRlcyA9IGV4cG9ydHMuZ2V0U3dpcGVEaXJlY3Rpb24gPSBleHBvcnRzLmdldFNsaWRlQ291bnQgPSBleHBvcnRzLmdldFJlcXVpcmVkTGF6eVNsaWRlcyA9IGV4cG9ydHMuZ2V0UHJlQ2xvbmVzID0gZXhwb3J0cy5nZXRQb3N0Q2xvbmVzID0gZXhwb3J0cy5nZXRPbkRlbWFuZExhenlTbGlkZXMgPSBleHBvcnRzLmdldE5hdmlnYWJsZUluZGV4ZXMgPSBleHBvcnRzLmdldEhlaWdodCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9kZWZhdWx0UHJvcHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWZhdWx0LXByb3BzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5tYXgobG93ZXJCb3VuZCwgTWF0aC5taW4obnVtYmVyLCB1cHBlckJvdW5kKSk7XG59XG5cbnZhciBzYWZlUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBzYWZlUHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgdmFyIHBhc3NpdmVFdmVudHMgPSBbXCJvblRvdWNoU3RhcnRcIiwgXCJvblRvdWNoTW92ZVwiLCBcIm9uV2hlZWxcIl07XG5cbiAgaWYgKCFwYXNzaXZlRXZlbnRzLmluY2x1ZGVzKGV2ZW50Ll9yZWFjdE5hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zYWZlUHJldmVudERlZmF1bHQgPSBzYWZlUHJldmVudERlZmF1bHQ7XG5cbnZhciBnZXRPbkRlbWFuZExhenlTbGlkZXMgPSBmdW5jdGlvbiBnZXRPbkRlbWFuZExhenlTbGlkZXMoc3BlYykge1xuICB2YXIgb25EZW1hbmRTbGlkZXMgPSBbXTtcbiAgdmFyIHN0YXJ0SW5kZXggPSBsYXp5U3RhcnRJbmRleChzcGVjKTtcbiAgdmFyIGVuZEluZGV4ID0gbGF6eUVuZEluZGV4KHNwZWMpO1xuXG4gIGZvciAodmFyIHNsaWRlSW5kZXggPSBzdGFydEluZGV4OyBzbGlkZUluZGV4IDwgZW5kSW5kZXg7IHNsaWRlSW5kZXgrKykge1xuICAgIGlmIChzcGVjLmxhenlMb2FkZWRMaXN0LmluZGV4T2Yoc2xpZGVJbmRleCkgPCAwKSB7XG4gICAgICBvbkRlbWFuZFNsaWRlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvbkRlbWFuZFNsaWRlcztcbn07IC8vIHJldHVybiBsaXN0IG9mIHNsaWRlcyB0aGF0IG5lZWQgdG8gYmUgcHJlc2VudFxuXG5cbmV4cG9ydHMuZ2V0T25EZW1hbmRMYXp5U2xpZGVzID0gZ2V0T25EZW1hbmRMYXp5U2xpZGVzO1xuXG52YXIgZ2V0UmVxdWlyZWRMYXp5U2xpZGVzID0gZnVuY3Rpb24gZ2V0UmVxdWlyZWRMYXp5U2xpZGVzKHNwZWMpIHtcbiAgdmFyIHJlcXVpcmVkU2xpZGVzID0gW107XG4gIHZhciBzdGFydEluZGV4ID0gbGF6eVN0YXJ0SW5kZXgoc3BlYyk7XG4gIHZhciBlbmRJbmRleCA9IGxhenlFbmRJbmRleChzcGVjKTtcblxuICBmb3IgKHZhciBzbGlkZUluZGV4ID0gc3RhcnRJbmRleDsgc2xpZGVJbmRleCA8IGVuZEluZGV4OyBzbGlkZUluZGV4KyspIHtcbiAgICByZXF1aXJlZFNsaWRlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVkU2xpZGVzO1xufTsgLy8gc3RhcnRJbmRleCB0aGF0IG5lZWRzIHRvIGJlIHByZXNlbnRcblxuXG5leHBvcnRzLmdldFJlcXVpcmVkTGF6eVNsaWRlcyA9IGdldFJlcXVpcmVkTGF6eVNsaWRlcztcblxudmFyIGxhenlTdGFydEluZGV4ID0gZnVuY3Rpb24gbGF6eVN0YXJ0SW5kZXgoc3BlYykge1xuICByZXR1cm4gc3BlYy5jdXJyZW50U2xpZGUgLSBsYXp5U2xpZGVzT25MZWZ0KHNwZWMpO1xufTtcblxuZXhwb3J0cy5sYXp5U3RhcnRJbmRleCA9IGxhenlTdGFydEluZGV4O1xuXG52YXIgbGF6eUVuZEluZGV4ID0gZnVuY3Rpb24gbGF6eUVuZEluZGV4KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY3VycmVudFNsaWRlICsgbGF6eVNsaWRlc09uUmlnaHQoc3BlYyk7XG59O1xuXG5leHBvcnRzLmxhenlFbmRJbmRleCA9IGxhenlFbmRJbmRleDtcblxudmFyIGxhenlTbGlkZXNPbkxlZnQgPSBmdW5jdGlvbiBsYXp5U2xpZGVzT25MZWZ0KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY2VudGVyTW9kZSA/IE1hdGguZmxvb3Ioc3BlYy5zbGlkZXNUb1Nob3cgLyAyKSArIChwYXJzZUludChzcGVjLmNlbnRlclBhZGRpbmcpID4gMCA/IDEgOiAwKSA6IDA7XG59O1xuXG5leHBvcnRzLmxhenlTbGlkZXNPbkxlZnQgPSBsYXp5U2xpZGVzT25MZWZ0O1xuXG52YXIgbGF6eVNsaWRlc09uUmlnaHQgPSBmdW5jdGlvbiBsYXp5U2xpZGVzT25SaWdodChzcGVjKSB7XG4gIHJldHVybiBzcGVjLmNlbnRlck1vZGUgPyBNYXRoLmZsb29yKChzcGVjLnNsaWRlc1RvU2hvdyAtIDEpIC8gMikgKyAxICsgKHBhcnNlSW50KHNwZWMuY2VudGVyUGFkZGluZykgPiAwID8gMSA6IDApIDogc3BlYy5zbGlkZXNUb1Nob3c7XG59OyAvLyBnZXQgd2lkdGggb2YgYW4gZWxlbWVudFxuXG5cbmV4cG9ydHMubGF6eVNsaWRlc09uUmlnaHQgPSBsYXp5U2xpZGVzT25SaWdodDtcblxudmFyIGdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICByZXR1cm4gZWxlbSAmJiBlbGVtLm9mZnNldFdpZHRoIHx8IDA7XG59O1xuXG5leHBvcnRzLmdldFdpZHRoID0gZ2V0V2lkdGg7XG5cbnZhciBnZXRIZWlnaHQgPSBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbSkge1xuICByZXR1cm4gZWxlbSAmJiBlbGVtLm9mZnNldEhlaWdodCB8fCAwO1xufTtcblxuZXhwb3J0cy5nZXRIZWlnaHQgPSBnZXRIZWlnaHQ7XG5cbnZhciBnZXRTd2lwZURpcmVjdGlvbiA9IGZ1bmN0aW9uIGdldFN3aXBlRGlyZWN0aW9uKHRvdWNoT2JqZWN0KSB7XG4gIHZhciB2ZXJ0aWNhbFN3aXBpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgeERpc3QsIHlEaXN0LCByLCBzd2lwZUFuZ2xlO1xuICB4RGlzdCA9IHRvdWNoT2JqZWN0LnN0YXJ0WCAtIHRvdWNoT2JqZWN0LmN1clg7XG4gIHlEaXN0ID0gdG91Y2hPYmplY3Quc3RhcnRZIC0gdG91Y2hPYmplY3QuY3VyWTtcbiAgciA9IE1hdGguYXRhbjIoeURpc3QsIHhEaXN0KTtcbiAgc3dpcGVBbmdsZSA9IE1hdGgucm91bmQociAqIDE4MCAvIE1hdGguUEkpO1xuXG4gIGlmIChzd2lwZUFuZ2xlIDwgMCkge1xuICAgIHN3aXBlQW5nbGUgPSAzNjAgLSBNYXRoLmFicyhzd2lwZUFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzd2lwZUFuZ2xlIDw9IDQ1ICYmIHN3aXBlQW5nbGUgPj0gMCB8fCBzd2lwZUFuZ2xlIDw9IDM2MCAmJiBzd2lwZUFuZ2xlID49IDMxNSkge1xuICAgIHJldHVybiBcImxlZnRcIjtcbiAgfVxuXG4gIGlmIChzd2lwZUFuZ2xlID49IDEzNSAmJiBzd2lwZUFuZ2xlIDw9IDIyNSkge1xuICAgIHJldHVybiBcInJpZ2h0XCI7XG4gIH1cblxuICBpZiAodmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgaWYgKHN3aXBlQW5nbGUgPj0gMzUgJiYgc3dpcGVBbmdsZSA8PSAxMzUpIHtcbiAgICAgIHJldHVybiBcInVwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImRvd25cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xufTsgLy8gd2hldGhlciBvciBub3Qgd2UgY2FuIGdvIG5leHRcblxuXG5leHBvcnRzLmdldFN3aXBlRGlyZWN0aW9uID0gZ2V0U3dpcGVEaXJlY3Rpb247XG5cbnZhciBjYW5Hb05leHQgPSBmdW5jdGlvbiBjYW5Hb05leHQoc3BlYykge1xuICB2YXIgY2FuR28gPSB0cnVlO1xuXG4gIGlmICghc3BlYy5pbmZpbml0ZSkge1xuICAgIGlmIChzcGVjLmNlbnRlck1vZGUgJiYgc3BlYy5jdXJyZW50U2xpZGUgPj0gc3BlYy5zbGlkZUNvdW50IC0gMSkge1xuICAgICAgY2FuR28gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNwZWMuc2xpZGVDb3VudCA8PSBzcGVjLnNsaWRlc1RvU2hvdyB8fCBzcGVjLmN1cnJlbnRTbGlkZSA+PSBzcGVjLnNsaWRlQ291bnQgLSBzcGVjLnNsaWRlc1RvU2hvdykge1xuICAgICAgY2FuR28gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuR287XG59OyAvLyBnaXZlbiBhbiBvYmplY3QgYW5kIGEgbGlzdCBvZiBrZXlzLCByZXR1cm4gbmV3IG9iamVjdCB3aXRoIGdpdmVuIGtleXNcblxuXG5leHBvcnRzLmNhbkdvTmV4dCA9IGNhbkdvTmV4dDtcblxudmFyIGV4dHJhY3RPYmplY3QgPSBmdW5jdGlvbiBleHRyYWN0T2JqZWN0KHNwZWMsIGtleXMpIHtcbiAgdmFyIG5ld09iamVjdCA9IHt9O1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXdPYmplY3Rba2V5XSA9IHNwZWNba2V5XTtcbiAgfSk7XG4gIHJldHVybiBuZXdPYmplY3Q7XG59OyAvLyBnZXQgaW5pdGlhbGl6ZWQgc3RhdGVcblxuXG5leHBvcnRzLmV4dHJhY3RPYmplY3QgPSBleHRyYWN0T2JqZWN0O1xuXG52YXIgaW5pdGlhbGl6ZWRTdGF0ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemVkU3RhdGUoc3BlYykge1xuICAvLyBzcGVjIGFsc28gY29udGFpbnMgbGlzdFJlZiwgdHJhY2tSZWZcbiAgdmFyIHNsaWRlQ291bnQgPSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHNwZWMuY2hpbGRyZW4pO1xuXG4gIHZhciBsaXN0Tm9kZSA9IHNwZWMubGlzdFJlZjtcbiAgdmFyIGxpc3RXaWR0aCA9IE1hdGguY2VpbChnZXRXaWR0aChsaXN0Tm9kZSkpO1xuICB2YXIgdHJhY2tOb2RlID0gc3BlYy50cmFja1JlZiAmJiBzcGVjLnRyYWNrUmVmLm5vZGU7XG4gIHZhciB0cmFja1dpZHRoID0gTWF0aC5jZWlsKGdldFdpZHRoKHRyYWNrTm9kZSkpO1xuICB2YXIgc2xpZGVXaWR0aDtcblxuICBpZiAoIXNwZWMudmVydGljYWwpIHtcbiAgICB2YXIgY2VudGVyUGFkZGluZ0FkaiA9IHNwZWMuY2VudGVyTW9kZSAmJiBwYXJzZUludChzcGVjLmNlbnRlclBhZGRpbmcpICogMjtcblxuICAgIGlmICh0eXBlb2Ygc3BlYy5jZW50ZXJQYWRkaW5nID09PSBcInN0cmluZ1wiICYmIHNwZWMuY2VudGVyUGFkZGluZy5zbGljZSgtMSkgPT09IFwiJVwiKSB7XG4gICAgICBjZW50ZXJQYWRkaW5nQWRqICo9IGxpc3RXaWR0aCAvIDEwMDtcbiAgICB9XG5cbiAgICBzbGlkZVdpZHRoID0gTWF0aC5jZWlsKChsaXN0V2lkdGggLSBjZW50ZXJQYWRkaW5nQWRqKSAvIHNwZWMuc2xpZGVzVG9TaG93KTtcbiAgfSBlbHNlIHtcbiAgICBzbGlkZVdpZHRoID0gbGlzdFdpZHRoO1xuICB9XG5cbiAgdmFyIHNsaWRlSGVpZ2h0ID0gbGlzdE5vZGUgJiYgZ2V0SGVpZ2h0KGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWluZGV4PVwiMFwiXScpKTtcbiAgdmFyIGxpc3RIZWlnaHQgPSBzbGlkZUhlaWdodCAqIHNwZWMuc2xpZGVzVG9TaG93O1xuICB2YXIgY3VycmVudFNsaWRlID0gc3BlYy5jdXJyZW50U2xpZGUgPT09IHVuZGVmaW5lZCA/IHNwZWMuaW5pdGlhbFNsaWRlIDogc3BlYy5jdXJyZW50U2xpZGU7XG5cbiAgaWYgKHNwZWMucnRsICYmIHNwZWMuY3VycmVudFNsaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBjdXJyZW50U2xpZGUgPSBzbGlkZUNvdW50IC0gMSAtIHNwZWMuaW5pdGlhbFNsaWRlO1xuICB9XG5cbiAgdmFyIGxhenlMb2FkZWRMaXN0ID0gc3BlYy5sYXp5TG9hZGVkTGlzdCB8fCBbXTtcbiAgdmFyIHNsaWRlc1RvTG9hZCA9IGdldE9uRGVtYW5kTGF6eVNsaWRlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgIGN1cnJlbnRTbGlkZTogY3VycmVudFNsaWRlLFxuICAgIGxhenlMb2FkZWRMaXN0OiBsYXp5TG9hZGVkTGlzdFxuICB9KSk7XG4gIGxhenlMb2FkZWRMaXN0ID0gbGF6eUxvYWRlZExpc3QuY29uY2F0KHNsaWRlc1RvTG9hZCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBzbGlkZUNvdW50OiBzbGlkZUNvdW50LFxuICAgIHNsaWRlV2lkdGg6IHNsaWRlV2lkdGgsXG4gICAgbGlzdFdpZHRoOiBsaXN0V2lkdGgsXG4gICAgdHJhY2tXaWR0aDogdHJhY2tXaWR0aCxcbiAgICBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZSxcbiAgICBzbGlkZUhlaWdodDogc2xpZGVIZWlnaHQsXG4gICAgbGlzdEhlaWdodDogbGlzdEhlaWdodCxcbiAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3RcbiAgfTtcblxuICBpZiAoc3BlYy5hdXRvcGxheWluZyA9PT0gbnVsbCAmJiBzcGVjLmF1dG9wbGF5KSB7XG4gICAgc3RhdGVbXCJhdXRvcGxheWluZ1wiXSA9IFwicGxheWluZ1wiO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuZXhwb3J0cy5pbml0aWFsaXplZFN0YXRlID0gaW5pdGlhbGl6ZWRTdGF0ZTtcblxudmFyIHNsaWRlSGFuZGxlciA9IGZ1bmN0aW9uIHNsaWRlSGFuZGxlcihzcGVjKSB7XG4gIHZhciB3YWl0Rm9yQW5pbWF0ZSA9IHNwZWMud2FpdEZvckFuaW1hdGUsXG4gICAgICBhbmltYXRpbmcgPSBzcGVjLmFuaW1hdGluZyxcbiAgICAgIGZhZGUgPSBzcGVjLmZhZGUsXG4gICAgICBpbmZpbml0ZSA9IHNwZWMuaW5maW5pdGUsXG4gICAgICBpbmRleCA9IHNwZWMuaW5kZXgsXG4gICAgICBzbGlkZUNvdW50ID0gc3BlYy5zbGlkZUNvdW50LFxuICAgICAgbGF6eUxvYWQgPSBzcGVjLmxhenlMb2FkLFxuICAgICAgY3VycmVudFNsaWRlID0gc3BlYy5jdXJyZW50U2xpZGUsXG4gICAgICBjZW50ZXJNb2RlID0gc3BlYy5jZW50ZXJNb2RlLFxuICAgICAgc2xpZGVzVG9TY3JvbGwgPSBzcGVjLnNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2xpZGVzVG9TaG93ID0gc3BlYy5zbGlkZXNUb1Nob3csXG4gICAgICB1c2VDU1MgPSBzcGVjLnVzZUNTUztcbiAgdmFyIGxhenlMb2FkZWRMaXN0ID0gc3BlYy5sYXp5TG9hZGVkTGlzdDtcbiAgaWYgKHdhaXRGb3JBbmltYXRlICYmIGFuaW1hdGluZykgcmV0dXJuIHt9O1xuICB2YXIgYW5pbWF0aW9uU2xpZGUgPSBpbmRleCxcbiAgICAgIGZpbmFsU2xpZGUsXG4gICAgICBhbmltYXRpb25MZWZ0LFxuICAgICAgZmluYWxMZWZ0O1xuICB2YXIgc3RhdGUgPSB7fSxcbiAgICAgIG5leHRTdGF0ZSA9IHt9O1xuICB2YXIgdGFyZ2V0U2xpZGUgPSBpbmZpbml0ZSA/IGluZGV4IDogY2xhbXAoaW5kZXgsIDAsIHNsaWRlQ291bnQgLSAxKTtcblxuICBpZiAoZmFkZSkge1xuICAgIGlmICghaW5maW5pdGUgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzbGlkZUNvdW50KSkgcmV0dXJuIHt9O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgYW5pbWF0aW9uU2xpZGUgPSBpbmRleCArIHNsaWRlQ291bnQ7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSBzbGlkZUNvdW50KSB7XG4gICAgICBhbmltYXRpb25TbGlkZSA9IGluZGV4IC0gc2xpZGVDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobGF6eUxvYWQgJiYgbGF6eUxvYWRlZExpc3QuaW5kZXhPZihhbmltYXRpb25TbGlkZSkgPCAwKSB7XG4gICAgICBsYXp5TG9hZGVkTGlzdCA9IGxhenlMb2FkZWRMaXN0LmNvbmNhdChhbmltYXRpb25TbGlkZSk7XG4gICAgfVxuXG4gICAgc3RhdGUgPSB7XG4gICAgICBhbmltYXRpbmc6IHRydWUsXG4gICAgICBjdXJyZW50U2xpZGU6IGFuaW1hdGlvblNsaWRlLFxuICAgICAgbGF6eUxvYWRlZExpc3Q6IGxhenlMb2FkZWRMaXN0LFxuICAgICAgdGFyZ2V0U2xpZGU6IGFuaW1hdGlvblNsaWRlXG4gICAgfTtcbiAgICBuZXh0U3RhdGUgPSB7XG4gICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgdGFyZ2V0U2xpZGU6IGFuaW1hdGlvblNsaWRlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbFNsaWRlID0gYW5pbWF0aW9uU2xpZGU7XG5cbiAgICBpZiAoYW5pbWF0aW9uU2xpZGUgPCAwKSB7XG4gICAgICBmaW5hbFNsaWRlID0gYW5pbWF0aW9uU2xpZGUgKyBzbGlkZUNvdW50O1xuICAgICAgaWYgKCFpbmZpbml0ZSkgZmluYWxTbGlkZSA9IDA7ZWxzZSBpZiAoc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwKSBmaW5hbFNsaWRlID0gc2xpZGVDb3VudCAtIHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbDtcbiAgICB9IGVsc2UgaWYgKCFjYW5Hb05leHQoc3BlYykgJiYgYW5pbWF0aW9uU2xpZGUgPiBjdXJyZW50U2xpZGUpIHtcbiAgICAgIGFuaW1hdGlvblNsaWRlID0gZmluYWxTbGlkZSA9IGN1cnJlbnRTbGlkZTtcbiAgICB9IGVsc2UgaWYgKGNlbnRlck1vZGUgJiYgYW5pbWF0aW9uU2xpZGUgPj0gc2xpZGVDb3VudCkge1xuICAgICAgYW5pbWF0aW9uU2xpZGUgPSBpbmZpbml0ZSA/IHNsaWRlQ291bnQgOiBzbGlkZUNvdW50IC0gMTtcbiAgICAgIGZpbmFsU2xpZGUgPSBpbmZpbml0ZSA/IDAgOiBzbGlkZUNvdW50IC0gMTtcbiAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblNsaWRlID49IHNsaWRlQ291bnQpIHtcbiAgICAgIGZpbmFsU2xpZGUgPSBhbmltYXRpb25TbGlkZSAtIHNsaWRlQ291bnQ7XG4gICAgICBpZiAoIWluZmluaXRlKSBmaW5hbFNsaWRlID0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdztlbHNlIGlmIChzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGwgIT09IDApIGZpbmFsU2xpZGUgPSAwO1xuICAgIH1cblxuICAgIGlmICghaW5maW5pdGUgJiYgYW5pbWF0aW9uU2xpZGUgKyBzbGlkZXNUb1Nob3cgPj0gc2xpZGVDb3VudCkge1xuICAgICAgZmluYWxTbGlkZSA9IHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3c7XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uTGVmdCA9IGdldFRyYWNrTGVmdChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgc2xpZGVJbmRleDogYW5pbWF0aW9uU2xpZGVcbiAgICB9KSk7XG4gICAgZmluYWxMZWZ0ID0gZ2V0VHJhY2tMZWZ0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICBzbGlkZUluZGV4OiBmaW5hbFNsaWRlXG4gICAgfSkpO1xuXG4gICAgaWYgKCFpbmZpbml0ZSkge1xuICAgICAgaWYgKGFuaW1hdGlvbkxlZnQgPT09IGZpbmFsTGVmdCkgYW5pbWF0aW9uU2xpZGUgPSBmaW5hbFNsaWRlO1xuICAgICAgYW5pbWF0aW9uTGVmdCA9IGZpbmFsTGVmdDtcbiAgICB9XG5cbiAgICBpZiAobGF6eUxvYWQpIHtcbiAgICAgIGxhenlMb2FkZWRMaXN0ID0gbGF6eUxvYWRlZExpc3QuY29uY2F0KGdldE9uRGVtYW5kTGF6eVNsaWRlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICBjdXJyZW50U2xpZGU6IGFuaW1hdGlvblNsaWRlXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmICghdXNlQ1NTKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgY3VycmVudFNsaWRlOiBmaW5hbFNsaWRlLFxuICAgICAgICB0cmFja1N0eWxlOiBnZXRUcmFja0NTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGZpbmFsTGVmdFxuICAgICAgICB9KSksXG4gICAgICAgIGxhenlMb2FkZWRMaXN0OiBsYXp5TG9hZGVkTGlzdCxcbiAgICAgICAgdGFyZ2V0U2xpZGU6IHRhcmdldFNsaWRlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgYW5pbWF0aW5nOiB0cnVlLFxuICAgICAgICBjdXJyZW50U2xpZGU6IGZpbmFsU2xpZGUsXG4gICAgICAgIHRyYWNrU3R5bGU6IGdldFRyYWNrQW5pbWF0ZUNTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGFuaW1hdGlvbkxlZnRcbiAgICAgICAgfSkpLFxuICAgICAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3QsXG4gICAgICAgIHRhcmdldFNsaWRlOiB0YXJnZXRTbGlkZVxuICAgICAgfTtcbiAgICAgIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFNsaWRlOiBmaW5hbFNsaWRlLFxuICAgICAgICB0cmFja1N0eWxlOiBnZXRUcmFja0NTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGZpbmFsTGVmdFxuICAgICAgICB9KSksXG4gICAgICAgIHN3aXBlTGVmdDogbnVsbCxcbiAgICAgICAgdGFyZ2V0U2xpZGU6IHRhcmdldFNsaWRlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIG5leHRTdGF0ZTogbmV4dFN0YXRlXG4gIH07XG59O1xuXG5leHBvcnRzLnNsaWRlSGFuZGxlciA9IHNsaWRlSGFuZGxlcjtcblxudmFyIGNoYW5nZVNsaWRlID0gZnVuY3Rpb24gY2hhbmdlU2xpZGUoc3BlYywgb3B0aW9ucykge1xuICB2YXIgaW5kZXhPZmZzZXQsIHByZXZpb3VzSW50LCBzbGlkZU9mZnNldCwgdW5ldmVuT2Zmc2V0LCB0YXJnZXRTbGlkZTtcbiAgdmFyIHNsaWRlc1RvU2Nyb2xsID0gc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgIHNsaWRlc1RvU2hvdyA9IHNwZWMuc2xpZGVzVG9TaG93LFxuICAgICAgc2xpZGVDb3VudCA9IHNwZWMuc2xpZGVDb3VudCxcbiAgICAgIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlLFxuICAgICAgcHJldmlvdXNUYXJnZXRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGUsXG4gICAgICBsYXp5TG9hZCA9IHNwZWMubGF6eUxvYWQsXG4gICAgICBpbmZpbml0ZSA9IHNwZWMuaW5maW5pdGU7XG4gIHVuZXZlbk9mZnNldCA9IHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCAhPT0gMDtcbiAgaW5kZXhPZmZzZXQgPSB1bmV2ZW5PZmZzZXQgPyAwIDogKHNsaWRlQ291bnQgLSBjdXJyZW50U2xpZGUpICUgc2xpZGVzVG9TY3JvbGw7XG5cbiAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJwcmV2aW91c1wiKSB7XG4gICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IHNsaWRlc1RvU2Nyb2xsIDogc2xpZGVzVG9TaG93IC0gaW5kZXhPZmZzZXQ7XG4gICAgdGFyZ2V0U2xpZGUgPSBjdXJyZW50U2xpZGUgLSBzbGlkZU9mZnNldDtcblxuICAgIGlmIChsYXp5TG9hZCAmJiAhaW5maW5pdGUpIHtcbiAgICAgIHByZXZpb3VzSW50ID0gY3VycmVudFNsaWRlIC0gc2xpZGVPZmZzZXQ7XG4gICAgICB0YXJnZXRTbGlkZSA9IHByZXZpb3VzSW50ID09PSAtMSA/IHNsaWRlQ291bnQgLSAxIDogcHJldmlvdXNJbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFpbmZpbml0ZSkge1xuICAgICAgdGFyZ2V0U2xpZGUgPSBwcmV2aW91c1RhcmdldFNsaWRlIC0gc2xpZGVzVG9TY3JvbGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJuZXh0XCIpIHtcbiAgICBzbGlkZU9mZnNldCA9IGluZGV4T2Zmc2V0ID09PSAwID8gc2xpZGVzVG9TY3JvbGwgOiBpbmRleE9mZnNldDtcbiAgICB0YXJnZXRTbGlkZSA9IGN1cnJlbnRTbGlkZSArIHNsaWRlT2Zmc2V0O1xuXG4gICAgaWYgKGxhenlMb2FkICYmICFpbmZpbml0ZSkge1xuICAgICAgdGFyZ2V0U2xpZGUgPSAoY3VycmVudFNsaWRlICsgc2xpZGVzVG9TY3JvbGwpICUgc2xpZGVDb3VudCArIGluZGV4T2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICghaW5maW5pdGUpIHtcbiAgICAgIHRhcmdldFNsaWRlID0gcHJldmlvdXNUYXJnZXRTbGlkZSArIHNsaWRlc1RvU2Nyb2xsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IFwiZG90c1wiKSB7XG4gICAgLy8gQ2xpY2sgb24gZG90c1xuICAgIHRhcmdldFNsaWRlID0gb3B0aW9ucy5pbmRleCAqIG9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcImNoaWxkcmVuXCIpIHtcbiAgICAvLyBDbGljayBvbiB0aGUgc2xpZGVzXG4gICAgdGFyZ2V0U2xpZGUgPSBvcHRpb25zLmluZGV4O1xuXG4gICAgaWYgKGluZmluaXRlKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gc2libGluZ0RpcmVjdGlvbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICB0YXJnZXRTbGlkZTogdGFyZ2V0U2xpZGVcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKHRhcmdldFNsaWRlID4gb3B0aW9ucy5jdXJyZW50U2xpZGUgJiYgZGlyZWN0aW9uID09PSBcImxlZnRcIikge1xuICAgICAgICB0YXJnZXRTbGlkZSA9IHRhcmdldFNsaWRlIC0gc2xpZGVDb3VudDtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2xpZGUgPCBvcHRpb25zLmN1cnJlbnRTbGlkZSAmJiBkaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgICB0YXJnZXRTbGlkZSA9IHRhcmdldFNsaWRlICsgc2xpZGVDb3VudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcImluZGV4XCIpIHtcbiAgICB0YXJnZXRTbGlkZSA9IE51bWJlcihvcHRpb25zLmluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRTbGlkZTtcbn07XG5cbmV4cG9ydHMuY2hhbmdlU2xpZGUgPSBjaGFuZ2VTbGlkZTtcblxudmFyIGtleUhhbmRsZXIgPSBmdW5jdGlvbiBrZXlIYW5kbGVyKGUsIGFjY2Vzc2liaWxpdHksIHJ0bCkge1xuICBpZiAoZS50YXJnZXQudGFnTmFtZS5tYXRjaChcIlRFWFRBUkVBfElOUFVUfFNFTEVDVFwiKSB8fCAhYWNjZXNzaWJpbGl0eSkgcmV0dXJuIFwiXCI7XG4gIGlmIChlLmtleUNvZGUgPT09IDM3KSByZXR1cm4gcnRsID8gXCJuZXh0XCIgOiBcInByZXZpb3VzXCI7XG4gIGlmIChlLmtleUNvZGUgPT09IDM5KSByZXR1cm4gcnRsID8gXCJwcmV2aW91c1wiIDogXCJuZXh0XCI7XG4gIHJldHVybiBcIlwiO1xufTtcblxuZXhwb3J0cy5rZXlIYW5kbGVyID0ga2V5SGFuZGxlcjtcblxudmFyIHN3aXBlU3RhcnQgPSBmdW5jdGlvbiBzd2lwZVN0YXJ0KGUsIHN3aXBlLCBkcmFnZ2FibGUpIHtcbiAgZS50YXJnZXQudGFnTmFtZSA9PT0gXCJJTUdcIiAmJiBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gIGlmICghc3dpcGUgfHwgIWRyYWdnYWJsZSAmJiBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpICE9PSAtMSkgcmV0dXJuIFwiXCI7XG4gIHJldHVybiB7XG4gICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgdG91Y2hPYmplY3Q6IHtcbiAgICAgIHN0YXJ0WDogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS5jbGllbnRYLFxuICAgICAgc3RhcnRZOiBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVkgOiBlLmNsaWVudFksXG4gICAgICBjdXJYOiBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVggOiBlLmNsaWVudFgsXG4gICAgICBjdXJZOiBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVkgOiBlLmNsaWVudFlcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLnN3aXBlU3RhcnQgPSBzd2lwZVN0YXJ0O1xuXG52YXIgc3dpcGVNb3ZlID0gZnVuY3Rpb24gc3dpcGVNb3ZlKGUsIHNwZWMpIHtcbiAgLy8gc3BlYyBhbHNvIGNvbnRhaW5zLCB0cmFja1JlZiBhbmQgc2xpZGVJbmRleFxuICB2YXIgc2Nyb2xsaW5nID0gc3BlYy5zY3JvbGxpbmcsXG4gICAgICBhbmltYXRpbmcgPSBzcGVjLmFuaW1hdGluZyxcbiAgICAgIHZlcnRpY2FsID0gc3BlYy52ZXJ0aWNhbCxcbiAgICAgIHN3aXBlVG9TbGlkZSA9IHNwZWMuc3dpcGVUb1NsaWRlLFxuICAgICAgdmVydGljYWxTd2lwaW5nID0gc3BlYy52ZXJ0aWNhbFN3aXBpbmcsXG4gICAgICBydGwgPSBzcGVjLnJ0bCxcbiAgICAgIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlLFxuICAgICAgZWRnZUZyaWN0aW9uID0gc3BlYy5lZGdlRnJpY3Rpb24sXG4gICAgICBlZGdlRHJhZ2dlZCA9IHNwZWMuZWRnZURyYWdnZWQsXG4gICAgICBvbkVkZ2UgPSBzcGVjLm9uRWRnZSxcbiAgICAgIHN3aXBlZCA9IHNwZWMuc3dpcGVkLFxuICAgICAgc3dpcGluZyA9IHNwZWMuc3dpcGluZyxcbiAgICAgIHNsaWRlQ291bnQgPSBzcGVjLnNsaWRlQ291bnQsXG4gICAgICBzbGlkZXNUb1Njcm9sbCA9IHNwZWMuc2xpZGVzVG9TY3JvbGwsXG4gICAgICBpbmZpbml0ZSA9IHNwZWMuaW5maW5pdGUsXG4gICAgICB0b3VjaE9iamVjdCA9IHNwZWMudG91Y2hPYmplY3QsXG4gICAgICBzd2lwZUV2ZW50ID0gc3BlYy5zd2lwZUV2ZW50LFxuICAgICAgbGlzdEhlaWdodCA9IHNwZWMubGlzdEhlaWdodCxcbiAgICAgIGxpc3RXaWR0aCA9IHNwZWMubGlzdFdpZHRoO1xuICBpZiAoc2Nyb2xsaW5nKSByZXR1cm47XG4gIGlmIChhbmltYXRpbmcpIHJldHVybiBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gIGlmICh2ZXJ0aWNhbCAmJiBzd2lwZVRvU2xpZGUgJiYgdmVydGljYWxTd2lwaW5nKSBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gIHZhciBzd2lwZUxlZnQsXG4gICAgICBzdGF0ZSA9IHt9O1xuICB2YXIgY3VyTGVmdCA9IGdldFRyYWNrTGVmdChzcGVjKTtcbiAgdG91Y2hPYmplY3QuY3VyWCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWCA6IGUuY2xpZW50WDtcbiAgdG91Y2hPYmplY3QuY3VyWSA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWSA6IGUuY2xpZW50WTtcbiAgdG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyh0b3VjaE9iamVjdC5jdXJYIC0gdG91Y2hPYmplY3Quc3RhcnRYLCAyKSkpO1xuICB2YXIgdmVydGljYWxTd2lwZUxlbmd0aCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KE1hdGgucG93KHRvdWNoT2JqZWN0LmN1clkgLSB0b3VjaE9iamVjdC5zdGFydFksIDIpKSk7XG5cbiAgaWYgKCF2ZXJ0aWNhbFN3aXBpbmcgJiYgIXN3aXBpbmcgJiYgdmVydGljYWxTd2lwZUxlbmd0aCA+IDEwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbGluZzogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBpZiAodmVydGljYWxTd2lwaW5nKSB0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA9IHZlcnRpY2FsU3dpcGVMZW5ndGg7XG4gIHZhciBwb3NpdGlvbk9mZnNldCA9ICghcnRsID8gMSA6IC0xKSAqICh0b3VjaE9iamVjdC5jdXJYID4gdG91Y2hPYmplY3Quc3RhcnRYID8gMSA6IC0xKTtcbiAgaWYgKHZlcnRpY2FsU3dpcGluZykgcG9zaXRpb25PZmZzZXQgPSB0b3VjaE9iamVjdC5jdXJZID4gdG91Y2hPYmplY3Quc3RhcnRZID8gMSA6IC0xO1xuICB2YXIgZG90Q291bnQgPSBNYXRoLmNlaWwoc2xpZGVDb3VudCAvIHNsaWRlc1RvU2Nyb2xsKTtcbiAgdmFyIHN3aXBlRGlyZWN0aW9uID0gZ2V0U3dpcGVEaXJlY3Rpb24oc3BlYy50b3VjaE9iamVjdCwgdmVydGljYWxTd2lwaW5nKTtcbiAgdmFyIHRvdWNoU3dpcGVMZW5ndGggPSB0b3VjaE9iamVjdC5zd2lwZUxlbmd0aDtcblxuICBpZiAoIWluZmluaXRlKSB7XG4gICAgaWYgKGN1cnJlbnRTbGlkZSA9PT0gMCAmJiAoc3dpcGVEaXJlY3Rpb24gPT09IFwicmlnaHRcIiB8fCBzd2lwZURpcmVjdGlvbiA9PT0gXCJkb3duXCIpIHx8IGN1cnJlbnRTbGlkZSArIDEgPj0gZG90Q291bnQgJiYgKHN3aXBlRGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCBzd2lwZURpcmVjdGlvbiA9PT0gXCJ1cFwiKSB8fCAhY2FuR29OZXh0KHNwZWMpICYmIChzd2lwZURpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgc3dpcGVEaXJlY3Rpb24gPT09IFwidXBcIikpIHtcbiAgICAgIHRvdWNoU3dpcGVMZW5ndGggPSB0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCAqIGVkZ2VGcmljdGlvbjtcblxuICAgICAgaWYgKGVkZ2VEcmFnZ2VkID09PSBmYWxzZSAmJiBvbkVkZ2UpIHtcbiAgICAgICAgb25FZGdlKHN3aXBlRGlyZWN0aW9uKTtcbiAgICAgICAgc3RhdGVbXCJlZGdlRHJhZ2dlZFwiXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzd2lwZWQgJiYgc3dpcGVFdmVudCkge1xuICAgIHN3aXBlRXZlbnQoc3dpcGVEaXJlY3Rpb24pO1xuICAgIHN0YXRlW1wic3dpcGVkXCJdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICghdmVydGljYWwpIHtcbiAgICBpZiAoIXJ0bCkge1xuICAgICAgc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHRvdWNoU3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVMZWZ0ID0gY3VyTGVmdCAtIHRvdWNoU3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHRvdWNoU3dpcGVMZW5ndGggKiAobGlzdEhlaWdodCAvIGxpc3RXaWR0aCkgKiBwb3NpdGlvbk9mZnNldDtcbiAgfVxuXG4gIGlmICh2ZXJ0aWNhbFN3aXBpbmcpIHtcbiAgICBzd2lwZUxlZnQgPSBjdXJMZWZ0ICsgdG91Y2hTd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICB0b3VjaE9iamVjdDogdG91Y2hPYmplY3QsXG4gICAgc3dpcGVMZWZ0OiBzd2lwZUxlZnQsXG4gICAgdHJhY2tTdHlsZTogZ2V0VHJhY2tDU1MoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGxlZnQ6IHN3aXBlTGVmdFxuICAgIH0pKVxuICB9KTtcblxuICBpZiAoTWF0aC5hYnModG91Y2hPYmplY3QuY3VyWCAtIHRvdWNoT2JqZWN0LnN0YXJ0WCkgPCBNYXRoLmFicyh0b3VjaE9iamVjdC5jdXJZIC0gdG91Y2hPYmplY3Quc3RhcnRZKSAqIDAuOCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICh0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDEwKSB7XG4gICAgc3RhdGVbXCJzd2lwaW5nXCJdID0gdHJ1ZTtcbiAgICBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG5leHBvcnRzLnN3aXBlTW92ZSA9IHN3aXBlTW92ZTtcblxudmFyIHN3aXBlRW5kID0gZnVuY3Rpb24gc3dpcGVFbmQoZSwgc3BlYykge1xuICB2YXIgZHJhZ2dpbmcgPSBzcGVjLmRyYWdnaW5nLFxuICAgICAgc3dpcGUgPSBzcGVjLnN3aXBlLFxuICAgICAgdG91Y2hPYmplY3QgPSBzcGVjLnRvdWNoT2JqZWN0LFxuICAgICAgbGlzdFdpZHRoID0gc3BlYy5saXN0V2lkdGgsXG4gICAgICB0b3VjaFRocmVzaG9sZCA9IHNwZWMudG91Y2hUaHJlc2hvbGQsXG4gICAgICB2ZXJ0aWNhbFN3aXBpbmcgPSBzcGVjLnZlcnRpY2FsU3dpcGluZyxcbiAgICAgIGxpc3RIZWlnaHQgPSBzcGVjLmxpc3RIZWlnaHQsXG4gICAgICBzd2lwZVRvU2xpZGUgPSBzcGVjLnN3aXBlVG9TbGlkZSxcbiAgICAgIHNjcm9sbGluZyA9IHNwZWMuc2Nyb2xsaW5nLFxuICAgICAgb25Td2lwZSA9IHNwZWMub25Td2lwZSxcbiAgICAgIHRhcmdldFNsaWRlID0gc3BlYy50YXJnZXRTbGlkZSxcbiAgICAgIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlLFxuICAgICAgaW5maW5pdGUgPSBzcGVjLmluZmluaXRlO1xuXG4gIGlmICghZHJhZ2dpbmcpIHtcbiAgICBpZiAoc3dpcGUpIHNhZmVQcmV2ZW50RGVmYXVsdChlKTtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgbWluU3dpcGUgPSB2ZXJ0aWNhbFN3aXBpbmcgPyBsaXN0SGVpZ2h0IC8gdG91Y2hUaHJlc2hvbGQgOiBsaXN0V2lkdGggLyB0b3VjaFRocmVzaG9sZDtcbiAgdmFyIHN3aXBlRGlyZWN0aW9uID0gZ2V0U3dpcGVEaXJlY3Rpb24odG91Y2hPYmplY3QsIHZlcnRpY2FsU3dpcGluZyk7IC8vIHJlc2V0IHRoZSBzdGF0ZSBvZiB0b3VjaCByZWxhdGVkIHN0YXRlIHZhcmlhYmxlcy5cblxuICB2YXIgc3RhdGUgPSB7XG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIGVkZ2VEcmFnZ2VkOiBmYWxzZSxcbiAgICBzY3JvbGxpbmc6IGZhbHNlLFxuICAgIHN3aXBpbmc6IGZhbHNlLFxuICAgIHN3aXBlZDogZmFsc2UsXG4gICAgc3dpcGVMZWZ0OiBudWxsLFxuICAgIHRvdWNoT2JqZWN0OiB7fVxuICB9O1xuXG4gIGlmIChzY3JvbGxpbmcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBpZiAoIXRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKHRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gbWluU3dpcGUpIHtcbiAgICBzYWZlUHJldmVudERlZmF1bHQoZSk7XG5cbiAgICBpZiAob25Td2lwZSkge1xuICAgICAgb25Td2lwZShzd2lwZURpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlQ291bnQsIG5ld1NsaWRlO1xuICAgIHZhciBhY3RpdmVTbGlkZSA9IGluZmluaXRlID8gY3VycmVudFNsaWRlIDogdGFyZ2V0U2xpZGU7XG5cbiAgICBzd2l0Y2ggKHN3aXBlRGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgIG5ld1NsaWRlID0gYWN0aXZlU2xpZGUgKyBnZXRTbGlkZUNvdW50KHNwZWMpO1xuICAgICAgICBzbGlkZUNvdW50ID0gc3dpcGVUb1NsaWRlID8gY2hlY2tOYXZpZ2FibGUoc3BlYywgbmV3U2xpZGUpIDogbmV3U2xpZGU7XG4gICAgICAgIHN0YXRlW1wiY3VycmVudERpcmVjdGlvblwiXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgIG5ld1NsaWRlID0gYWN0aXZlU2xpZGUgLSBnZXRTbGlkZUNvdW50KHNwZWMpO1xuICAgICAgICBzbGlkZUNvdW50ID0gc3dpcGVUb1NsaWRlID8gY2hlY2tOYXZpZ2FibGUoc3BlYywgbmV3U2xpZGUpIDogbmV3U2xpZGU7XG4gICAgICAgIHN0YXRlW1wiY3VycmVudERpcmVjdGlvblwiXSA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzbGlkZUNvdW50ID0gYWN0aXZlU2xpZGU7XG4gICAgfVxuXG4gICAgc3RhdGVbXCJ0cmlnZ2VyU2xpZGVIYW5kbGVyXCJdID0gc2xpZGVDb3VudDtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGp1c3QgdGhlIHRyYWNrIGJhY2sgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgY3VycmVudExlZnQgPSBnZXRUcmFja0xlZnQoc3BlYyk7XG4gICAgc3RhdGVbXCJ0cmFja1N0eWxlXCJdID0gZ2V0VHJhY2tBbmltYXRlQ1NTKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICBsZWZ0OiBjdXJyZW50TGVmdFxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbmV4cG9ydHMuc3dpcGVFbmQgPSBzd2lwZUVuZDtcblxudmFyIGdldE5hdmlnYWJsZUluZGV4ZXMgPSBmdW5jdGlvbiBnZXROYXZpZ2FibGVJbmRleGVzKHNwZWMpIHtcbiAgdmFyIG1heCA9IHNwZWMuaW5maW5pdGUgPyBzcGVjLnNsaWRlQ291bnQgKiAyIDogc3BlYy5zbGlkZUNvdW50O1xuICB2YXIgYnJlYWtwb2ludCA9IHNwZWMuaW5maW5pdGUgPyBzcGVjLnNsaWRlc1RvU2hvdyAqIC0xIDogMDtcbiAgdmFyIGNvdW50ZXIgPSBzcGVjLmluZmluaXRlID8gc3BlYy5zbGlkZXNUb1Nob3cgKiAtMSA6IDA7XG4gIHZhciBpbmRleGVzID0gW107XG5cbiAgd2hpbGUgKGJyZWFrcG9pbnQgPCBtYXgpIHtcbiAgICBpbmRleGVzLnB1c2goYnJlYWtwb2ludCk7XG4gICAgYnJlYWtwb2ludCA9IGNvdW50ZXIgKyBzcGVjLnNsaWRlc1RvU2Nyb2xsO1xuICAgIGNvdW50ZXIgKz0gTWF0aC5taW4oc3BlYy5zbGlkZXNUb1Njcm9sbCwgc3BlYy5zbGlkZXNUb1Nob3cpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXM7XG59O1xuXG5leHBvcnRzLmdldE5hdmlnYWJsZUluZGV4ZXMgPSBnZXROYXZpZ2FibGVJbmRleGVzO1xuXG52YXIgY2hlY2tOYXZpZ2FibGUgPSBmdW5jdGlvbiBjaGVja05hdmlnYWJsZShzcGVjLCBpbmRleCkge1xuICB2YXIgbmF2aWdhYmxlcyA9IGdldE5hdmlnYWJsZUluZGV4ZXMoc3BlYyk7XG4gIHZhciBwcmV2TmF2aWdhYmxlID0gMDtcblxuICBpZiAoaW5kZXggPiBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBpbmRleCA9IG5hdmlnYWJsZXNbbmF2aWdhYmxlcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBuIGluIG5hdmlnYWJsZXMpIHtcbiAgICAgIGlmIChpbmRleCA8IG5hdmlnYWJsZXNbbl0pIHtcbiAgICAgICAgaW5kZXggPSBwcmV2TmF2aWdhYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldk5hdmlnYWJsZSA9IG5hdmlnYWJsZXNbbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZXhwb3J0cy5jaGVja05hdmlnYWJsZSA9IGNoZWNrTmF2aWdhYmxlO1xuXG52YXIgZ2V0U2xpZGVDb3VudCA9IGZ1bmN0aW9uIGdldFNsaWRlQ291bnQoc3BlYykge1xuICB2YXIgY2VudGVyT2Zmc2V0ID0gc3BlYy5jZW50ZXJNb2RlID8gc3BlYy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihzcGVjLnNsaWRlc1RvU2hvdyAvIDIpIDogMDtcblxuICBpZiAoc3BlYy5zd2lwZVRvU2xpZGUpIHtcbiAgICB2YXIgc3dpcGVkU2xpZGU7XG4gICAgdmFyIHNsaWNrTGlzdCA9IHNwZWMubGlzdFJlZjtcbiAgICB2YXIgc2xpZGVzID0gc2xpY2tMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgc2xpY2tMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2xpY2stc2xpZGVcIikgfHwgW107XG4gICAgQXJyYXkuZnJvbShzbGlkZXMpLmV2ZXJ5KGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgICAgIGlmIChzbGlkZS5vZmZzZXRMZWZ0IC0gY2VudGVyT2Zmc2V0ICsgZ2V0V2lkdGgoc2xpZGUpIC8gMiA+IHNwZWMuc3dpcGVMZWZ0ICogLTEpIHtcbiAgICAgICAgICBzd2lwZWRTbGlkZSA9IHNsaWRlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNsaWRlLm9mZnNldFRvcCArIGdldEhlaWdodChzbGlkZSkgLyAyID4gc3BlYy5zd2lwZUxlZnQgKiAtMSkge1xuICAgICAgICAgIHN3aXBlZFNsaWRlID0gc2xpZGU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzd2lwZWRTbGlkZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IHNwZWMucnRsID09PSB0cnVlID8gc3BlYy5zbGlkZUNvdW50IC0gc3BlYy5jdXJyZW50U2xpZGUgOiBzcGVjLmN1cnJlbnRTbGlkZTtcbiAgICB2YXIgc2xpZGVzVHJhdmVyc2VkID0gTWF0aC5hYnMoc3dpcGVkU2xpZGUuZGF0YXNldC5pbmRleCAtIGN1cnJlbnRJbmRleCkgfHwgMTtcbiAgICByZXR1cm4gc2xpZGVzVHJhdmVyc2VkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzcGVjLnNsaWRlc1RvU2Nyb2xsO1xuICB9XG59O1xuXG5leHBvcnRzLmdldFNsaWRlQ291bnQgPSBnZXRTbGlkZUNvdW50O1xuXG52YXIgY2hlY2tTcGVjS2V5cyA9IGZ1bmN0aW9uIGNoZWNrU3BlY0tleXMoc3BlYywga2V5c0FycmF5KSB7XG4gIHJldHVybiBrZXlzQXJyYXkucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHNwZWMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSwgdHJ1ZSkgPyBudWxsIDogY29uc29sZS5lcnJvcihcIktleXMgTWlzc2luZzpcIiwgc3BlYyk7XG59O1xuXG5leHBvcnRzLmNoZWNrU3BlY0tleXMgPSBjaGVja1NwZWNLZXlzO1xuXG52YXIgZ2V0VHJhY2tDU1MgPSBmdW5jdGlvbiBnZXRUcmFja0NTUyhzcGVjKSB7XG4gIGNoZWNrU3BlY0tleXMoc3BlYywgW1wibGVmdFwiLCBcInZhcmlhYmxlV2lkdGhcIiwgXCJzbGlkZUNvdW50XCIsIFwic2xpZGVzVG9TaG93XCIsIFwic2xpZGVXaWR0aFwiXSk7XG4gIHZhciB0cmFja1dpZHRoLCB0cmFja0hlaWdodDtcbiAgdmFyIHRyYWNrQ2hpbGRyZW4gPSBzcGVjLnNsaWRlQ291bnQgKyAyICogc3BlYy5zbGlkZXNUb1Nob3c7XG5cbiAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgdHJhY2tXaWR0aCA9IGdldFRvdGFsU2xpZGVzKHNwZWMpICogc3BlYy5zbGlkZVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHRyYWNrSGVpZ2h0ID0gdHJhY2tDaGlsZHJlbiAqIHNwZWMuc2xpZGVIZWlnaHQ7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2l0aW9uOiBcIlwiLFxuICAgIFdlYmtpdFRyYW5zaXRpb246IFwiXCJcbiAgfTtcblxuICBpZiAoc3BlYy51c2VUcmFuc2Zvcm0pIHtcbiAgICB2YXIgV2Via2l0VHJhbnNmb3JtID0gIXNwZWMudmVydGljYWwgPyBcInRyYW5zbGF0ZTNkKFwiICsgc3BlYy5sZWZ0ICsgXCJweCwgMHB4LCAwcHgpXCIgOiBcInRyYW5zbGF0ZTNkKDBweCwgXCIgKyBzcGVjLmxlZnQgKyBcInB4LCAwcHgpXCI7XG4gICAgdmFyIHRyYW5zZm9ybSA9ICFzcGVjLnZlcnRpY2FsID8gXCJ0cmFuc2xhdGUzZChcIiArIHNwZWMubGVmdCArIFwicHgsIDBweCwgMHB4KVwiIDogXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgc3BlYy5sZWZ0ICsgXCJweCwgMHB4KVwiO1xuICAgIHZhciBtc1RyYW5zZm9ybSA9ICFzcGVjLnZlcnRpY2FsID8gXCJ0cmFuc2xhdGVYKFwiICsgc3BlYy5sZWZ0ICsgXCJweClcIiA6IFwidHJhbnNsYXRlWShcIiArIHNwZWMubGVmdCArIFwicHgpXCI7XG4gICAgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogV2Via2l0VHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBtc1RyYW5zZm9ybTogbXNUcmFuc2Zvcm1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3BlYy52ZXJ0aWNhbCkge1xuICAgICAgc3R5bGVbXCJ0b3BcIl0gPSBzcGVjLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW1wibGVmdFwiXSA9IHNwZWMubGVmdDtcbiAgICB9XG4gIH1cblxuICBpZiAoc3BlYy5mYWRlKSBzdHlsZSA9IHtcbiAgICBvcGFjaXR5OiAxXG4gIH07XG4gIGlmICh0cmFja1dpZHRoKSBzdHlsZS53aWR0aCA9IHRyYWNrV2lkdGg7XG4gIGlmICh0cmFja0hlaWdodCkgc3R5bGUuaGVpZ2h0ID0gdHJhY2tIZWlnaHQ7IC8vIEZhbGxiYWNrIGZvciBJRThcblxuICBpZiAod2luZG93ICYmICF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAmJiB3aW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICBpZiAoIXNwZWMudmVydGljYWwpIHtcbiAgICAgIHN0eWxlLm1hcmdpbkxlZnQgPSBzcGVjLmxlZnQgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLm1hcmdpblRvcCA9IHNwZWMubGVmdCArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5leHBvcnRzLmdldFRyYWNrQ1NTID0gZ2V0VHJhY2tDU1M7XG5cbnZhciBnZXRUcmFja0FuaW1hdGVDU1MgPSBmdW5jdGlvbiBnZXRUcmFja0FuaW1hdGVDU1Moc3BlYykge1xuICBjaGVja1NwZWNLZXlzKHNwZWMsIFtcImxlZnRcIiwgXCJ2YXJpYWJsZVdpZHRoXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcInNsaWRlV2lkdGhcIiwgXCJzcGVlZFwiLCBcImNzc0Vhc2VcIl0pO1xuICB2YXIgc3R5bGUgPSBnZXRUcmFja0NTUyhzcGVjKTsgLy8gdXNlQ1NTIGlzIHRydWUgYnkgZGVmYXVsdCBzbyBpdCBjYW4gYmUgdW5kZWZpbmVkXG5cbiAgaWYgKHNwZWMudXNlVHJhbnNmb3JtKSB7XG4gICAgc3R5bGUuV2Via2l0VHJhbnNpdGlvbiA9IFwiLXdlYmtpdC10cmFuc2Zvcm0gXCIgKyBzcGVjLnNwZWVkICsgXCJtcyBcIiArIHNwZWMuY3NzRWFzZTtcbiAgICBzdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gXCIgKyBzcGVjLnNwZWVkICsgXCJtcyBcIiArIHNwZWMuY3NzRWFzZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3BlYy52ZXJ0aWNhbCkge1xuICAgICAgc3R5bGUudHJhbnNpdGlvbiA9IFwidG9wIFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcImxlZnQgXCIgKyBzcGVjLnNwZWVkICsgXCJtcyBcIiArIHNwZWMuY3NzRWFzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5leHBvcnRzLmdldFRyYWNrQW5pbWF0ZUNTUyA9IGdldFRyYWNrQW5pbWF0ZUNTUztcblxudmFyIGdldFRyYWNrTGVmdCA9IGZ1bmN0aW9uIGdldFRyYWNrTGVmdChzcGVjKSB7XG4gIGlmIChzcGVjLnVuc2xpY2spIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNoZWNrU3BlY0tleXMoc3BlYywgW1wic2xpZGVJbmRleFwiLCBcInRyYWNrUmVmXCIsIFwiaW5maW5pdGVcIiwgXCJjZW50ZXJNb2RlXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcInNsaWRlc1RvU2Nyb2xsXCIsIFwic2xpZGVXaWR0aFwiLCBcImxpc3RXaWR0aFwiLCBcInZhcmlhYmxlV2lkdGhcIiwgXCJzbGlkZUhlaWdodFwiXSk7XG4gIHZhciBzbGlkZUluZGV4ID0gc3BlYy5zbGlkZUluZGV4LFxuICAgICAgdHJhY2tSZWYgPSBzcGVjLnRyYWNrUmVmLFxuICAgICAgaW5maW5pdGUgPSBzcGVjLmluZmluaXRlLFxuICAgICAgY2VudGVyTW9kZSA9IHNwZWMuY2VudGVyTW9kZSxcbiAgICAgIHNsaWRlQ291bnQgPSBzcGVjLnNsaWRlQ291bnQsXG4gICAgICBzbGlkZXNUb1Nob3cgPSBzcGVjLnNsaWRlc1RvU2hvdyxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsID0gc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgIHNsaWRlV2lkdGggPSBzcGVjLnNsaWRlV2lkdGgsXG4gICAgICBsaXN0V2lkdGggPSBzcGVjLmxpc3RXaWR0aCxcbiAgICAgIHZhcmlhYmxlV2lkdGggPSBzcGVjLnZhcmlhYmxlV2lkdGgsXG4gICAgICBzbGlkZUhlaWdodCA9IHNwZWMuc2xpZGVIZWlnaHQsXG4gICAgICBmYWRlID0gc3BlYy5mYWRlLFxuICAgICAgdmVydGljYWwgPSBzcGVjLnZlcnRpY2FsO1xuICB2YXIgc2xpZGVPZmZzZXQgPSAwO1xuICB2YXIgdGFyZ2V0TGVmdDtcbiAgdmFyIHRhcmdldFNsaWRlO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSAwO1xuXG4gIGlmIChmYWRlIHx8IHNwZWMuc2xpZGVDb3VudCA9PT0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHNsaWRlc1RvT2Zmc2V0ID0gMDtcblxuICBpZiAoaW5maW5pdGUpIHtcbiAgICBzbGlkZXNUb09mZnNldCA9IC1nZXRQcmVDbG9uZXMoc3BlYyk7IC8vIGJyaW5nIGFjdGl2ZSBzbGlkZSB0byB0aGUgYmVnaW5uaW5nIG9mIHZpc3VhbCBhcmVhXG4gICAgLy8gaWYgbmV4dCBzY3JvbGwgZG9lc24ndCBoYXZlIGVub3VnaCBjaGlsZHJlbiwganVzdCByZWFjaCB0aWxsIHRoZSBlbmQgb2Ygb3JpZ2luYWwgc2xpZGVzIGluc3RlYWQgb2Ygc2hpZnRpbmcgc2xpZGVzVG9TY3JvbGwgY2hpbGRyZW5cblxuICAgIGlmIChzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGwgIT09IDAgJiYgc2xpZGVJbmRleCArIHNsaWRlc1RvU2Nyb2xsID4gc2xpZGVDb3VudCkge1xuICAgICAgc2xpZGVzVG9PZmZzZXQgPSAtKHNsaWRlSW5kZXggPiBzbGlkZUNvdW50ID8gc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBzbGlkZUNvdW50KSA6IHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCk7XG4gICAgfSAvLyBzaGlmdCBjdXJyZW50IHNsaWRlIHRvIGNlbnRlciBvZiB0aGUgZnJhbWVcblxuXG4gICAgaWYgKGNlbnRlck1vZGUpIHtcbiAgICAgIHNsaWRlc1RvT2Zmc2V0ICs9IHBhcnNlSW50KHNsaWRlc1RvU2hvdyAvIDIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwICYmIHNsaWRlSW5kZXggKyBzbGlkZXNUb1Njcm9sbCA+IHNsaWRlQ291bnQpIHtcbiAgICAgIHNsaWRlc1RvT2Zmc2V0ID0gc2xpZGVzVG9TaG93IC0gc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsO1xuICAgIH1cblxuICAgIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgICBzbGlkZXNUb09mZnNldCA9IHBhcnNlSW50KHNsaWRlc1RvU2hvdyAvIDIpO1xuICAgIH1cbiAgfVxuXG4gIHNsaWRlT2Zmc2V0ID0gc2xpZGVzVG9PZmZzZXQgKiBzbGlkZVdpZHRoO1xuICB2ZXJ0aWNhbE9mZnNldCA9IHNsaWRlc1RvT2Zmc2V0ICogc2xpZGVIZWlnaHQ7XG5cbiAgaWYgKCF2ZXJ0aWNhbCkge1xuICAgIHRhcmdldExlZnQgPSBzbGlkZUluZGV4ICogc2xpZGVXaWR0aCAqIC0xICsgc2xpZGVPZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0TGVmdCA9IHNsaWRlSW5kZXggKiBzbGlkZUhlaWdodCAqIC0xICsgdmVydGljYWxPZmZzZXQ7XG4gIH1cblxuICBpZiAodmFyaWFibGVXaWR0aCA9PT0gdHJ1ZSkge1xuICAgIHZhciB0YXJnZXRTbGlkZUluZGV4O1xuICAgIHZhciB0cmFja0VsZW0gPSB0cmFja1JlZiAmJiB0cmFja1JlZi5ub2RlO1xuICAgIHRhcmdldFNsaWRlSW5kZXggPSBzbGlkZUluZGV4ICsgZ2V0UHJlQ2xvbmVzKHNwZWMpO1xuICAgIHRhcmdldFNsaWRlID0gdHJhY2tFbGVtICYmIHRyYWNrRWxlbS5jaGlsZE5vZGVzW3RhcmdldFNsaWRlSW5kZXhdO1xuICAgIHRhcmdldExlZnQgPSB0YXJnZXRTbGlkZSA/IHRhcmdldFNsaWRlLm9mZnNldExlZnQgKiAtMSA6IDA7XG5cbiAgICBpZiAoY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IGluZmluaXRlID8gc2xpZGVJbmRleCArIGdldFByZUNsb25lcyhzcGVjKSA6IHNsaWRlSW5kZXg7XG4gICAgICB0YXJnZXRTbGlkZSA9IHRyYWNrRWxlbSAmJiB0cmFja0VsZW0uY2hpbGRyZW5bdGFyZ2V0U2xpZGVJbmRleF07XG4gICAgICB0YXJnZXRMZWZ0ID0gMDtcblxuICAgICAgZm9yICh2YXIgc2xpZGUgPSAwOyBzbGlkZSA8IHRhcmdldFNsaWRlSW5kZXg7IHNsaWRlKyspIHtcbiAgICAgICAgdGFyZ2V0TGVmdCAtPSB0cmFja0VsZW0gJiYgdHJhY2tFbGVtLmNoaWxkcmVuW3NsaWRlXSAmJiB0cmFja0VsZW0uY2hpbGRyZW5bc2xpZGVdLm9mZnNldFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRMZWZ0IC09IHBhcnNlSW50KHNwZWMuY2VudGVyUGFkZGluZyk7XG4gICAgICB0YXJnZXRMZWZ0ICs9IHRhcmdldFNsaWRlICYmIChsaXN0V2lkdGggLSB0YXJnZXRTbGlkZS5vZmZzZXRXaWR0aCkgLyAyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRMZWZ0O1xufTtcblxuZXhwb3J0cy5nZXRUcmFja0xlZnQgPSBnZXRUcmFja0xlZnQ7XG5cbnZhciBnZXRQcmVDbG9uZXMgPSBmdW5jdGlvbiBnZXRQcmVDbG9uZXMoc3BlYykge1xuICBpZiAoc3BlYy51bnNsaWNrIHx8ICFzcGVjLmluZmluaXRlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoc3BlYy52YXJpYWJsZVdpZHRoKSB7XG4gICAgcmV0dXJuIHNwZWMuc2xpZGVDb3VudDtcbiAgfVxuXG4gIHJldHVybiBzcGVjLnNsaWRlc1RvU2hvdyArIChzcGVjLmNlbnRlck1vZGUgPyAxIDogMCk7XG59O1xuXG5leHBvcnRzLmdldFByZUNsb25lcyA9IGdldFByZUNsb25lcztcblxudmFyIGdldFBvc3RDbG9uZXMgPSBmdW5jdGlvbiBnZXRQb3N0Q2xvbmVzKHNwZWMpIHtcbiAgaWYgKHNwZWMudW5zbGljayB8fCAhc3BlYy5pbmZpbml0ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHNwZWMuc2xpZGVDb3VudDtcbn07XG5cbmV4cG9ydHMuZ2V0UG9zdENsb25lcyA9IGdldFBvc3RDbG9uZXM7XG5cbnZhciBnZXRUb3RhbFNsaWRlcyA9IGZ1bmN0aW9uIGdldFRvdGFsU2xpZGVzKHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuc2xpZGVDb3VudCA9PT0gMSA/IDEgOiBnZXRQcmVDbG9uZXMoc3BlYykgKyBzcGVjLnNsaWRlQ291bnQgKyBnZXRQb3N0Q2xvbmVzKHNwZWMpO1xufTtcblxuZXhwb3J0cy5nZXRUb3RhbFNsaWRlcyA9IGdldFRvdGFsU2xpZGVzO1xuXG52YXIgc2libGluZ0RpcmVjdGlvbiA9IGZ1bmN0aW9uIHNpYmxpbmdEaXJlY3Rpb24oc3BlYykge1xuICBpZiAoc3BlYy50YXJnZXRTbGlkZSA+IHNwZWMuY3VycmVudFNsaWRlKSB7XG4gICAgaWYgKHNwZWMudGFyZ2V0U2xpZGUgPiBzcGVjLmN1cnJlbnRTbGlkZSArIHNsaWRlc09uUmlnaHQoc3BlYykpIHtcbiAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJyaWdodFwiO1xuICB9IGVsc2Uge1xuICAgIGlmIChzcGVjLnRhcmdldFNsaWRlIDwgc3BlYy5jdXJyZW50U2xpZGUgLSBzbGlkZXNPbkxlZnQoc3BlYykpIHtcbiAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwibGVmdFwiO1xuICB9XG59O1xuXG5leHBvcnRzLnNpYmxpbmdEaXJlY3Rpb24gPSBzaWJsaW5nRGlyZWN0aW9uO1xuXG52YXIgc2xpZGVzT25SaWdodCA9IGZ1bmN0aW9uIHNsaWRlc09uUmlnaHQoX3JlZikge1xuICB2YXIgc2xpZGVzVG9TaG93ID0gX3JlZi5zbGlkZXNUb1Nob3csXG4gICAgICBjZW50ZXJNb2RlID0gX3JlZi5jZW50ZXJNb2RlLFxuICAgICAgcnRsID0gX3JlZi5ydGwsXG4gICAgICBjZW50ZXJQYWRkaW5nID0gX3JlZi5jZW50ZXJQYWRkaW5nO1xuXG4gIC8vIHJldHVybnMgbm8gb2Ygc2xpZGVzIG9uIHRoZSByaWdodCBvZiBhY3RpdmUgc2xpZGVcbiAgaWYgKGNlbnRlck1vZGUpIHtcbiAgICB2YXIgcmlnaHQgPSAoc2xpZGVzVG9TaG93IC0gMSkgLyAyICsgMTtcbiAgICBpZiAocGFyc2VJbnQoY2VudGVyUGFkZGluZykgPiAwKSByaWdodCArPSAxO1xuICAgIGlmIChydGwgJiYgc2xpZGVzVG9TaG93ICUgMiA9PT0gMCkgcmlnaHQgKz0gMTtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH1cblxuICBpZiAocnRsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc2xpZGVzVG9TaG93IC0gMTtcbn07XG5cbmV4cG9ydHMuc2xpZGVzT25SaWdodCA9IHNsaWRlc09uUmlnaHQ7XG5cbnZhciBzbGlkZXNPbkxlZnQgPSBmdW5jdGlvbiBzbGlkZXNPbkxlZnQoX3JlZjIpIHtcbiAgdmFyIHNsaWRlc1RvU2hvdyA9IF9yZWYyLnNsaWRlc1RvU2hvdyxcbiAgICAgIGNlbnRlck1vZGUgPSBfcmVmMi5jZW50ZXJNb2RlLFxuICAgICAgcnRsID0gX3JlZjIucnRsLFxuICAgICAgY2VudGVyUGFkZGluZyA9IF9yZWYyLmNlbnRlclBhZGRpbmc7XG5cbiAgLy8gcmV0dXJucyBubyBvZiBzbGlkZXMgb24gdGhlIGxlZnQgb2YgYWN0aXZlIHNsaWRlXG4gIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgdmFyIGxlZnQgPSAoc2xpZGVzVG9TaG93IC0gMSkgLyAyICsgMTtcbiAgICBpZiAocGFyc2VJbnQoY2VudGVyUGFkZGluZykgPiAwKSBsZWZ0ICs9IDE7XG4gICAgaWYgKCFydGwgJiYgc2xpZGVzVG9TaG93ICUgMiA9PT0gMCkgbGVmdCArPSAxO1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgaWYgKHJ0bCkge1xuICAgIHJldHVybiBzbGlkZXNUb1Nob3cgLSAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnRzLnNsaWRlc09uTGVmdCA9IHNsaWRlc09uTGVmdDtcblxudmFyIGNhblVzZURPTSA9IGZ1bmN0aW9uIGNhblVzZURPTSgpIHtcbiAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbn07XG5cbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xudmFyIHZhbGlkU2V0dGluZ3MgPSBPYmplY3Qua2V5cyhfZGVmYXVsdFByb3BzW1wiZGVmYXVsdFwiXSk7XG5leHBvcnRzLnZhbGlkU2V0dGluZ3MgPSB2YWxpZFNldHRpbmdzO1xuXG5mdW5jdGlvbiBmaWx0ZXJTZXR0aW5ncyhzZXR0aW5ncykge1xuICByZXR1cm4gdmFsaWRTZXR0aW5ncy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc2V0dGluZ05hbWUpIHtcbiAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoc2V0dGluZ05hbWUpKSB7XG4gICAgICBhY2Nbc2V0dGluZ05hbWVdID0gc2V0dGluZ3Nbc2V0dGluZ05hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGVja1NwZWNLZXlzIiwiY2hlY2tOYXZpZ2FibGUiLCJjaGFuZ2VTbGlkZSIsImNhblVzZURPTSIsImNhbkdvTmV4dCIsImNsYW1wIiwiZXh0cmFjdE9iamVjdCIsImZpbHRlclNldHRpbmdzIiwidmFsaWRTZXR0aW5ncyIsInN3aXBlU3RhcnQiLCJzd2lwZU1vdmUiLCJzd2lwZUVuZCIsInNsaWRlc09uUmlnaHQiLCJzbGlkZXNPbkxlZnQiLCJzbGlkZUhhbmRsZXIiLCJzaWJsaW5nRGlyZWN0aW9uIiwic2FmZVByZXZlbnREZWZhdWx0IiwibGF6eVN0YXJ0SW5kZXgiLCJsYXp5U2xpZGVzT25SaWdodCIsImxhenlTbGlkZXNPbkxlZnQiLCJsYXp5RW5kSW5kZXgiLCJrZXlIYW5kbGVyIiwiaW5pdGlhbGl6ZWRTdGF0ZSIsImdldFdpZHRoIiwiZ2V0VHJhY2tMZWZ0IiwiZ2V0VHJhY2tDU1MiLCJnZXRUcmFja0FuaW1hdGVDU1MiLCJnZXRUb3RhbFNsaWRlcyIsImdldFN3aXBlRGlyZWN0aW9uIiwiZ2V0U2xpZGVDb3VudCIsImdldFJlcXVpcmVkTGF6eVNsaWRlcyIsImdldFByZUNsb25lcyIsImdldFBvc3RDbG9uZXMiLCJnZXRPbkRlbWFuZExhenlTbGlkZXMiLCJnZXROYXZpZ2FibGVJbmRleGVzIiwiZ2V0SGVpZ2h0IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfZGVmYXVsdFByb3BzIiwib2JqIiwiX19lc01vZHVsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJudW1iZXIiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJldmVudCIsInBhc3NpdmVFdmVudHMiLCJpbmNsdWRlcyIsIl9yZWFjdE5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsInNwZWMiLCJvbkRlbWFuZFNsaWRlcyIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInNsaWRlSW5kZXgiLCJsYXp5TG9hZGVkTGlzdCIsImluZGV4T2YiLCJyZXF1aXJlZFNsaWRlcyIsImN1cnJlbnRTbGlkZSIsImNlbnRlck1vZGUiLCJmbG9vciIsInNsaWRlc1RvU2hvdyIsInBhcnNlSW50IiwiY2VudGVyUGFkZGluZyIsImVsZW0iLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInRvdWNoT2JqZWN0IiwidmVydGljYWxTd2lwaW5nIiwidW5kZWZpbmVkIiwieERpc3QiLCJ5RGlzdCIsInIiLCJzd2lwZUFuZ2xlIiwic3RhcnRYIiwiY3VyWCIsInN0YXJ0WSIsImN1clkiLCJhdGFuMiIsInJvdW5kIiwiUEkiLCJhYnMiLCJjYW5HbyIsImluZmluaXRlIiwic2xpZGVDb3VudCIsIm5ld09iamVjdCIsIkNoaWxkcmVuIiwiY291bnQiLCJjaGlsZHJlbiIsImxpc3ROb2RlIiwibGlzdFJlZiIsImxpc3RXaWR0aCIsImNlaWwiLCJ0cmFja05vZGUiLCJ0cmFja1JlZiIsIm5vZGUiLCJ0cmFja1dpZHRoIiwic2xpZGVXaWR0aCIsInZlcnRpY2FsIiwiY2VudGVyUGFkZGluZ0FkaiIsInNsaWNlIiwic2xpZGVIZWlnaHQiLCJxdWVyeVNlbGVjdG9yIiwibGlzdEhlaWdodCIsImluaXRpYWxTbGlkZSIsInJ0bCIsInNsaWRlc1RvTG9hZCIsImNvbmNhdCIsInN0YXRlIiwiYXV0b3BsYXlpbmciLCJhdXRvcGxheSIsIndhaXRGb3JBbmltYXRlIiwiYW5pbWF0aW5nIiwiZmFkZSIsImluZGV4IiwibGF6eUxvYWQiLCJzbGlkZXNUb1Njcm9sbCIsInVzZUNTUyIsImFuaW1hdGlvblNsaWRlIiwiZmluYWxTbGlkZSIsImFuaW1hdGlvbkxlZnQiLCJmaW5hbExlZnQiLCJuZXh0U3RhdGUiLCJ0YXJnZXRTbGlkZSIsInRyYWNrU3R5bGUiLCJsZWZ0Iiwic3dpcGVMZWZ0Iiwib3B0aW9ucyIsImluZGV4T2Zmc2V0IiwicHJldmlvdXNJbnQiLCJzbGlkZU9mZnNldCIsInVuZXZlbk9mZnNldCIsInByZXZpb3VzVGFyZ2V0U2xpZGUiLCJtZXNzYWdlIiwiZGlyZWN0aW9uIiwiTnVtYmVyIiwiZSIsImFjY2Vzc2liaWxpdHkiLCJ0YWdOYW1lIiwibWF0Y2giLCJrZXlDb2RlIiwic3dpcGUiLCJkcmFnZ2FibGUiLCJ0eXBlIiwiZHJhZ2dpbmciLCJ0b3VjaGVzIiwicGFnZVgiLCJjbGllbnRYIiwicGFnZVkiLCJjbGllbnRZIiwic2Nyb2xsaW5nIiwic3dpcGVUb1NsaWRlIiwiZWRnZUZyaWN0aW9uIiwiZWRnZURyYWdnZWQiLCJvbkVkZ2UiLCJzd2lwZWQiLCJzd2lwaW5nIiwic3dpcGVFdmVudCIsImN1ckxlZnQiLCJzd2lwZUxlbmd0aCIsInNxcnQiLCJwb3ciLCJ2ZXJ0aWNhbFN3aXBlTGVuZ3RoIiwicG9zaXRpb25PZmZzZXQiLCJkb3RDb3VudCIsInN3aXBlRGlyZWN0aW9uIiwidG91Y2hTd2lwZUxlbmd0aCIsInRvdWNoVGhyZXNob2xkIiwib25Td2lwZSIsIm1pblN3aXBlIiwibmV3U2xpZGUiLCJhY3RpdmVTbGlkZSIsImN1cnJlbnRMZWZ0IiwiYnJlYWtwb2ludCIsImNvdW50ZXIiLCJpbmRleGVzIiwibmF2aWdhYmxlcyIsInByZXZOYXZpZ2FibGUiLCJuIiwiY2VudGVyT2Zmc2V0Iiwic3dpcGVkU2xpZGUiLCJzbGlja0xpc3QiLCJzbGlkZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJzbGlkZSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjdXJyZW50SW5kZXgiLCJzbGlkZXNUcmF2ZXJzZWQiLCJkYXRhc2V0Iiwia2V5c0FycmF5IiwicmVkdWNlIiwiaGFzT3duUHJvcGVydHkiLCJjb25zb2xlIiwiZXJyb3IiLCJ0cmFja0hlaWdodCIsInRyYWNrQ2hpbGRyZW4iLCJzdHlsZSIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwiV2Via2l0VHJhbnNpdGlvbiIsInVzZVRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwid2lkdGgiLCJoZWlnaHQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwic3BlZWQiLCJjc3NFYXNlIiwidW5zbGljayIsInZhcmlhYmxlV2lkdGgiLCJ0YXJnZXRMZWZ0IiwidmVydGljYWxPZmZzZXQiLCJzbGlkZXNUb09mZnNldCIsInRhcmdldFNsaWRlSW5kZXgiLCJ0cmFja0VsZW0iLCJjaGlsZE5vZGVzIiwiX3JlZiIsInJpZ2h0IiwiX3JlZjIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXR0aW5ncyIsImFjYyIsInNldHRpbmdOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */ /* eslint-disable require-jsdoc, valid-jsdoc */ var MapShim = function() {\n    if (typeof Map !== \"undefined\") {\n        return Map;\n    }\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */ function getIndex(arr, key) {\n        var result = -1;\n        arr.some(function(entry, index) {\n            if (entry[0] === key) {\n                result = index;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    }\n    return /** @class */ function() {\n        function class_1() {\n            this.__entries__ = [];\n        }\n        Object.defineProperty(class_1.prototype, \"size\", {\n            /**\r\n             * @returns {boolean}\r\n             */ get: function() {\n                return this.__entries__.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */ class_1.prototype.get = function(key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n            return entry && entry[1];\n        };\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */ class_1.prototype.set = function(key, value) {\n            var index = getIndex(this.__entries__, key);\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([\n                    key,\n                    value\n                ]);\n            }\n        };\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */ class_1.prototype.delete = function(key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */ class_1.prototype.has = function(key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n        /**\r\n         * @returns {void}\r\n         */ class_1.prototype.clear = function() {\n            this.__entries__.splice(0);\n        };\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */ class_1.prototype.forEach = function(callback, ctx) {\n            if (ctx === void 0) {\n                ctx = null;\n            }\n            for(var _i = 0, _a = this.__entries__; _i < _a.length; _i++){\n                var entry = _a[_i];\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n        return class_1;\n    }();\n}();\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */ var isBrowser =  true && typeof document !== \"undefined\" && window.document === document;\n// Returns global object of a current environment.\nvar global$1 = function() {\n    if (typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g.Math === Math) {\n        return __webpack_require__.g;\n    }\n    if (typeof self !== \"undefined\" && self.Math === Math) {\n        return self;\n    }\n    if ( true && window.Math === Math) {\n        return window;\n    }\n    // eslint-disable-next-line no-new-func\n    return Function(\"return this\")();\n}();\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */ var requestAnimationFrame$1 = function() {\n    if (typeof requestAnimationFrame === \"function\") {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n    return function(callback) {\n        return setTimeout(function() {\n            return callback(Date.now());\n        }, 1000 / 60);\n    };\n}();\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */ function throttle(callback, delay) {\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */ function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n            callback();\n        }\n        if (trailingCall) {\n            proxy();\n        }\n    }\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */ function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */ function proxy() {\n        var timeStamp = Date.now();\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n            setTimeout(timeoutCallback, delay);\n        }\n        lastCallTime = timeStamp;\n    }\n    return proxy;\n}\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\",\n    \"width\",\n    \"height\",\n    \"size\",\n    \"weight\"\n];\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== \"undefined\";\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */ var ResizeObserverController = /** @class */ function() {\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */ function ResizeObserverController() {\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */ this.connected_ = false;\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */ this.mutationEventsAdded_ = false;\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */ this.mutationsObserver_ = null;\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */ this.observers_ = [];\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n    }\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.addObserver = function(observer) {\n        if (!~this.observers_.indexOf(observer)) {\n            this.observers_.push(observer);\n        }\n        // Add listeners if they haven't been added yet.\n        if (!this.connected_) {\n            this.connect_();\n        }\n    };\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.removeObserver = function(observer) {\n        var observers = this.observers_;\n        var index = observers.indexOf(observer);\n        // Remove observer if it's present in registry.\n        if (~index) {\n            observers.splice(index, 1);\n        }\n        // Remove listeners if controller has no connected observers.\n        if (!observers.length && this.connected_) {\n            this.disconnect_();\n        }\n    };\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.refresh = function() {\n        var changesDetected = this.updateObservers_();\n        // Continue running updates if changes have been detected as there might\n        // be future ones caused by CSS transitions.\n        if (changesDetected) {\n            this.refresh();\n        }\n    };\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */ ResizeObserverController.prototype.updateObservers_ = function() {\n        // Collect observers that have active observations.\n        var activeObservers = this.observers_.filter(function(observer) {\n            return observer.gatherActive(), observer.hasActive();\n        });\n        // Deliver notifications in a separate cycle in order to avoid any\n        // collisions between observers, e.g. when multiple instances of\n        // ResizeObserver are tracking the same element and the callback of one\n        // of them changes content dimensions of the observed target. Sometimes\n        // this may result in notifications being blocked for the rest of observers.\n        activeObservers.forEach(function(observer) {\n            return observer.broadcastActive();\n        });\n        return activeObservers.length > 0;\n    };\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.connect_ = function() {\n        // Do nothing if running in a non-browser environment or if listeners\n        // have been already added.\n        if (!isBrowser || this.connected_) {\n            return;\n        }\n        // Subscription to the \"Transitionend\" event is used as a workaround for\n        // delayed transitions. This way it's possible to capture at least the\n        // final state of an element.\n        document.addEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.addEventListener(\"resize\", this.refresh);\n        if (mutationObserverSupported) {\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\n            this.mutationsObserver_.observe(document, {\n                attributes: true,\n                childList: true,\n                characterData: true,\n                subtree: true\n            });\n        } else {\n            document.addEventListener(\"DOMSubtreeModified\", this.refresh);\n            this.mutationEventsAdded_ = true;\n        }\n        this.connected_ = true;\n    };\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.disconnect_ = function() {\n        // Do nothing if running in a non-browser environment or if listeners\n        // have been already removed.\n        if (!isBrowser || !this.connected_) {\n            return;\n        }\n        document.removeEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.removeEventListener(\"resize\", this.refresh);\n        if (this.mutationsObserver_) {\n            this.mutationsObserver_.disconnect();\n        }\n        if (this.mutationEventsAdded_) {\n            document.removeEventListener(\"DOMSubtreeModified\", this.refresh);\n        }\n        this.mutationsObserver_ = null;\n        this.mutationEventsAdded_ = false;\n        this.connected_ = false;\n    };\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */ ResizeObserverController.prototype.onTransitionEnd_ = function(_a) {\n        var _b = _a.propertyName, propertyName = _b === void 0 ? \"\" : _b;\n        // Detect whether transition may affect dimensions of an element.\n        var isReflowProperty = transitionKeys.some(function(key) {\n            return !!~propertyName.indexOf(key);\n        });\n        if (isReflowProperty) {\n            this.refresh();\n        }\n    };\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */ ResizeObserverController.getInstance = function() {\n        if (!this.instance_) {\n            this.instance_ = new ResizeObserverController();\n        }\n        return this.instance_;\n    };\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */ ResizeObserverController.instance_ = null;\n    return ResizeObserverController;\n}();\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */ var defineConfigurable = function(target, props) {\n    for(var _i = 0, _a = Object.keys(props); _i < _a.length; _i++){\n        var key = _a[_i];\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n    return target;\n};\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */ var getWindowOf = function(target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n};\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */ function toFloat(value) {\n    return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */ function getBordersSize(styles) {\n    var positions = [];\n    for(var _i = 1; _i < arguments.length; _i++){\n        positions[_i - 1] = arguments[_i];\n    }\n    return positions.reduce(function(size, position) {\n        var value = styles[\"border-\" + position + \"-width\"];\n        return size + toFloat(value);\n    }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */ function getPaddings(styles) {\n    var positions = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    var paddings = {};\n    for(var _i = 0, positions_1 = positions; _i < positions_1.length; _i++){\n        var position = positions_1[_i];\n        var value = styles[\"padding-\" + position];\n        paddings[position] = toFloat(value);\n    }\n    return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */ function getSVGContentRect(target) {\n    var bbox = target.getBBox();\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */ function getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width), height = toFloat(styles.height);\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === \"border-box\") {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, \"left\", \"right\") + horizPad;\n        }\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, \"top\", \"bottom\") + vertPad;\n        }\n    }\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */ var isSVGGraphicsElement = function() {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== \"undefined\") {\n        return function(target) {\n            return target instanceof getWindowOf(target).SVGGraphicsElement;\n        };\n    }\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function(target) {\n        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \"function\";\n    };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */ function isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */ function getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n    return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */ function createReadOnlyRect(_a) {\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== \"undefined\" ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n    return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */ function createRectInit(x, y, width, height) {\n    return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n    };\n}\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */ var ResizeObservation = /** @class */ function() {\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */ function ResizeObservation(target) {\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */ this.broadcastWidth = 0;\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */ this.broadcastHeight = 0;\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */ this.contentRect_ = createRectInit(0, 0, 0, 0);\n        this.target = target;\n    }\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */ ResizeObservation.prototype.isActive = function() {\n        var rect = getContentRect(this.target);\n        this.contentRect_ = rect;\n        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n    };\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */ ResizeObservation.prototype.broadcastRect = function() {\n        var rect = this.contentRect_;\n        this.broadcastWidth = rect.width;\n        this.broadcastHeight = rect.height;\n        return rect;\n    };\n    return ResizeObservation;\n}();\nvar ResizeObserverEntry = /** @class */ function() {\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */ function ResizeObserverEntry(target, rectInit) {\n        var contentRect = createReadOnlyRect(rectInit);\n        // According to the specification following properties are not writable\n        // and are also not enumerable in the native implementation.\n        //\n        // Property accessors are not being used as they'd require to define a\n        // private WeakMap storage which may cause memory leaks in browsers that\n        // don't support this type of collections.\n        defineConfigurable(this, {\n            target: target,\n            contentRect: contentRect\n        });\n    }\n    return ResizeObserverEntry;\n}();\nvar ResizeObserverSPI = /** @class */ function() {\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */ function ResizeObserverSPI(callback, controller, callbackCtx) {\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */ this.activeObservations_ = [];\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */ this.observations_ = new MapShim();\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"The callback provided as parameter 1 is not a function.\");\n        }\n        this.callback_ = callback;\n        this.controller_ = controller;\n        this.callbackCtx_ = callbackCtx;\n    }\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.observe = function(target) {\n        if (!arguments.length) {\n            throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        // Do nothing if current environment doesn't have the Element interface.\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n            return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n            throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        // Do nothing if element is already being observed.\n        if (observations.has(target)) {\n            return;\n        }\n        observations.set(target, new ResizeObservation(target));\n        this.controller_.addObserver(this);\n        // Force the update of observations.\n        this.controller_.refresh();\n    };\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.unobserve = function(target) {\n        if (!arguments.length) {\n            throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        // Do nothing if current environment doesn't have the Element interface.\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n            return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n            throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        // Do nothing if element is not being observed.\n        if (!observations.has(target)) {\n            return;\n        }\n        observations.delete(target);\n        if (!observations.size) {\n            this.controller_.removeObserver(this);\n        }\n    };\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.disconnect = function() {\n        this.clearActive();\n        this.observations_.clear();\n        this.controller_.removeObserver(this);\n    };\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.gatherActive = function() {\n        var _this = this;\n        this.clearActive();\n        this.observations_.forEach(function(observation) {\n            if (observation.isActive()) {\n                _this.activeObservations_.push(observation);\n            }\n        });\n    };\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.broadcastActive = function() {\n        // Do nothing if observer doesn't have active observations.\n        if (!this.hasActive()) {\n            return;\n        }\n        var ctx = this.callbackCtx_;\n        // Create ResizeObserverEntry instance for every active observation.\n        var entries = this.activeObservations_.map(function(observation) {\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n        });\n        this.callback_.call(ctx, entries, ctx);\n        this.clearActive();\n    };\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */ ResizeObserverSPI.prototype.clearActive = function() {\n        this.activeObservations_.splice(0);\n    };\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */ ResizeObserverSPI.prototype.hasActive = function() {\n        return this.activeObservations_.length > 0;\n    };\n    return ResizeObserverSPI;\n}();\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== \"undefined\" ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */ var ResizeObserver = /** @class */ function() {\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */ function ResizeObserver(callback) {\n        if (!(this instanceof ResizeObserver)) {\n            throw new TypeError(\"Cannot call a class as a function.\");\n        }\n        if (!arguments.length) {\n            throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        var controller = ResizeObserverController.getInstance();\n        var observer = new ResizeObserverSPI(callback, controller, this);\n        observers.set(this, observer);\n    }\n    return ResizeObserver;\n}();\n// Expose public methods of ResizeObserver.\n[\n    \"observe\",\n    \"unobserve\",\n    \"disconnect\"\n].forEach(function(method) {\n    ResizeObserver.prototype[method] = function() {\n        var _a;\n        return (_a = observers.get(this))[method].apply(_a, arguments);\n    };\n});\nvar index = function() {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== \"undefined\") {\n        return global$1.ResizeObserver;\n    }\n    return ResizeObserver;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0NBS0MsR0FDRCw2Q0FBNkMsR0FDN0MsSUFBSUEsVUFBVTtJQUNWLElBQUksT0FBT0MsUUFBUSxhQUFhO1FBQzVCLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0tBTUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHLEVBQUVDLEdBQUc7UUFDdEIsSUFBSUMsU0FBUyxDQUFDO1FBQ2RGLElBQUlHLElBQUksQ0FBQyxTQUFVQyxLQUFLLEVBQUVDLEtBQUs7WUFDM0IsSUFBSUQsS0FBSyxDQUFDLEVBQUUsS0FBS0gsS0FBSztnQkFDbEJDLFNBQVNHO2dCQUNULE9BQU87WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU9IO0lBQ1g7SUFDQSxPQUFPLFdBQVcsR0FBSTtRQUNsQixTQUFTSTtZQUNMLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7UUFDekI7UUFDQUMsT0FBT0MsY0FBYyxDQUFDSCxRQUFRSSxTQUFTLEVBQUUsUUFBUTtZQUM3Qzs7YUFFQyxHQUNEQyxLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDSixXQUFXLENBQUNLLE1BQU07WUFDbEM7WUFDQUMsWUFBWTtZQUNaQyxjQUFjO1FBQ2xCO1FBQ0E7OztTQUdDLEdBQ0RSLFFBQVFJLFNBQVMsQ0FBQ0MsR0FBRyxHQUFHLFNBQVVWLEdBQUc7WUFDakMsSUFBSUksUUFBUU4sU0FBUyxJQUFJLENBQUNRLFdBQVcsRUFBRU47WUFDdkMsSUFBSUcsUUFBUSxJQUFJLENBQUNHLFdBQVcsQ0FBQ0YsTUFBTTtZQUNuQyxPQUFPRCxTQUFTQSxLQUFLLENBQUMsRUFBRTtRQUM1QjtRQUNBOzs7O1NBSUMsR0FDREUsUUFBUUksU0FBUyxDQUFDSyxHQUFHLEdBQUcsU0FBVWQsR0FBRyxFQUFFZSxLQUFLO1lBQ3hDLElBQUlYLFFBQVFOLFNB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TSxJQUFJWixVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDdEQsVUFBVS9GLE1BQU0sRUFBRTtZQUNuQixNQUFNLElBQUlxSixVQUFVO1FBQ3hCO1FBQ0EsSUFBSUosYUFBYXBHLHlCQUF5QmdDLFdBQVc7UUFDckQsSUFBSXhCLFdBQVcsSUFBSTJGLGtCQUFrQnBJLFVBQVVxSSxZQUFZLElBQUk7UUFDL0R4RixVQUFVdEQsR0FBRyxDQUFDLElBQUksRUFBRWtEO0lBQ3hCO0lBQ0EsT0FBTzRHO0FBQ1g7QUFDQSwyQ0FBMkM7QUFDM0M7SUFDSTtJQUNBO0lBQ0E7Q0FDSCxDQUFDdEosT0FBTyxDQUFDLFNBQVV1SixNQUFNO0lBQ3RCRCxlQUFlbkssU0FBUyxDQUFDb0ssT0FBTyxHQUFHO1FBQy9CLElBQUluSjtRQUNKLE9BQU8sQ0FBQ0EsS0FBSzBDLFVBQVUxRCxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUNtSyxPQUFPLENBQUNDLEtBQUssQ0FBQ3BKLElBQUlnRjtJQUN4RDtBQUNKO0FBRUEsSUFBSXRHLFFBQVE7SUFDUiwrQ0FBK0M7SUFDL0MsSUFBSSxPQUFPMkIsU0FBUzZJLGNBQWMsS0FBSyxhQUFhO1FBQ2hELE9BQU83SSxTQUFTNkksY0FBYztJQUNsQztJQUNBLE9BQU9BO0FBQ1g7QUFFQSwrREFBZXhLLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzP2YzNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiJdLCJuYW1lcyI6WyJNYXBTaGltIiwiTWFwIiwiZ2V0SW5kZXgiLCJhcnIiLCJrZXkiLCJyZXN1bHQiLCJzb21lIiwiZW50cnkiLCJpbmRleCIsImNsYXNzXzEiLCJfX2VudHJpZXNfXyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsInZhbHVlIiwicHVzaCIsImRlbGV0ZSIsImVudHJpZXMiLCJzcGxpY2UiLCJoYXMiLCJjbGVhciIsImZvckVhY2giLCJjYWxsYmFjayIsImN0eCIsIl9pIiwiX2EiLCJjYWxsIiwiaXNCcm93c2VyIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJnbG9iYWwkMSIsImdsb2JhbCIsIk1hdGgiLCJzZWxmIiwiRnVuY3Rpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJpbmQiLCJzZXRUaW1lb3V0IiwiRGF0ZSIsIm5vdyIsInRyYWlsaW5nVGltZW91dCIsInRocm90dGxlIiwiZGVsYXkiLCJsZWFkaW5nQ2FsbCIsInRyYWlsaW5nQ2FsbCIsImxhc3RDYWxsVGltZSIsInJlc29sdmVQZW5kaW5nIiwicHJveHkiLCJ0aW1lb3V0Q2FsbGJhY2siLCJ0aW1lU3RhbXAiLCJSRUZSRVNIX0RFTEFZIiwidHJhbnNpdGlvbktleXMiLCJtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiTXV0YXRpb25PYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciIsImNvbm5lY3RlZF8iLCJtdXRhdGlvbkV2ZW50c0FkZGVkXyIsIm11dGF0aW9uc09ic2VydmVyXyIsIm9ic2VydmVyc18iLCJvblRyYW5zaXRpb25FbmRfIiwicmVmcmVzaCIsImFkZE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJpbmRleE9mIiwiY29ubmVjdF8iLCJyZW1vdmVPYnNlcnZlciIsIm9ic2VydmVycyIsImRpc2Nvbm5lY3RfIiwiY2hhbmdlc0RldGVjdGVkIiwidXBkYXRlT2JzZXJ2ZXJzXyIsImFjdGl2ZU9ic2VydmVycyIsImZpbHRlciIsImdhdGhlckFjdGl2ZSIsImhhc0FjdGl2ZSIsImJyb2FkY2FzdEFjdGl2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJfYiIsInByb3BlcnR5TmFtZSIsImlzUmVmbG93UHJvcGVydHkiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlXyIsImRlZmluZUNvbmZpZ3VyYWJsZSIsInRhcmdldCIsInByb3BzIiwia2V5cyIsIndyaXRhYmxlIiwiZ2V0V2luZG93T2YiLCJvd25lckdsb2JhbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImVtcHR5UmVjdCIsImNyZWF0ZVJlY3RJbml0IiwidG9GbG9hdCIsInBhcnNlRmxvYXQiLCJnZXRCb3JkZXJzU2l6ZSIsInN0eWxlcyIsInBvc2l0aW9ucyIsImFyZ3VtZW50cyIsInJlZHVjZSIsInNpemUiLCJwb3NpdGlvbiIsImdldFBhZGRpbmdzIiwicGFkZGluZ3MiLCJwb3NpdGlvbnNfMSIsImdldFNWR0NvbnRlbnRSZWN0IiwiYmJveCIsImdldEJCb3giLCJ3aWR0aCIsImhlaWdodCIsImdldEhUTUxFbGVtZW50Q29udGVudFJlY3QiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldENvbXB1dGVkU3R5bGUiLCJob3JpelBhZCIsImxlZnQiLCJyaWdodCIsInZlcnRQYWQiLCJ0b3AiLCJib3R0b20iLCJib3hTaXppbmciLCJyb3VuZCIsImlzRG9jdW1lbnRFbGVtZW50IiwidmVydFNjcm9sbGJhciIsImhvcml6U2Nyb2xsYmFyIiwiYWJzIiwiaXNTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0Q29udGVudFJlY3QiLCJjcmVhdGVSZWFkT25seVJlY3QiLCJ4IiwieSIsIkNvbnN0ciIsIkRPTVJlY3RSZWFkT25seSIsInJlY3QiLCJjcmVhdGUiLCJSZXNpemVPYnNlcnZhdGlvbiIsImJyb2FkY2FzdFdpZHRoIiwiYnJvYWRjYXN0SGVpZ2h0IiwiY29udGVudFJlY3RfIiwiaXNBY3RpdmUiLCJicm9hZGNhc3RSZWN0IiwiUmVzaXplT2JzZXJ2ZXJFbnRyeSIsInJlY3RJbml0IiwiY29udGVudFJlY3QiLCJSZXNpemVPYnNlcnZlclNQSSIsImNvbnRyb2xsZXIiLCJjYWxsYmFja0N0eCIsImFjdGl2ZU9ic2VydmF0aW9uc18iLCJvYnNlcnZhdGlvbnNfIiwiVHlwZUVycm9yIiwiY2FsbGJhY2tfIiwiY29udHJvbGxlcl8iLCJjYWxsYmFja0N0eF8iLCJFbGVtZW50Iiwib2JzZXJ2YXRpb25zIiwidW5vYnNlcnZlIiwiY2xlYXJBY3RpdmUiLCJfdGhpcyIsIm9ic2VydmF0aW9uIiwibWFwIiwiV2Vha01hcCIsIlJlc2l6ZU9ic2VydmVyIiwibWV0aG9kIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js":
/*!*****************************************************!*\
  !*** ./node_modules/string-convert/camel2hyphen.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar camel2hyphen = function(str) {\n    return str.replace(/[A-Z]/g, function(match) {\n        return \"-\" + match.toLowerCase();\n    }).toLowerCase();\n};\nmodule.exports = camel2hyphen;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJpbmctY29udmVydC9jYW1lbDJoeXBoZW4uanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLGVBQWUsU0FBVUMsR0FBRztJQUM5QixPQUFPQSxJQUNFQyxPQUFPLENBQUMsVUFBVSxTQUFVQyxLQUFLO1FBQ2hDLE9BQU8sTUFBTUEsTUFBTUMsV0FBVztJQUNoQyxHQUNDQSxXQUFXO0FBQ3RCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cmluZy1jb252ZXJ0L2NhbWVsMmh5cGhlbi5qcz82ZTgwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjYW1lbDJoeXBoZW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbDJoeXBoZW47Il0sIm5hbWVzIjpbImNhbWVsMmh5cGhlbiIsInN0ciIsInJlcGxhY2UiLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css":
/*!***********************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick-theme.css ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"830cbd4048cd\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay10aGVtZS5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay10aGVtZS5jc3M/OGRlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjgzMGNiZDQwNDhjZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css":
/*!*****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.css ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"fe7d55f30d9b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3M/MDJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImZlN2Q1NWYzMGQ5YlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/matching/global.css":
/*!*************************************!*\
  !*** ./src/app/matching/global.css ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"add39bb7442c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0Y2hpbmcvZ2xvYmFsLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9tYXRjaGluZy9nbG9iYWwuY3NzPzEyYTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhZGQzOWJiNzQ0MmNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matching/global.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/messages/[id]/global.css":
/*!******************************************!*\
  !*** ./src/app/messages/[id]/global.css ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"bf47f0c97280\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWVzc2FnZXMvW2lkXS9nbG9iYWwuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL21lc3NhZ2VzL1tpZF0vZ2xvYmFsLmNzcz82NTAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYmY0N2YwYzk3MjgwXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/messages/[id]/global.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/recent-messages/global.css":
/*!********************************************!*\
  !*** ./src/app/recent-messages/global.css ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"4742b088d0cc\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcmVjZW50LW1lc3NhZ2VzL2dsb2JhbC5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvcmVjZW50LW1lc3NhZ2VzL2dsb2JhbC5jc3M/MzExYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjQ3NDJiMDg4ZDBjY1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/recent-messages/global.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/users/global.css":
/*!**********************************!*\
  !*** ./src/app/users/global.css ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"25dc6d7adafa\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXNlcnMvZ2xvYmFsLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC91c2Vycy9nbG9iYWwuY3NzP2RiMmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyNWRjNmQ3YWRhZmFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/users/global.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/dashboard.css":
/*!**********************************!*\
  !*** ./src/styles/dashboard.css ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"e0a520fc4532\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvZGFzaGJvYXJkLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0eWxlcy9kYXNoYm9hcmQuY3NzPzRhZWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJlMGE1MjBmYzQ1MzJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/dashboard.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/plan.css":
/*!*****************************!*\
  !*** ./src/styles/plan.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"497a4c970245\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvcGxhbi5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvcGxhbi5jc3M/ZjYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjQ5N2E0Yzk3MDI0NVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/plan.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/tinder.css":
/*!*******************************!*\
  !*** ./src/styles/tinder.css ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"6075529de15e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvdGluZGVyLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0eWxlcy90aW5kZXIuY3NzP2RiMDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2MDc1NTI5ZGUxNWVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/tinder.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1GLFlBQVksU0FBU0csSUFBSTtJQUMzQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87UUFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNwQztJQUNBLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPUDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanM/ZTJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBhZGRMb2NhbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlXCIpLmFkZExvY2FsZShwYXRoLCAuLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwicGF0aCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywwQkFBMEJDLG1CQUFPQSxDQUFDLG1IQUE0QjtBQUNwRSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLGdCQUFnQk8sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsYUFBYTtJQUN6RCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPO0lBQUs7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDdkUsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsMkZBQWdCO0FBQzdDLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyxpSUFBdUM7QUFDbEUsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLHVGQUFjO0FBQ3pDLE1BQU1TLDhCQUE4QlQsbUJBQU9BLENBQUMsNklBQTZDO0FBQ3pGLE1BQU1VLGlDQUFpQ1YsbUJBQU9BLENBQUMscUpBQWlEO0FBQ2hHLE1BQU1XLG1CQUFtQlgsbUJBQU9BLENBQUMsbUdBQW9CO0FBQ3JELE1BQU1ZLG1CQUFtQlosbUJBQU9BLENBQUMscUdBQXFCO0FBQ3RELE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLDZGQUFpQjtBQUM5QyxNQUFNYyxzQkFBc0JkLG1CQUFPQSxDQUFDLCtKQUFrRDtBQUN0RixNQUFNZSxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ2hFLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUNELGdKQUFnSjtJQUNoSixJQUFJLENBQUNBLGVBQWUsQ0FBQyxDQUFDLEdBQUdsQixZQUFZbUIsVUFBVSxFQUFFTCxPQUFPO1FBQ3BEO0lBQ0o7SUFDQSw0RUFBNEU7SUFDNUUsWUFBWTtJQUNaLElBQUksQ0FBQ0UsUUFBUUkscUJBQXFCLEVBQUU7UUFDaEMsTUFBTUMsU0FDTixPQUFPTCxRQUFRSyxNQUFNLEtBQUssY0FBY0wsUUFBUUssTUFBTSxHQUFHLFlBQVlSLFNBQVNBLE9BQU9RLE1BQU0sR0FBR0M7UUFDOUYsTUFBTUMsZ0JBQWdCVCxPQUFPLE1BQU1DLEtBQUssTUFBTU07UUFDOUMsa0VBQWtFO1FBQ2xFLElBQUlYLFdBQVdjLEdBQUcsQ0FBQ0QsZ0JBQWdCO1lBQy9CO1FBQ0o7UUFDQSwrQkFBK0I7UUFDL0JiLFdBQVdlLEdBQUcsQ0FBQ0Y7SUFDbkI7SUFDQSxNQUFNRyxrQkFBa0JSLGNBQWNMLE9BQU9ELFFBQVEsQ0FBQ0UsTUFBTUcsY0FBY0osT0FBT0QsUUFBUSxDQUFDRSxNQUFNQyxJQUFJQztJQUNwRyx1REFBdUQ7SUFDdkQsMERBQTBEO0lBQzFELHNEQUFzRDtJQUN0RCx5REFBeUQ7SUFDekRXLFFBQVFDLE9BQU8sQ0FBQ0YsaUJBQWlCRyxLQUFLLENBQUMsQ0FBQ0M7UUFDcEMsSUFBSUMsSUFBcUMsRUFBRTtZQUN2QyxxQ0FBcUM7WUFDckMsTUFBTUQ7UUFDVjtJQUNKO0FBQ0o7QUFDQSxTQUFTRSxnQkFBZ0JDLEtBQUs7SUFDMUIsTUFBTUMsY0FBY0QsTUFBTUUsYUFBYTtJQUN2QyxNQUFNQyxTQUFTRixZQUFZRyxZQUFZLENBQUM7SUFDeEMsT0FBT0QsVUFBVUEsV0FBVyxXQUFXSCxNQUFNSyxPQUFPLElBQUlMLE1BQU1NLE9BQU8sSUFBSU4sTUFBTU8sUUFBUSxJQUFJUCxNQUFNUSxNQUFNLElBQUksNkJBQTZCO0lBQ3hJUixNQUFNUyxXQUFXLElBQUlULE1BQU1TLFdBQVcsQ0FBQ0MsS0FBSyxLQUFLO0FBQ3JEO0FBQ0EsU0FBU0MsWUFBWUMsQ0FBQyxFQUFFaEMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRStCLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUzQixNQUFNLEVBQUVILFdBQVc7SUFDbkYsTUFBTSxFQUFFK0IsUUFBUSxFQUFFLEdBQUdKLEVBQUVWLGFBQWE7SUFDcEMsa0RBQWtEO0lBQ2xELE1BQU1lLG1CQUFtQkQsU0FBU0UsV0FBVyxPQUFPO0lBQ3BELElBQUlELG9CQUFxQmxCLENBQUFBLGdCQUFnQmEsTUFBTSxnSkFBZ0o7SUFDL0wsQ0FBQzNCLGVBQWUsQ0FBQyxDQUFDLEdBQUdsQixZQUFZbUIsVUFBVSxFQUFFTCxLQUFJLEdBQUk7UUFDakQsOENBQThDO1FBQzlDO0lBQ0o7SUFDQStCLEVBQUVPLGNBQWM7SUFDaEIsTUFBTUMsV0FBVztRQUNiLHdFQUF3RTtRQUN4RSxNQUFNQyxlQUFlTixVQUFVLE9BQU9BLFNBQVM7UUFDL0MsSUFBSSxvQkFBb0JuQyxRQUFRO1lBQzVCQSxNQUFNLENBQUNpQyxVQUFVLFlBQVksT0FBTyxDQUFDaEMsTUFBTUMsSUFBSTtnQkFDM0NnQztnQkFDQTFCO2dCQUNBMkIsUUFBUU07WUFDWjtRQUNKLE9BQU87WUFDSHpDLE1BQU0sQ0FBQ2lDLFVBQVUsWUFBWSxPQUFPLENBQUMvQixNQUFNRCxNQUFNO2dCQUM3Q2tDLFFBQVFNO1lBQ1o7UUFDSjtJQUNKO0lBQ0EsSUFBSXBDLGFBQWE7UUFDYnJCLE9BQU8wRCxPQUFPLENBQUNDLGVBQWUsQ0FBQ0g7SUFDbkMsT0FBTztRQUNIQTtJQUNKO0FBQ0o7QUFDQSxTQUFTSSxrQkFBa0JDLGNBQWM7SUFDckMsSUFBSSxPQUFPQSxtQkFBbUIsVUFBVTtRQUNwQyxPQUFPQTtJQUNYO0lBQ0EsT0FBTyxDQUFDLEdBQUd6RCxXQUFXMEQsU0FBUyxFQUFFRDtBQUNyQztBQUNBOztDQUVDLEdBQUcsTUFBTUUsT0FBTyxXQUFXLEdBQUcvRCxHQUFBQSxPQUFPMEQsT0FBTyxDQUFDTSxVQUFVLFNBQUMsU0FBU0MsY0FBY0MsS0FBSyxFQUFFQyxZQUFZOztJQUMvRixJQUFJQztJQUNKLE1BQU0sRUFBRW5ELE1BQU1vRCxRQUFRLEVBQUVuRCxJQUFJb0QsTUFBTSxFQUFFRixVQUFVRyxZQUFZLEVBQUV4RCxVQUFVeUQsZUFBZSxJQUFJLEVBQUVDLFFBQVEsRUFBRXhCLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUzQixNQUFNLEVBQUVrRCxPQUFPLEVBQUVDLGNBQWNDLGdCQUFnQixFQUFFQyxjQUFjQyxnQkFBZ0IsRUFBRUMsaUJBQWlCLEtBQUssRUFBRSxHQUFHQyxXQUFXLEdBQUdkO0lBQ3pQRSxXQUFXRztJQUNYLElBQUlRLGtCQUFtQixRQUFPWCxhQUFhLFlBQVksT0FBT0EsYUFBYSxRQUFPLEdBQUk7UUFDbEZBLFdBQXlCLFdBQUgsR0FBSSxJQUFHckUsWUFBWWtGLEdBQUcsRUFBRSxLQUFLO1lBQy9DYixVQUFVQTtRQUNkO0lBQ0o7SUFDQSxNQUFNYyxjQUFjbEYsT0FBTzBELE9BQU8sQ0FBQ3lCLFVBQVUsQ0FBQzVFLDRCQUE0QjZFLGFBQWE7SUFDdkYsTUFBTUMsWUFBWXJGLE9BQU8wRCxPQUFPLENBQUN5QixVQUFVLENBQUMzRSwrQkFBK0I4RSxnQkFBZ0I7SUFDM0YsTUFBTXRFLFNBQVNrRSxlQUFlLE9BQU9BLGNBQWNHO0lBQ25ELDBEQUEwRDtJQUMxRCxNQUFNaEUsY0FBYyxDQUFDNkQ7SUFDckIsTUFBTUssa0JBQWtCZixpQkFBaUI7SUFDekM7Ozs7O0tBS0MsR0FBRyxNQUFNZ0Isa0JBQWtCaEIsaUJBQWlCLE9BQU81RCxvQkFBb0I2RSxZQUFZLENBQUNDLElBQUksR0FBRzlFLG9CQUFvQjZFLFlBQVksQ0FBQ0UsSUFBSTtJQUNqSSxJQUFJekQsSUFBcUMsRUFBRTtRQUN2QyxTQUFTMEQsZ0JBQWdCQyxJQUFJO1lBQ3pCLE9BQU8sSUFBSUMsTUFBTSxpQ0FBaUNELEtBQUtFLEdBQUcsR0FBRyxpQkFBaUJGLEtBQUtHLFFBQVEsR0FBRyw0QkFBNEJILEtBQUtJLE1BQU0sR0FBRyxlQUFnQixNQUE2QixHQUFHLHFFQUFxRSxDQUFDO1FBQ2xRO1FBQ0Esc0NBQXNDO1FBQ3RDLE1BQU1DLHFCQUFxQjtZQUN2QmpGLE1BQU07UUFDVjtRQUNBLE1BQU1rRixnQkFBZ0I3RyxPQUFPOEcsSUFBSSxDQUFDRjtRQUNsQ0MsY0FBY0UsT0FBTyxDQUFDLENBQUNOO1lBQ25CLElBQUlBLFFBQVEsUUFBUTtnQkFDaEIsSUFBSTdCLEtBQUssQ0FBQzZCLElBQUksSUFBSSxRQUFRLE9BQU83QixLQUFLLENBQUM2QixJQUFJLEtBQUssWUFBWSxPQUFPN0IsS0FBSyxDQUFDNkIsSUFBSSxLQUFLLFVBQVU7b0JBQ3hGLE1BQU1ILGdCQUFnQjt3QkFDbEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRL0IsS0FBSyxDQUFDNkIsSUFBSSxLQUFLLE9BQU8sU0FBUyxPQUFPN0IsS0FBSyxDQUFDNkIsSUFBSTtvQkFDNUQ7Z0JBQ0o7WUFDSixPQUFPO2dCQUNILHNDQUFzQztnQkFDdEMsNkRBQTZEO2dCQUM3RCxNQUFNOUYsSUFBSThGO1lBQ2Q7UUFDSjtRQUNBLHNDQUFzQztRQUN0QyxNQUFNTyxxQkFBcUI7WUFDdkJwRixJQUFJO1lBQ0orQixTQUFTO1lBQ1RFLFFBQVE7WUFDUkQsU0FBUztZQUNUdUIsVUFBVTtZQUNWMUQsVUFBVTtZQUNWUyxRQUFRO1lBQ1JrRCxTQUFTO1lBQ1RDLGNBQWM7WUFDZEUsY0FBYztZQUNkRSxnQkFBZ0I7UUFDcEI7UUFDQSxNQUFNd0IsZ0JBQWdCakgsT0FBTzhHLElBQUksQ0FBQ0U7UUFDbENDLGNBQWNGLE9BQU8sQ0FBQyxDQUFDTjtZQUNuQixNQUFNUyxVQUFVLE9BQU90QyxLQUFLLENBQUM2QixJQUFJO1lBQ2pDLElBQUlBLFFBQVEsTUFBTTtnQkFDZCxJQUFJN0IsS0FBSyxDQUFDNkIsSUFBSSxJQUFJUyxZQUFZLFlBQVlBLFlBQVksVUFBVTtvQkFDNUQsTUFBTVosZ0JBQWdCO3dCQUNsQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFPO29CQUNaO2dCQUNKO1lBQ0osT0FBTyxJQUFJVCxRQUFRLFVBQVU7Z0JBQ3pCLElBQUk3QixLQUFLLENBQUM2QixJQUFJLElBQUlTLFlBQVksVUFBVTtvQkFDcEMsTUFBTVosZ0JBQWdCO3dCQUNsQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFPO29CQUNaO2dCQUNKO1lBQ0osT0FBTyxJQUFJVCxRQUFRLGFBQWFBLFFBQVEsa0JBQWtCQSxRQUFRLGdCQUFnQjtnQkFDOUUsSUFBSTdCLEtBQUssQ0FBQzZCLElBQUksSUFBSVMsWUFBWSxZQUFZO29CQUN0QyxNQUFNWixnQkFBZ0I7d0JBQ2xCRzt3QkFDQUMsVUFBVTt3QkFDVkMsUUFBUU87b0JBQ1o7Z0JBQ0o7WUFDSixPQUFPLElBQUlULFFBQVEsYUFBYUEsUUFBUSxZQUFZQSxRQUFRLGFBQWFBLFFBQVEsY0FBY0EsUUFBUSxjQUFjQSxRQUFRLGtCQUFrQjtnQkFDM0ksSUFBSTdCLEtBQUssQ0FBQzZCLElBQUksSUFBSSxRQUFRUyxZQUFZLFdBQVc7b0JBQzdDLE1BQU1aLGdCQUFnQjt3QkFDbEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRTztvQkFDWjtnQkFDSjtZQUNKLE9BQU87Z0JBQ0gsc0NBQXNDO2dCQUN0Qyw2REFBNkQ7Z0JBQzdELE1BQU12RyxJQUFJOEY7WUFDZDtRQUNKO1FBQ0EsNEZBQTRGO1FBQzVGLHNEQUFzRDtRQUN0RCxNQUFNVSxZQUFZekcsT0FBTzBELE9BQU8sQ0FBQ2dELE1BQU0sQ0FBQztRQUN4QyxJQUFJeEMsTUFBTW5ELFFBQVEsSUFBSSxDQUFDMEYsVUFBVUUsT0FBTyxJQUFJLENBQUN0RixhQUFhO1lBQ3REb0YsVUFBVUUsT0FBTyxHQUFHO1lBQ3BCQyxRQUFRQyxJQUFJLENBQUM7UUFDakI7SUFDSjtJQUNBLElBQUkzRSxJQUFxQyxFQUFFO1FBQ3ZDLElBQUliLGVBQWUsQ0FBQ2lELFFBQVE7WUFDeEIsSUFBSXJEO1lBQ0osSUFBSSxPQUFPb0QsYUFBYSxVQUFVO2dCQUM5QnBELE9BQU9vRDtZQUNYLE9BQU8sSUFBSSxPQUFPQSxhQUFhLFlBQVksT0FBT0EsU0FBU3lDLFFBQVEsS0FBSyxVQUFVO2dCQUM5RTdGLE9BQU9vRCxTQUFTeUMsUUFBUTtZQUM1QjtZQUNBLElBQUk3RixNQUFNO2dCQUNOLE1BQU04RixvQkFBb0I5RixLQUFLK0YsS0FBSyxDQUFDLEtBQUtDLElBQUksQ0FBQyxDQUFDQyxVQUFVQSxRQUFRQyxVQUFVLENBQUMsUUFBUUQsUUFBUUUsUUFBUSxDQUFDO2dCQUN0RyxJQUFJTCxtQkFBbUI7b0JBQ25CLE1BQU0sSUFBSWpCLE1BQU0sbUJBQW1CN0UsT0FBTztnQkFDOUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxNQUFNLEVBQUVBLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdsQixPQUFPMEQsT0FBTyxDQUFDMkQsT0FBTyxDQUFDO1FBQ3hDLElBQUksQ0FBQ25DLGFBQWE7WUFDZCxNQUFNb0MsZUFBZTFELGtCQUFrQlM7WUFDdkMsT0FBTztnQkFDSHBELE1BQU1xRztnQkFDTnBHLElBQUlvRCxTQUFTVixrQkFBa0JVLFVBQVVnRDtZQUM3QztRQUNKO1FBQ0EsTUFBTSxDQUFDQSxjQUFjQyxXQUFXLEdBQUcsQ0FBQyxHQUFHckgsYUFBYXNILFdBQVcsRUFBRXRDLGFBQWFiLFVBQVU7UUFDeEYsT0FBTztZQUNIcEQsTUFBTXFHO1lBQ05wRyxJQUFJb0QsU0FBUyxDQUFDLEdBQUdwRSxhQUFhc0gsV0FBVyxFQUFFdEMsYUFBYVosVUFBVWlELGNBQWNEO1FBQ3BGO0lBQ0osR0FBRztRQUNDcEM7UUFDQWI7UUFDQUM7S0FDSDtJQUNELE1BQU1tRCxlQUFlekgsT0FBTzBELE9BQU8sQ0FBQ2dELE1BQU0sQ0FBQ3pGO0lBQzNDLE1BQU15RyxhQUFhMUgsT0FBTzBELE9BQU8sQ0FBQ2dELE1BQU0sQ0FBQ3hGO0lBQ3pDLG9GQUFvRjtJQUNwRixJQUFJeUc7SUFDSixJQUFJNUMsZ0JBQWdCO1FBQ2hCLElBQUk3QyxJQUFzQyxFQUFFO1lBQ3hDLElBQUl3QyxTQUFTO2dCQUNUa0MsUUFBUUMsSUFBSSxDQUFDLG9EQUFvRHhDLFdBQVc7WUFDaEY7WUFDQSxJQUFJTyxrQkFBa0I7Z0JBQ2xCZ0MsUUFBUUMsSUFBSSxDQUFDLHlEQUF5RHhDLFdBQVc7WUFDckY7WUFDQSxJQUFJO2dCQUNBc0QsUUFBUTNILE9BQU8wRCxPQUFPLENBQUNrRSxRQUFRLENBQUNDLElBQUksQ0FBQ3pEO1lBQ3pDLEVBQUUsT0FBT25DLEtBQUs7Z0JBQ1YsSUFBSSxDQUFDbUMsVUFBVTtvQkFDWCxNQUFNLElBQUkwQixNQUFNLHVEQUF1RHpCLFdBQVc7Z0JBQ3RGO2dCQUNBLE1BQU0sSUFBSXlCLE1BQU0sNkRBQTZEekIsV0FBVyw4RkFBK0YsTUFBNkIsR0FBRyxzRUFBc0UsQ0FBQztZQUNsUztRQUNKLE9BQU8sRUFFTjtJQUNMLE9BQU87UUFDSCxJQUFJbkMsSUFBc0MsRUFBRTtZQUN4QyxJQUFJLENBQUNrQyxZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTMEQsSUFBSSxNQUFNLEtBQUs7Z0JBQ3JELE1BQU0sSUFBSWhDLE1BQU07WUFDcEI7UUFDSjtJQUNKO0lBQ0EsTUFBTWlDLFdBQVdoRCxpQkFBaUI0QyxTQUFTLE9BQU9BLFVBQVUsWUFBWUEsTUFBTUssR0FBRyxHQUFHN0Q7SUFDcEYsTUFBTSxDQUFDOEQsb0JBQW9CQyxXQUFXQyxhQUFhLEdBQUcsQ0FBQyxHQUFHMUgsaUJBQWlCMkgsZUFBZSxFQUFFO1FBQ3hGQyxZQUFZO0lBQ2hCO0lBQ0EsTUFBTUMsU0FBU3RJLE9BQU8wRCxPQUFPLENBQUM2RSxXQUFXLENBQUMsQ0FBQ0M7UUFDdkMsNEVBQTRFO1FBQzVFLElBQUlkLFdBQVdmLE9BQU8sS0FBS3pGLE1BQU11RyxhQUFhZCxPQUFPLEtBQUsxRixNQUFNO1lBQzVEa0g7WUFDQVQsV0FBV2YsT0FBTyxHQUFHekY7WUFDckJ1RyxhQUFhZCxPQUFPLEdBQUcxRjtRQUMzQjtRQUNBZ0gsbUJBQW1CTztRQUNuQixJQUFJVCxVQUFVO1lBQ1YsSUFBSSxPQUFPQSxhQUFhLFlBQVlBLFNBQVNTO2lCQUN4QyxJQUFJLE9BQU9ULGFBQWEsVUFBVTtnQkFDbkNBLFNBQVNwQixPQUFPLEdBQUc2QjtZQUN2QjtRQUNKO0lBQ0osR0FBRztRQUNDdEg7UUFDQTZHO1FBQ0E5RztRQUNBa0g7UUFDQUY7S0FDSDtJQUNELDJEQUEyRDtJQUMzRGpJLE9BQU8wRCxPQUFPLENBQUMrRSxTQUFTLENBQUM7UUFDckIsZ0hBQWdIO1FBQ2hILElBQUl2RyxJQUFxQyxFQUFFO1lBQ3ZDO1FBQ0o7UUFDQSxJQUFJLENBQUNsQixRQUFRO1lBQ1Q7UUFDSjtRQUNBLDJEQUEyRDtRQUMzRCxJQUFJLENBQUNrSCxhQUFhLENBQUMzQyxpQkFBaUI7WUFDaEM7UUFDSjtRQUNBLG9CQUFvQjtRQUNwQnhFLFNBQVNDLFFBQVFDLE1BQU1DLElBQUk7WUFDdkJNO1FBQ0osR0FBRztZQUNDa0gsTUFBTWxEO1FBQ1YsR0FBR25FO0lBQ1AsR0FBRztRQUNDSDtRQUNBRDtRQUNBaUg7UUFDQTFHO1FBQ0ErRDtRQUNBTCxlQUFlLE9BQU8sS0FBSyxJQUFJQSxZQUFZMUQsTUFBTTtRQUNqRFI7UUFDQUs7UUFDQW1FO0tBQ0g7SUFDRCxNQUFNbUQsYUFBYTtRQUNmWCxLQUFLTTtRQUNMNUQsU0FBUzFCLENBQUM7WUFDTixJQUFJZCxJQUFxQyxFQUFFO2dCQUN2QyxJQUFJLENBQUNjLEdBQUc7b0JBQ0osTUFBTSxJQUFJOEMsTUFBTTtnQkFDcEI7WUFDSjtZQUNBLElBQUksQ0FBQ2Ysa0JBQWtCLE9BQU9MLFlBQVksWUFBWTtnQkFDbERBLFFBQVExQjtZQUNaO1lBQ0EsSUFBSStCLGtCQUFrQjRDLE1BQU16RCxLQUFLLElBQUksT0FBT3lELE1BQU16RCxLQUFLLENBQUNRLE9BQU8sS0FBSyxZQUFZO2dCQUM1RWlELE1BQU16RCxLQUFLLENBQUNRLE9BQU8sQ0FBQzFCO1lBQ3hCO1lBQ0EsSUFBSSxDQUFDaEMsUUFBUTtnQkFDVDtZQUNKO1lBQ0EsSUFBSWdDLEVBQUU0RixnQkFBZ0IsRUFBRTtnQkFDcEI7WUFDSjtZQUNBN0YsWUFBWUMsR0FBR2hDLFFBQVFDLE1BQU1DLElBQUkrQixTQUFTQyxTQUFTQyxRQUFRM0IsUUFBUUg7UUFDdkU7UUFDQXNELGNBQWMzQixDQUFDO1lBQ1gsSUFBSSxDQUFDK0Isa0JBQWtCLE9BQU9ILHFCQUFxQixZQUFZO2dCQUMzREEsaUJBQWlCNUI7WUFDckI7WUFDQSxJQUFJK0Isa0JBQWtCNEMsTUFBTXpELEtBQUssSUFBSSxPQUFPeUQsTUFBTXpELEtBQUssQ0FBQ1MsWUFBWSxLQUFLLFlBQVk7Z0JBQ2pGZ0QsTUFBTXpELEtBQUssQ0FBQ1MsWUFBWSxDQUFDM0I7WUFDN0I7WUFDQSxJQUFJLENBQUNoQyxRQUFRO2dCQUNUO1lBQ0o7WUFDQSxJQUFJLENBQUMsQ0FBQ3VFLG1CQUFtQnJELGtCQUF5QixhQUFZLEtBQU1iLGFBQWE7Z0JBQzdFO1lBQ0o7WUFDQU4sU0FBU0MsUUFBUUMsTUFBTUMsSUFBSTtnQkFDdkJNO2dCQUNBcUgsVUFBVTtnQkFDVixnR0FBZ0c7Z0JBQ2hHdEgsdUJBQXVCO1lBQzNCLEdBQUc7Z0JBQ0NtSCxNQUFNbEQ7WUFDVixHQUFHbkU7UUFDUDtRQUNBd0QsY0FBYzdCLENBQUM7WUFDWCxJQUFJLENBQUMrQixrQkFBa0IsT0FBT0QscUJBQXFCLFlBQVk7Z0JBQzNEQSxpQkFBaUI5QjtZQUNyQjtZQUNBLElBQUkrQixrQkFBa0I0QyxNQUFNekQsS0FBSyxJQUFJLE9BQU95RCxNQUFNekQsS0FBSyxDQUFDVyxZQUFZLEtBQUssWUFBWTtnQkFDakY4QyxNQUFNekQsS0FBSyxDQUFDVyxZQUFZLENBQUM3QjtZQUM3QjtZQUNBLElBQUksQ0FBQ2hDLFFBQVE7Z0JBQ1Q7WUFDSjtZQUNBLElBQUksQ0FBQ3VFLG1CQUFtQmxFLGFBQWE7Z0JBQ2pDO1lBQ0o7WUFDQU4sU0FBU0MsUUFBUUMsTUFBTUMsSUFBSTtnQkFDdkJNO2dCQUNBcUgsVUFBVTtnQkFDVixnR0FBZ0c7Z0JBQ2hHdEgsdUJBQXVCO1lBQzNCLEdBQUc7Z0JBQ0NtSCxNQUFNbEQ7WUFDVixHQUFHbkU7UUFDUDtJQUNKO0lBQ0EsNkZBQTZGO0lBQzdGLHdGQUF3RjtJQUN4RixvRkFBb0Y7SUFDcEYsSUFBSSxDQUFDLEdBQUdoQixPQUFPeUksYUFBYSxFQUFFNUgsS0FBSztRQUMvQnlILFdBQVcxSCxJQUFJLEdBQUdDO0lBQ3RCLE9BQU8sSUFBSSxDQUFDNkQsa0JBQWtCTixZQUFZa0QsTUFBTUcsSUFBSSxLQUFLLE9BQU8sQ0FBRSxXQUFVSCxNQUFNekQsS0FBSyxHQUFHO1FBQ3RGLE1BQU02RSxZQUFZLE9BQU92SCxXQUFXLGNBQWNBLFNBQVMwRCxlQUFlLE9BQU8sS0FBSyxJQUFJQSxZQUFZMUQsTUFBTTtRQUM1Ryx1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLE1BQU13SCxlQUFlLENBQUM5RCxlQUFlLE9BQU8sS0FBSyxJQUFJQSxZQUFZK0QsY0FBYyxLQUFLLENBQUMsR0FBR3ZJLGlCQUFpQndJLGVBQWUsRUFBRWhJLElBQUk2SCxXQUFXN0QsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWWlFLE9BQU8sRUFBRWpFLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVlrRSxhQUFhO1FBQ3JQVCxXQUFXMUgsSUFBSSxHQUFHK0gsZ0JBQWdCLENBQUMsR0FBR3JJLGFBQWEwSSxXQUFXLEVBQUUsQ0FBQyxHQUFHL0ksV0FBV2dKLFNBQVMsRUFBRXBJLElBQUk2SCxXQUFXN0QsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWXFFLGFBQWE7SUFDcks7SUFDQSxPQUFPeEUsaUJBQWlCLFdBQVcsR0FBRy9FLE9BQU8wRCxPQUFPLENBQUM4RixZQUFZLENBQUM3QixPQUFPZ0IsY0FBNEIsV0FBSCxHQUFJLElBQUc1SSxZQUFZa0YsR0FBRyxFQUFFLEtBQUs7UUFDM0gsR0FBR0QsU0FBUztRQUNaLEdBQUcyRCxVQUFVO1FBQ2J2RSxVQUFVQTtJQUNkO0FBQ0o7O0FBQ0EsTUFBTXhFLFdBQVdtRTtBQUVqQixJQUFJLENBQUMsT0FBT3ZFLFFBQVFrRSxPQUFPLEtBQUssY0FBZSxPQUFPbEUsUUFBUWtFLE9BQU8sS0FBSyxZQUFZbEUsUUFBUWtFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xFLFFBQVFrRSxPQUFPLENBQUMrRixVQUFVLEtBQUssYUFBYTtJQUNyS25LLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWtFLE9BQU8sRUFBRSxjQUFjO1FBQUVqRSxPQUFPO0lBQUs7SUFDbkVILE9BQU9vSyxNQUFNLENBQUNsSyxRQUFRa0UsT0FBTyxFQUFFbEU7SUFDL0JtSyxPQUFPbkssT0FBTyxHQUFHQSxRQUFRa0UsT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9hZGRsb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zLCBhcHBPcHRpb25zLCBpc0FwcFJvdXRlcikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKCFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGhyZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgZGVkdXBlIHJlcXVlc3RzIHdoZW4gZXhwZXJpbWVudGFsLm9wdGltaXN0aWNDbGllbnRDYWNoZSBpc1xuICAgIC8vIGRpc2FibGVkLlxuICAgIGlmICghb3B0aW9ucy5ieXBhc3NQcmVmZXRjaGVkQ2hlY2spIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gLy8gTGV0IHRoZSBsaW5rJ3MgbG9jYWxlIHByb3Agb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcm91dGVyIGxvY2FsZS5cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgOiBcImxvY2FsZVwiIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHByZWZldGNoZWRLZXkgPSBocmVmICsgXCIlXCIgKyBhcyArIFwiJVwiICsgbG9jYWxlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZldGNoZWQgdGhlIGtleSwgdGhlbiBkb24ndCBwcmVmZXRjaCBpdCBhZ2FpbiFcbiAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKHByZWZldGNoZWRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayB0aGlzIFVSTCBhcyBwcmVmZXRjaGVkLlxuICAgICAgICBwcmVmZXRjaGVkLmFkZChwcmVmZXRjaGVkS2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hQcm9taXNlID0gaXNBcHBSb3V0ZXIgPyByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXBwT3B0aW9ucykgOiByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgUHJvbWlzZS5yZXNvbHZlKHByZWZldGNoUHJvbWlzZSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSBcIl9zZWxmXCIgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyO1xufVxuZnVuY3Rpb24gbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gICAgY29uc3QgaXNBbmNob3JOb2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiQVwiO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBjb25zdCByb3V0ZXJTY3JvbGwgPSBzY3JvbGwgIT0gbnVsbCA/IHNjcm9sbCA6IHRydWU7XG4gICAgICAgIGlmIChcImJlZm9yZVBvcFN0YXRlXCIgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShhcyB8fCBocmVmLCB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRVcmwpKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wLCBhczogYXNQcm9wLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCwgcGFzc0hyZWYsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCwgbGVnYWN5QmVoYXZpb3IgPSBmYWxzZSwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY2hpbGRyZW4gPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImFcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHJvdXRlciA9IHBhZ2VzUm91dGVyICE9IG51bGwgPyBwYWdlc1JvdXRlciA6IGFwcFJvdXRlcjtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG4gICAgICogLSBudWxsOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIC0gdHJ1ZTogd2Ugd2lsbCBwcmVmZXRjaCBpZiB0aGUgbGluayBpcyB2aXNpYmxlIGFuZCBwcmVmZXRjaCB0aGUgZnVsbCBwYWdlLCBub3QganVzdCBwYXJ0aWFsbHlcbiAgICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG4gICAgICovIGNvbnN0IGFwcFByZWZldGNoS2luZCA9IHByZWZldGNoUHJvcCA9PT0gbnVsbCA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBgXCIgKyBhcmdzLmtleSArIFwiYCBleHBlY3RzIGEgXCIgKyBhcmdzLmV4cGVjdGVkICsgXCIgaW4gYDxMaW5rPmAsIGJ1dCBnb3QgYFwiICsgYXJncy5hY3R1YWwgKyBcImAgaW5zdGVhZC5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJocmVmXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wc1trZXldICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYCBvciBgb2JqZWN0YFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImFzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiICYmIHZhbFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibG9jYWxlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm9uQ2xpY2tcIiB8fCBrZXkgPT09IFwib25Nb3VzZUVudGVyXCIgfHwga2V5ID09PSBcIm9uVG91Y2hTdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgZnVuY3Rpb25gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmVwbGFjZVwiIHx8IGtleSA9PT0gXCJzY3JvbGxcIiB8fCBrZXkgPT09IFwic2hhbGxvd1wiIHx8IGtleSA9PT0gXCJwYXNzSHJlZlwiIHx8IGtleSA9PT0gXCJwcmVmZXRjaFwiIHx8IGtleSA9PT0gXCJsZWdhY3lCZWhhdmlvclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGJvb2xlYW5gXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQgJiYgIWlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG4gICAgICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaHJlZlByb3AucGF0aG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZi5zcGxpdChcIi9cIikuc29tZSgoc2VnbWVudCk9PnNlZ21lbnQuc3RhcnRzV2l0aChcIltcIikgJiYgc2VnbWVudC5lbmRzV2l0aChcIl1cIikpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIGhyZWYgYFwiICsgaHJlZiArIFwiYCBmb3VuZCBpbiA8TGluaz4gd2hpbGUgdXNpbmcgdGhlIGAvYXBwYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBocmVmLCBhcyB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBpZiAoIXBhZ2VzUm91dGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgICAgICBhczogYXNQcm9wID8gZm9ybWF0U3RyaW5nT3JVcmwoYXNQcm9wKSA6IHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocGFnZXNSb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcGFnZXNSb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGluaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlclByb3ApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYCcgKyBocmVmUHJvcCArICdgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlblwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbi50eXBlKSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlaW50ZXJzZWN0aW9uLnVzZUludGVyc2VjdGlvbikoe1xuICAgICAgICByb290TWFyZ2luOiBcIjIwMHB4XCJcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcbiAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcbiAgICAgICAgICAgIHJlc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XG4gICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcbiAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSBcImZ1bmN0aW9uXCIpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgbmVlZCB0byBwcmVmZXRjaCB0aGUgVVJMLCBkb24ndCBkbyBwcmVmZXRjaC5cbiAgICAgICAgaWYgKCFpc1Zpc2libGUgfHwgIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIHRoZSBVUkwuXG4gICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaXNBcHBSb3V0ZXIsXG4gICAgICAgIGFwcFByZWZldGNoS2luZFxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrIChlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09IFwiYVwiICYmICEoXCJocmVmXCIgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgICAuLi5jaGlsZFByb3BzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuY29uc3QgX2RlZmF1bHQgPSBMaW5rO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVzb2x2ZWhyZWYiLCJfaXNsb2NhbHVybCIsIl9mb3JtYXR1cmwiLCJfdXRpbHMiLCJfYWRkbG9jYWxlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX3VzZWludGVyc2VjdGlvbiIsIl9nZXRkb21haW5sb2NhbGUiLCJfYWRkYmFzZXBhdGgiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwicHJlZmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZXN0UHJvcHMiLCJqc3giLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImFwcFByZWZldGNoS2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwia2luZCIsImNoaWxkUHJvcHMiLCJkZWZhdWx0UHJldmVudGVkIiwicHJpb3JpdHkiLCJpc0Fic29sdXRlVXJsIiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUlBQXdDO0FBQ3JFLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxxSEFBaUM7QUFDdkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQyxpSEFBNEI7QUFDcEQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQyx5SUFBMkM7QUFDMUUsU0FBU0YsWUFBWVUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDeEMsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU8sQ0FBQyxHQUFHUixXQUFXWSxvQkFBb0IsRUFBRUo7SUFDekYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCxNQUFNSyxnQkFBZ0JGLFlBQVlHLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJGLGdCQUFnQkYsWUFBWUssS0FBSyxDQUFDSCxhQUFhLENBQUMsRUFBRSxDQUFDSSxNQUFNLElBQUlOO0lBQ3hGLE1BQU1PLFdBQVdILG1CQUFtQkksS0FBSyxDQUFDLEtBQUs7SUFDL0MsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUMsRUFBR0osS0FBSyxDQUFDLGNBQWM7UUFDeENNLFFBQVFDLEtBQUssQ0FBQyxtQkFBbUJWLGNBQWMsdUNBQXVDSixPQUFPZSxRQUFRLEdBQUc7UUFDeEcsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR3JCLE9BQU9zQix3QkFBd0IsRUFBRVQ7UUFDM0RKLGNBQWMsQ0FBQ0UsZ0JBQWdCQSxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUMsSUFBS1U7SUFDNUQ7SUFDQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDLENBQUMsR0FBR25CLFlBQVlxQixVQUFVLEVBQUVkLGNBQWM7UUFDM0MsT0FBT0YsWUFBWTtZQUNmRTtTQUNILEdBQUdBO0lBQ1I7SUFDQSxJQUFJO1FBQ0FELE9BQU8sSUFBSWdCLElBQUlmLFlBQVlnQixVQUFVLENBQUMsT0FBT3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPZSxRQUFRLEVBQUU7SUFDbEYsRUFBRSxPQUFPTyxHQUFHO1FBQ1Isa0RBQWtEO1FBQ2xEbkIsT0FBTyxJQUFJZ0IsSUFBSSxLQUFLO0lBQ3hCO0lBQ0EsSUFBSTtRQUNBLE1BQU1JLFdBQVcsSUFBSUosSUFBSWYsYUFBYUQ7UUFDdENvQixTQUFTUixRQUFRLEdBQUcsQ0FBQyxHQUFHbkIsd0JBQXdCNEIsMEJBQTBCLEVBQUVELFNBQVNSLFFBQVE7UUFDN0YsSUFBSVUsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQyxHQUFHM0IsUUFBUTRCLGNBQWMsRUFBRUgsU0FBU1IsUUFBUSxLQUFLUSxTQUFTSSxZQUFZLElBQUl6QixXQUFXO1lBQ3RGLE1BQU0wQixRQUFRLENBQUMsR0FBR3JDLGFBQWFzQyxzQkFBc0IsRUFBRU4sU0FBU0ksWUFBWTtZQUM1RSxNQUFNLEVBQUVHLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHaEMsZUFBZWlDLGFBQWEsRUFBRVQsU0FBU1IsUUFBUSxFQUFFUSxTQUFTUixRQUFRLEVBQUVhO1lBQ25HLElBQUlFLFFBQVE7Z0JBQ1JMLGlCQUFpQixDQUFDLEdBQUdoQyxXQUFXWSxvQkFBb0IsRUFBRTtvQkFDbERVLFVBQVVlO29CQUNWRyxNQUFNVixTQUFTVSxJQUFJO29CQUNuQkwsT0FBTyxDQUFDLEdBQUdsQyxNQUFNd0MsSUFBSSxFQUFFTixPQUFPRztnQkFDbEM7WUFDSjtRQUNKO1FBQ0Esb0VBQW9FO1FBQ3BFLE1BQU1JLGVBQWVaLFNBQVNhLE1BQU0sS0FBS2pDLEtBQUtpQyxNQUFNLEdBQUdiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUFJYSxTQUFTdEIsSUFBSTtRQUNsSCxPQUFPQyxZQUFZO1lBQ2ZpQztZQUNBVixrQkFBa0JVO1NBQ3JCLEdBQUdBO0lBQ1IsRUFBRSxPQUFPYixHQUFHO1FBQ1IsT0FBT3BCLFlBQVk7WUFDZkU7U0FDSCxHQUFHQTtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFtRCxPQUFPLEtBQUssY0FBZSxPQUFPbkQsUUFBUW1ELE9BQU8sS0FBSyxZQUFZbkQsUUFBUW1ELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25ELFFBQVFtRCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUQsT0FBTyxFQUFFLGNBQWM7UUFBRWxELE9BQU87SUFBSztJQUNuRUgsT0FBT3VELE1BQU0sQ0FBQ3JELFFBQVFtRCxPQUFPLEVBQUVuRDtJQUMvQnNELE9BQU90RCxPQUFPLEdBQUdBLFFBQVFtRCxPQUFPO0FBQ2xDLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcz8yZjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUhyZWZcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVIcmVmO1xuICAgIH1cbn0pO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfdXRpbHMxID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09IFwic3RyaW5nXCIgPyBocmVmIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnNsaWNlKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KFwiP1wiLCAxKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8IFwiXCIpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaHJlZiAnXCIgKyB1cmxBc1N0cmluZyArIFwiJyBwYXNzZWQgdG8gbmV4dC9yb3V0ZXIgaW4gcGFnZTogJ1wiICsgcm91dGVyLnBhdGhuYW1lICsgXCInLiBSZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWYuXCIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogXCJcIikgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKFwiI1wiKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsIFwiaHR0cDovL25cIik7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTChcIi9cIiwgXCJodHRwOi8vblwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gXCJcIjtcbiAgICAgICAgaWYgKCgwLCBfdXRpbHMxLmlzRHluYW1pY1JvdXRlKShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS1ocmVmLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXNvbHZlSHJlZiIsIl9xdWVyeXN0cmluZyIsInJlcXVpcmUiLCJfZm9ybWF0dXJsIiwiX29taXQiLCJfdXRpbHMiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIl9pc2xvY2FsdXJsIiwiX3V0aWxzMSIsIl9pbnRlcnBvbGF0ZWFzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJsZW5ndGgiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwicGF0aG5hbWUiLCJub3JtYWxpemVkVXJsIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwiaXNMb2NhbFVSTCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJhc1BhdGgiLCJfIiwiZmluYWxVcmwiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJyZXN1bHQiLCJwYXJhbXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXQiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7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LFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUM3RDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFDeEIsU0FBU0YsbUJBQW1CRyxHQUFHO0lBQzNCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEM7SUFDQSxPQUFPQztBQUNYLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlU3RyaW5nUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmdSZWdleHA7XG4gICAgfVxufSk7XG5jb25zdCByZUhhc1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dLztcbmNvbnN0IHJlUmVwbGFjZVJlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG4gICAgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy9lc2NhcGVSZWdFeHAuanMjTDIzXG4gICAgaWYgKHJlSGFzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUM1QjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1DLGVBQWUsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMEdBQWU7QUFDdEYsTUFBTUcsbUJBQW1CO0FBQ3pCLFNBQVNiLFVBQVVjLE1BQU07SUFDckIsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBTztJQUNYTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUNwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBTVIsV0FBVyxNQUFNQSxRQUFPO1FBQ3RFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNiSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDN0I7SUFDSjtJQUNBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZixhQUFhZ0Isc0JBQXNCLENBQUNQO0lBQ3ZEO0lBQ0EsSUFBSVEsU0FBU2QsT0FBT2MsTUFBTSxJQUFJUixTQUFTLE1BQU1BLFNBQVM7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsT0FBTztRQUNwRkEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQzFELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2RBLE9BQU87SUFDWDtJQUNBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFDaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFDN0IsT0FBTyxLQUFLTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUN0RDtBQUNBLE1BQU1sQixnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxxQkFBcUI4QixHQUFHO0lBQzdCLElBQUlDLElBQXNDLEVBQUU7UUFDeEMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUN6Q3JDLE9BQU91QyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxDQUFDQztnQkFDdEIsSUFBSSxDQUFDbkMsY0FBY29DLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDOUJFLFFBQVFDLElBQUksQ0FBQyx1REFBdURIO2dCQUN4RTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9wQyxVQUFVZ0M7QUFDckIsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0VXJsOiBudWxsLFxuICAgIHVybE9iamVjdEtleXM6IG51bGwsXG4gICAgZm9ybWF0V2l0aFZhbGlkYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFVybDtcbiAgICB9LFxuICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsT2JqZWN0S2V5cztcbiAgICB9LFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIikpO1xuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztcbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcbiAgICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCBcIlwiO1xuICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgXCJcIjtcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgXCJcIjtcbiAgICBsZXQgaG9zdCA9IGZhbHNlO1xuICAgIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCBcIjpcIikgKyBcIkBcIiA6IFwiXCI7XG4gICAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPyBcIltcIiArIGhvc3RuYW1lICsgXCJdXCIgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSBcIjpcIiArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBTdHJpbmcoX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgXCI/XCIgKyBxdWVyeSB8fCBcIlwiO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSBwcm90b2NvbCArPSBcIjpcIjtcbiAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICBob3N0ID0gXCIvL1wiICsgKGhvc3QgfHwgXCJcIik7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gXCIvXCIpIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gXCI/XCIpIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgICByZXR1cm4gXCJcIiArIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgXCJhdXRoXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBvcnRcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzbGFzaGVzXCJcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9xdWVyeXN0cmluZyIsIl8iLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGlCQUFpQjtRQUNiLE9BQU9RLGNBQWNSLGVBQWU7SUFDeEM7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT1EsV0FBV1IsY0FBYztJQUNwQztBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCRSxtQkFBT0EsQ0FBQyw4R0FBaUI7QUFDL0MsTUFBTUQsYUFBYUMsbUJBQU9BLENBQUMsd0dBQWMsR0FFekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFNvcnRlZFJvdXRlczogbnVsbCxcbiAgICBpc0R5bmFtaWNSb3V0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfSxcbiAgICBpc0R5bmFtaWNSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmUoXCIuL3NvcnRlZC1yb3V0ZXNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsOEdBQWlCO0FBQy9DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBHQUFlO0FBQzNDLFNBQVNGLGNBQWNJLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzNDLElBQUlDLG9CQUFvQjtJQUN4QixNQUFNQyxlQUFlLENBQUMsR0FBR0wsWUFBWU0sYUFBYSxFQUFFTDtJQUNwRCxNQUFNTSxnQkFBZ0JGLGFBQWFHLE1BQU07SUFDekMsTUFBTUMsaUJBQ04sQ0FBQ1AsZUFBZUQsUUFBUSxDQUFDLEdBQUdILGNBQWNZLGVBQWUsRUFBRUwsY0FBY0gsY0FBYyxFQUFDLEtBQU0sZ0RBQWdEO0lBQzlJLHNFQUFzRTtJQUN0RUM7SUFDQUMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTcEIsT0FBT3FCLElBQUksQ0FBQ0w7SUFDM0IsSUFBSSxDQUFDSSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7UUFDZixJQUFJcEIsUUFBUWUsY0FBYyxDQUFDSyxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHVCxhQUFhLENBQUNPLE1BQU07UUFDakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJRyxXQUFXLE1BQU9GLENBQUFBLFNBQVMsUUFBUSxFQUFDLElBQUtELFFBQVE7UUFDckQsSUFBSUUsVUFBVTtZQUNWQyxXQUFXLENBQUMsQ0FBQ3ZCLFFBQVEsTUFBTSxFQUFDLElBQUssTUFBTXVCLFdBQVc7UUFDdEQ7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ3pCLFFBQVFBLFFBQVE7WUFDekNBO1NBQ0g7UUFDRCxPQUFPLENBQUNzQixZQUFZRixTQUFTTCxjQUFhLEtBQU0sNkNBQTZDO1FBQzVGTCxDQUFBQSxvQkFBb0JBLGtCQUFrQmdCLE9BQU8sQ0FBQ0gsVUFBVUYsU0FBU3JCLE1BQU0yQixHQUFHLENBQzNFLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVVDLG1CQUFtQkQsVUFBVUUsSUFBSSxDQUFDLE9BQU9ELG1CQUFtQjdCLFdBQVcsR0FBRTtJQUN4RixJQUFJO1FBQ0FVLG9CQUFvQixHQUFHLG1DQUFtQzs7SUFFOUQsdUVBQXVFO0lBQ3ZFLGtEQUFrRDtJQUNsRDtJQUNBLE9BQU87UUFDSE87UUFDQWMsUUFBUXJCO0lBQ1o7QUFDSixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzP2QwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZUFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gXCJbXCIgKyAocmVwZWF0ID8gXCIuLi5cIiA6IFwiXCIpICsgcGFyYW0gKyBcIl1cIjtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbihcIi9cIikgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCBcIi9cIik7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLWFzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcnBvbGF0ZUFzIiwiX3JvdXRlbWF0Y2hlciIsInJlcXVpcmUiLCJfcm91dGVyZWdleCIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyx3SkFBdUQ7QUFDM0YscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0gsZUFBZUksS0FBSztJQUN6QixJQUFJLENBQUMsR0FBR0gsb0JBQW9CSSwwQkFBMEIsRUFBRUQsUUFBUTtRQUM1REEsUUFBUSxDQUFDLEdBQUdILG9CQUFvQkssbUNBQW1DLEVBQUVGLE9BQU9HLGdCQUFnQjtJQUNoRztJQUNBLE9BQU9KLFdBQVdLLElBQUksQ0FBQ0o7QUFDM0IsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzPzQ2ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R5bmFtaWNSb3V0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljUm91dGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICBpZiAoKDAsIF9pbnRlcmNlcHRpb25yb3V0ZXMuaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgpKHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9ICgwLCBfaW50ZXJjZXB0aW9ucm91dGVzLmV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uKShyb3V0ZSkuaW50ZXJjZXB0ZWRSb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzRHluYW1pY1JvdXRlIiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJURVNUX1JPVVRFIiwicm91dGUiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaW50ZXJjZXB0ZWRSb3V0ZSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxxRkFBYTtBQUNwQyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4R0FBa0M7QUFDL0QsU0FBU0YsV0FBV0ksR0FBRztJQUNuQixnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLENBQUMsR0FBR0gsT0FBT0ksYUFBYSxFQUFFRCxNQUFNLE9BQU87SUFDNUMsSUFBSTtRQUNBLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHTCxPQUFPTSxpQkFBaUI7UUFDbkQsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQixDQUFDLEdBQUdILGFBQWFRLFdBQVcsRUFBRUgsU0FBU0ksUUFBUTtJQUNoRyxFQUFFLE9BQU9DLEdBQUc7UUFDUixPQUFPO0lBQ1g7QUFDSixFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcz81ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbFVSTFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNMb2NhbFVSTDtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICghKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKSh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvY2FsLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNMb2NhbFVSTCIsIl91dGlscyIsInJlcXVpcmUiLCJfaGFzYmFzZXBhdGgiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0NBQXVDO0lBQ25DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxJQUFJO0lBQ3RCLE1BQU1DLFVBQVUsQ0FBQztJQUNqQlQsT0FBT1EsSUFBSSxDQUFDRCxRQUFRRyxPQUFPLENBQUMsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDSCxLQUFLSSxRQUFRLENBQUNELE1BQU07WUFDckJGLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFDOUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1gsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzP2ZiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbWl0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJvbWl0Iiwib2JqZWN0Iiwia2V5cyIsIm9taXR0ZWQiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTRix1QkFBdUJTLFlBQVk7SUFDeEMsTUFBTUMsUUFBUSxDQUFDO0lBQ2ZELGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYztRQUN6QixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHZDtRQUNqQixPQUFPLElBQUllLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNqQjtRQUNwQixPQUFPO1lBQ0hZLEtBQUssQ0FBQ0UsSUFBSSxHQUFHO2dCQUNURixLQUFLLENBQUNFLElBQUk7Z0JBQ1ZkO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNNLHVCQUF1QkMsS0FBSztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU2hCLHVCQUF1Qm1CLFFBQVE7SUFDcEMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQjNCLE9BQU80QixPQUFPLENBQUNILFVBQVVULE9BQU8sQ0FBQyxDQUFDTTtRQUM5QixJQUFJLENBQUNMLEtBQUtkLE1BQU0sR0FBR21CO1FBQ25CLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQVE7WUFDdEJBLE1BQU1hLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1QmxCO1FBQzNDO0lBQ0o7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNuQixPQUFPRSxNQUFNO0lBQ2xCLElBQUksSUFBSXVCLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsbUJBQW1CLElBQUlqQixNQUFNYyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQU87UUFDbEhELGdCQUFnQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ2hEO0lBQ0FELGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN0QkksTUFBTW1CLElBQUksQ0FBQ3ZCLGFBQWF3QixJQUFJLElBQUl0QixPQUFPLENBQUMsQ0FBQ0MsTUFBTVIsT0FBTzhCLE1BQU0sQ0FBQ3RCO1FBQzdESCxhQUFhRSxPQUFPLENBQUMsQ0FBQ2IsT0FBT2MsTUFBTVIsT0FBT3FCLE1BQU0sQ0FBQ2IsS0FBS2Q7SUFDMUQ7SUFDQSxPQUFPTTtBQUNYLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanM/MDE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IG51bGwsXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogbnVsbCxcbiAgICBhc3NpZ246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuICAgIH0sXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zO1xuICAgIH0sXG4gICAgYXNzaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlYXJjaFBhcmFtc0xpc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHNlYXJjaFBhcmFtc0xpc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcyk9PntcbiAgICAgICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpPT50YXJnZXQuZGVsZXRlKGtleSkpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMscUZBQWE7QUFDcEMsU0FBU0YsZ0JBQWdCRyxLQUFLO0lBQzFCLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFDckIsT0FBTyxDQUFDRztRQUNKLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTztRQUNYO1FBQ0EsTUFBTUUsU0FBUyxDQUFDTjtZQUNaLElBQUk7Z0JBQ0EsT0FBT08sbUJBQW1CUDtZQUM5QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1IsTUFBTSxJQUFJVixPQUFPVyxXQUFXLENBQUM7WUFDakM7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQm5CLE9BQU9vQixJQUFJLENBQUNULFFBQVFVLE9BQU8sQ0FBQyxDQUFDQztZQUN6QixNQUFNQyxJQUFJWixNQUFNLENBQUNXLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVgsVUFBVSxDQUFDVSxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDakJQLE1BQU0sQ0FBQ0csU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUFPSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLFFBQVFmLE9BQU9lLFVBQVVQLEVBQUVRLE1BQU0sR0FBRztvQkFDdkZoQixPQUFPUztpQkFDVixHQUFHVCxPQUFPUztZQUNmO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb3V0ZU1hdGNoZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlTWF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuICAgIGxldCB7IHJlLCBncm91cHMgfSA9IHBhcmFtO1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKFwiZmFpbGVkIHRvIGRlY29kZSBwYXJhbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZihcIi9cIikgPyBtLnNwbGl0KFwiL1wiKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0Um91dGVNYXRjaGVyIiwiX3V0aWxzIiwicmVxdWlyZSIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxzQkFBc0JDLG1CQUFPQSxDQUFDLHdKQUF1RDtBQUMzRixNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFHQUFxQjtBQUNuRCxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUM5RCxNQUFNRywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBQ3hDOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxlQUFlQyxLQUFLO0lBQzdCLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNWRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBTztRQUNIRSxLQUFLTjtRQUNMSztRQUNBSjtJQUNKO0FBQ0o7QUFDQSxTQUFTTSxxQkFBcUJDLEtBQUs7SUFD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LE9BQU87Z0JBQ0gsT0FBTyxNQUFNLENBQUMsR0FBRzVELGNBQWM2QixrQkFBa0IsRUFBRVI7WUFDdkQ7UUFDSixHQUFHUyxJQUFJLENBQUM7UUFDUmU7SUFDSjtBQUNKO0FBQ0EsU0FBU3ZELG1CQUFtQnlDLGVBQWUsRUFBRThCLGNBQWM7SUFDdkQsTUFBTUMsU0FBU1IsMEJBQTBCdkIsaUJBQWlCOEI7SUFDMUQsT0FBTztRQUNILEdBQUd4RSxjQUFjMEMsZ0JBQWdCO1FBQ2pDZ0MsWUFBWSxNQUFNRCxPQUFPTix1QkFBdUIsR0FBRztRQUNuRFgsV0FBV2lCLE9BQU9qQixTQUFTO0lBQy9CO0FBQ0o7QUFDQSxTQUFTdEQsd0JBQXdCd0MsZUFBZSxFQUFFaUMsT0FBTztJQUNyRCxNQUFNLEVBQUU3QyxrQkFBa0IsRUFBRSxHQUFHUCxxQkFBcUJtQjtJQUNwRCxNQUFNLEVBQUVrQyxXQUFXLElBQUksRUFBRSxHQUFHRDtJQUM1QixJQUFJN0MsdUJBQXVCLEtBQUs7UUFDNUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDSEYsWUFBWSxPQUFPRyxnQkFBZ0I7UUFDdkM7SUFDSjtJQUNBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQTBCdkIsaUJBQWlCO0lBQy9FLElBQUlvQyx1QkFBdUJGLFdBQVcsZUFBZTtJQUNyRCxPQUFPO1FBQ0hGLFlBQVksTUFBTVAsMEJBQTBCVyx1QkFBdUI7SUFDdkU7QUFDSixFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBudWxsLFxuICAgIGdldE5hbWVkUm91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlUmVnZXg7XG4gICAgfSxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuY29uc3QgX2VzY2FwZXJlZ2V4cCA9IHJlcXVpcmUoXCIuLi8uLi9lc2NhcGUtcmVnZXhwXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9IFwibnh0UFwiO1xuY29uc3QgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA9IFwibnh0SVwiO1xuLyoqXG4gKiBQYXJzZXMgYSBnaXZlbiBwYXJhbWV0ZXIgZnJvbSBhIHJvdXRlIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gZ2VuZXJhdGUgdGhlIHBhcmFtZXRyaXplZCByb3V0ZS4gRXhhbXBsZXM6XG4gKiAgIC0gYFsuLi5zbHVnXWAgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgLi4uc2x1Z2AgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IGZhbHNlIH1gXG4gKiAgIC0gYFtmb29dYCAtPiBgeyBrZXk6ICdmb28nLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGBiYXJgIC0+IGB7IGtleTogJ2JhcicsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICovIGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKFwiW1wiKSAmJiBwYXJhbS5lbmRzV2l0aChcIl1cIik7XG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKFwiLi4uXCIpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWF0Y2ggPSBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG1hcmtlck1hdGNoICYmIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShtYXJrZXJNYXRjaCkgKyBcIihbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXBlYXQsIG9wdGlvbmFsIH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gXCIoPzovKC4rPykpP1wiIDogXCIvKC4rPylcIiA6IFwiLyhbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGdyb3Vwc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlLCBncm91cHMgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmU6IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIiksXG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsXG4gKiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqLyBmdW5jdGlvbiBidWlsZEdldFNhZmVSb3V0ZUtleSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGxldCByb3V0ZUtleSA9IFwiXCI7XG4gICAgICAgIGxldCBqID0gKytpO1xuICAgICAgICB3aGlsZShqID4gMCl7XG4gICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGogLSAxKSAlIDI2KTtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKChqIC0gMSkgLyAyNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlS2V5O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQocGFyYW0pIHtcbiAgICBsZXQgeyBpbnRlcmNlcHRpb25NYXJrZXIsIGdldFNhZmVSb3V0ZUtleSwgc2VnbWVudCwgcm91dGVLZXlzLCBrZXlQcmVmaXggfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50KTtcbiAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csIFwiXCIpO1xuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IFwiXCIgKyBrZXlQcmVmaXggKyBjbGVhbmVkS2V5O1xuICAgIH1cbiAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgIC8vIHNhZmUga2V5XG4gICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgfVxuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0gXCJcIiArIGtleVByZWZpeCArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWdtZW50IGhhcyBhbiBpbnRlcmNlcHRpb24gbWFya2VyLCBtYWtlIHN1cmUgdGhhdCdzIHBhcnQgb2YgdGhlIHJlZ2V4IHBhdHRlcm5cbiAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByb3V0ZSB3aXRoIHRoZSBpbnRlcmNlcHRpb24gbWFya2VyIGRvZXNuJ3QgaW5jb3JyZWN0bHkgbWF0Y2hcbiAgICAvLyB0aGUgbm9uLWludGVyY2VwdGVkIHJvdXRlIChpZSAvYXBwLyguKVt1c2VybmFtZV0gc2hvdWxkIG5vdCBtYXRjaCAvYXBwL1t1c2VybmFtZV0pXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uUHJlZml4ID0gaW50ZXJjZXB0aW9uTWFya2VyID8gKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShpbnRlcmNlcHRpb25NYXJrZXIpIDogXCJcIjtcbiAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KSk/XCIgOiBcIi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPlteL10rPylcIjtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUocm91dGUsIHByZWZpeFJvdXRlS2V5cykge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzSW50ZXJjZXB0aW9uTWFya2VyID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25NYXJrZXIgJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZWRNYXJrZXJdID0gc2VnbWVudC5zcGxpdChwYXJhbU1hdGNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBnZXRTYWZlUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGludGVyY2VwdGlvbk1hcmtlcjogdXNlZE1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICByb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSxcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyByZXN1bHQubmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIixcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIGNvbnN0IHsgY2F0Y2hBbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmIChwYXJhbWV0ZXJpemVkUm91dGUgPT09IFwiL1wiKSB7XG4gICAgICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIi4qXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZWRSZWdleDogXCJeL1wiICsgY2F0Y2hBbGxSZWdleCArIFwiJFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBmYWxzZSk7XG4gICAgbGV0IGNhdGNoQWxsR3JvdXBlZFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIig/OigvLiopPylcIiA6IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIGNhdGNoQWxsR3JvdXBlZFJlZ2V4ICsgXCIkXCJcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWdleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJnZXRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwicmVxdWlyZSIsIl9lc2NhcGVyZWdleHAiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUM7SUFDRkMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDQyxPQUFPLENBQUNELFFBQVFFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFVBQVUsRUFBRSxFQUFFO0lBQ3pEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxRQUFRQyxNQUFNLEVBQUU7UUFDWixJQUFJQSxXQUFXLEtBQUssR0FBR0EsU0FBUztRQUNoQyxNQUFNQyxnQkFBZ0I7ZUFDZixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUN4QixDQUFDQyxJQUFJO1FBQ04sSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQ3hCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzVCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3pEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0Q7UUFDQSxNQUFNRyxTQUFTVCxjQUFjVSxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxJQUFJLENBQUNWLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDdUIsR0FBR2IsT0FBTyxDQUFDLEtBQUtDLFNBQVNZLElBQUksTUFBTUMsTUFBTSxDQUFD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RkFBaUY7UUFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ29DLEdBQUcsQ0FBQ1osY0FBYztZQUNqQyxJQUFJLENBQUN4QixRQUFRLENBQUNxQyxHQUFHLENBQUNiLGFBQWEsSUFBSW5DO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDVyxRQUFRLENBQUNiLEdBQUcsQ0FBQ3FDLGFBQWFoQyxPQUFPLENBQUM0QixTQUFTSCxLQUFLLENBQUMsSUFBSUksV0FBV0M7SUFDekU7SUFDQWdCLGFBQWE7UUFDVCxJQUFJLENBQUN2QixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDZixRQUFRLEdBQUcsSUFBSXVDO1FBQ3BCLElBQUksQ0FBQ3BDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0FBQ0o7QUFDQSxTQUFTbkIsZ0JBQWdCb0QsZUFBZTtJQUNwQyxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLG9DQUFvQztJQUNwQyw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdIQUFnSDtJQUNoSCw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBTyxJQUFJcEQ7SUFDakIsNkZBQTZGO0lBQzdGbUQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQ1MsV0FBV0QsS0FBS25ELE1BQU0sQ0FBQ29EO0lBQ2hELDRHQUE0RztJQUM1RyxPQUFPRCxLQUFLN0MsTUFBTTtBQUN0QixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U29ydGVkUm91dGVzO1xuICAgIH1cbn0pO1xuY2xhc3MgVXJsTm9kZSB7XG4gICAgaW5zZXJ0KHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHVybFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKSwgW10sIGZhbHNlKTtcbiAgICB9XG4gICAgc21vb3NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3NoKCk7XG4gICAgfVxuICAgIF9zbW9vc2gocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgcHJlZml4ID0gXCIvXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aHMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY2hpbGRyZW5QYXRocy5tYXAoKGMpPT50aGlzLmNoaWxkcmVuLmdldChjKS5fc21vb3NoKFwiXCIgKyBwcmVmaXggKyBjICsgXCIvXCIpKS5yZWR1Y2UoKHByZXYsIGN1cnIpPT5bXG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5jdXJyXG4gICAgICAgICAgICBdLCBbXSk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltdXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbXCIgKyB0aGlzLnNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSBcIi9cIiA/IFwiL1wiIDogcHJlZml4LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiWy4uLl1cIikuX3Ntb29zaChwcmVmaXggKyBcIlsuLi5cIiArIHRoaXMucmVzdFNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiW1suLi5dXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyBcIl1dL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG4gICAgICAgIGlmICh1cmxQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIG5leHRTZWdtZW50LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgbGV0IHNlZ21lbnROYW1lID0gbmV4dFNlZ21lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgbGV0IGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBvcHRpb25hbCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgICAgICBpc0NhdGNoQWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgd2l0aCBlcnJvbmVvdXMgcGVyaW9kcyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNsdWcocHJldmlvdXNTbHVnLCBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjb2xsaXNpb25zIGxpa2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1twb3N0XS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgY3VycmVudGx5IG11bHRpcGxlIGR5bmFtaWMgcGFyYW1zIG9uIHRoZSBzYW1lIHNlZ21lbnQgbGV2ZWwgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgZGlmZmVyZW50IHNsdWcgbmFtZXMgZm9yIHRoZSBzYW1lIGR5bmFtaWMgcGF0aCAoJ1wiICsgcHJldmlvdXNTbHVnICsgXCInICE9PSAnXCIgKyBuZXh0U2x1ZyArIFwiJykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5mb3JFYWNoKChzbHVnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1ZyA9PT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbHVnLnJlcGxhY2UoL1xcVy9nLCBcIlwiKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4nICsgdGhpcy5yZXN0U2x1Z05hbWUgKyAnXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIiApLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW1suLi5dXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbWy4uLl1dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4nICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArICddXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFsuLi5dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIlsuLi5dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5zbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICB0aGlzLnNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW10gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzKG5leHRTZWdtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQobmV4dFNlZ21lbnQsIG5ldyBVcmxOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZ2V0KG5leHRTZWdtZW50KS5faW5zZXJ0KHVybFBhdGhzLnNsaWNlKDEpLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U29ydGVkUm91dGVzKG5vcm1hbGl6ZWRQYWdlcykge1xuICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcbiAgICAvLyBFZyB5b3UgY2FuJ3QgaGF2ZSBwYWdlcy9bcG9zdF0vYWJjLmpzIGFuZCBwYWdlcy9baGVsbG9dL3NvbWV0aGluZy1lbHNlLmpzXG4gICAgLy8gT25seSAxIGR5bmFtaWMgc2VnbWVudCBwZXIgbmVzdGluZyBsZXZlbFxuICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcbiAgICAvLyBwYWdlcy9bcG9zdF0vY29tbWVudHMuanNcbiAgICAvLyBwYWdlcy9ibG9nL1twb3N0XS9jb21tZW50L1tpZF0uanNcbiAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGlzIGNhc2UgYFVybE5vZGVgIGNyZWF0ZWQgaGVyZSBoYXMgYHRoaXMuc2x1Z05hbWUgPT09ICdwb3N0J2BcbiAgICAvLyBBbmQgc2luY2UgeW91ciBQUiBwYXNzZWQgdGhyb3VnaCBgc2x1Z05hbWVgIGFzIGFuIGFycmF5IGJhc2ljYWxseSBpdCdkIGluY2x1ZGluZyBpdCBpbiB0b28gbWFueSBwb3NzaWJpbGl0aWVzXG4gICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgVXJsTm9kZSgpO1xuICAgIC8vIEhlcmUgdGhlIGByb290YCBnZXRzIGluamVjdGVkIG11bHRpcGxlIHBhdGhzLCBhbmQgaW5zZXJ0IHdpbGwgYnJlYWsgdGhlbSB1cCBpbnRvIHN1YmxldmVsc1xuICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG4gICAgLy8gU21vb3NoIHdpbGwgdGhlbiBzb3J0IHRob3NlIHN1YmxldmVscyB1cCB0byB0aGUgcG9pbnQgd2hlcmUgeW91IGdldCB0aGUgY29ycmVjdCByb3V0ZSBkZWZpbml0aW9uIHByaW9yaXR5XG4gICAgcmV0dXJuIHJvb3Quc21vb3NoKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlZC1yb3V0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQWtCTjtBQUNBLFNBQVNrQixRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJeEIsT0FBT0MsY0FBYyxDQUFDc0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRcEIsU0FBUztJQUNiRyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWhCLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFNBQVNzQixFQUFFO0lBQ2hCLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUNKLE9BQU87UUFDSCxJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87WUFDbkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFDQSxJQUFJLENBQUNQLE1BQU07WUFDUEEsT0FBTztZQUNQQyxTQUFTRixNQUFNTTtRQUNuQjtRQUNBLE9BQU9KO0lBQ1g7QUFDSjtBQUNBLDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUsTUFBTU8scUJBQXFCO0FBQzNCLE1BQU05QixnQkFBZ0IsQ0FBQytCLE1BQU1ELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUNyRCxTQUFTOUI7SUFDTCxNQUFNLEVBQUVnQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFLEdBQUdDLE9BQU9DLFFBQVE7SUFDcEQsT0FBT0osV0FBVyxPQUFPQyxXQUFZQyxDQUFBQSxPQUFPLE1BQU1BLE9BQU8sRUFBQztBQUM5RDtBQUNBLFNBQVNqQztJQUNMLE1BQU0sRUFBRW9DLElBQUksRUFBRSxHQUFHRixPQUFPQyxRQUFRO0lBQ2hDLE1BQU1FLFNBQVN0QztJQUNmLE9BQU9xQyxLQUFLRSxTQUFTLENBQUNELE9BQU9iLE1BQU07QUFDdkM7QUFDQSxTQUFTdkIsZUFBZXNDLFNBQVM7SUFDN0IsT0FBTyxPQUFPQSxjQUFjLFdBQVdBLFlBQVlBLFVBQVVDLFdBQVcsSUFBSUQsVUFBVXZCLElBQUksSUFBSTtBQUNsRztBQUNBLFNBQVNkLFVBQVV1QyxHQUFHO0lBQ2xCLE9BQU9BLElBQUlDLFFBQVEsSUFBSUQsSUFBSUUsV0FBVztBQUMxQztBQUNBLFNBQVN4Qyx5QkFBeUIwQixHQUFHO0lBQ2pDLE1BQU1lLFdBQVdmLElBQUlnQixLQUFLLENBQUM7SUFDM0IsTUFBTUMsYUFBYUYsUUFBUSxDQUFDLEVBQUU7SUFDOUIsT0FBT0UsV0FBVSw0REFBNEQ7SUFDN0UsMENBQTBDO0tBQ3pDQyxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsVUFBVSxPQUFRSCxDQUFBQSxRQUFRLENBQUMsRUFBRSxHQUFHLE1BQU1BLFNBQVNJLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsT0FBTyxFQUFDO0FBQ3RHO0FBQ0EsZUFBZTdDLG9CQUFvQjhDLEdBQUcsRUFBRUMsR0FBRztJQUN2QyxJQUFJQyxJQUFxQyxFQUFFO1FBQ3ZDLElBQUlDO1FBQ0osSUFBSSxDQUFDQSxpQkFBaUJILElBQUlJLFNBQVMsS0FBSyxPQUFPLEtBQUssSUFBSUQsZUFBZUUsZUFBZSxFQUFFO1lBQ3BGLE1BQU1DLFVBQVUsTUFBTXZELGVBQWVpRCxPQUFPO1lBQzVDLE1BQU0sSUFBSU8sTUFBTUQ7UUFDcEI7SUFDSjtJQUNBLGlEQUFpRDtJQUNqRCxNQUFNZixNQUFNVSxJQUFJVixHQUFHLElBQUlVLElBQUlBLEdBQUcsSUFBSUEsSUFBSUEsR0FBRyxDQUFDVixHQUFHO0lBQzdDLElBQUksQ0FBQ1MsSUFBSUssZUFBZSxFQUFFO1FBQ3RCLElBQUlKLElBQUlBLEdBQUcsSUFBSUEsSUFBSVosU0FBUyxFQUFFO1lBQzFCLCtCQUErQjtZQUMvQixPQUFPO2dCQUNIbUIsV0FBVyxNQUFNdEQsb0JBQW9CK0MsSUFBSVosU0FBUyxFQUFFWSxJQUFJQSxHQUFHO1lBQy9EO1FBQ0o7UUFDQSxPQUFPLENBQUM7SUFDWjtJQUNBLE1BQU1RLFFBQVEsTUFBTVQsSUFBSUssZUFBZSxDQUFDSjtJQUN4QyxJQUFJVixPQUFPdkMsVUFBVXVDLE1BQU07UUFDdkIsT0FBT2tCO0lBQ1g7SUFDQSxJQUFJLENBQUNBLE9BQU87UUFDUixNQUFNSCxVQUFVLE1BQU12RCxlQUFlaUQsT0FBTyxpRUFBaUVTLFFBQVE7UUFDckgsTUFBTSxJQUFJRixNQUFNRDtJQUNwQjtJQUNBLElBQUlKLElBQXFDLEVBQUU7UUFDdkMsSUFBSTdELE9BQU9xRSxJQUFJLENBQUNELE9BQU9uQyxNQUFNLEtBQUssS0FBSyxDQUFDMkIsSUFBSUEsR0FBRyxFQUFFO1lBQzdDVSxRQUFRQyxJQUFJLENBQUMsS0FBSzdELGVBQWVpRCxPQUFPO1FBQzVDO0lBQ0o7SUFDQSxPQUFPUztBQUNYO0FBQ0EsTUFBTXRELEtBQUssT0FBTzBELGdCQUFnQjtBQUNsQyxNQUFNekQsS0FBS0QsTUFBTTtJQUNiO0lBQ0E7SUFDQTtDQUNILENBQUMyRCxLQUFLLENBQUMsQ0FBQ0MsU0FBUyxPQUFPRixXQUFXLENBQUNFLE9BQU8sS0FBSztBQUNqRCxNQUFNMUQsb0JBQW9Ca0Q7QUFDMUI7QUFDQSxNQUFNakQsdUJBQXVCaUQ7QUFDN0I7QUFDQSxNQUFNaEQsMEJBQTBCZ0Q7SUFDNUJTLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3BELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dDLE9BQU8sR0FBRyxrQ0FBa0NXO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNekQsMEJBQTBCK0M7SUFDNUJTLFlBQVlDLElBQUksRUFBRVgsT0FBTyxDQUFDO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRywwQ0FBMENXLE9BQU8sTUFBTVg7SUFDMUU7QUFDSjtBQUNBLE1BQU03QyxnQ0FBZ0M4QztJQUNsQ1MsYUFBYTtRQUNULEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1osT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxTQUFTNUMsZUFBZXlELEtBQUs7SUFDekIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQ2xCZixTQUFTYSxNQUFNYixPQUFPO1FBQ3RCZ0IsT0FBT0gsTUFBTUcsS0FBSztJQUN0QjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV0VCX1ZJVEFMUzogbnVsbCxcbiAgICBleGVjT25jZTogbnVsbCxcbiAgICBpc0Fic29sdXRlVXJsOiBudWxsLFxuICAgIGdldExvY2F0aW9uT3JpZ2luOiBudWxsLFxuICAgIGdldFVSTDogbnVsbCxcbiAgICBnZXREaXNwbGF5TmFtZTogbnVsbCxcbiAgICBpc1Jlc1NlbnQ6IG51bGwsXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBudWxsLFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IG51bGwsXG4gICAgU1A6IG51bGwsXG4gICAgU1Q6IG51bGwsXG4gICAgRGVjb2RlRXJyb3I6IG51bGwsXG4gICAgTm9ybWFsaXplRXJyb3I6IG51bGwsXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgTWlzc2luZ1N0YXRpY1BhZ2U6IG51bGwsXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgc3RyaW5naWZ5RXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgV0VCX1ZJVEFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuICAgIH0sXG4gICAgZXhlY09uY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhlY09uY2U7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcbiAgICB9LFxuICAgIGdldFVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRVUkw7XG4gICAgfSxcbiAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIGlzUmVzU2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG4gICAgfSxcbiAgICBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuICAgIH0sXG4gICAgbG9hZEdldEluaXRpYWxQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuICAgIH0sXG4gICAgU1A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1A7XG4gICAgfSxcbiAgICBTVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVDtcbiAgICB9LFxuICAgIERlY29kZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuICAgIH0sXG4gICAgTm9ybWFsaXplRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG4gICAgfSxcbiAgICBQYWdlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcbiAgICB9LFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuICAgIH0sXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBzdHJpbmdpZnlFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgXCJDTFNcIixcbiAgICBcIkZDUFwiLFxuICAgIFwiRklEXCIsXG4gICAgXCJJTlBcIixcbiAgICBcIkxDUFwiLFxuICAgIFwiVFRGQlwiXG5dO1xuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5jb25zdCBpc0Fic29sdXRlVXJsID0gKHVybCk9PkFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF07XG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIikgKyAodXJsUGFydHNbMV0gPyBcIj9cIiArIHVybFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI/XCIpIDogXCJcIik7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YXIgX0FwcF9wcm90b3R5cGU7XG4gICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpO1xuICAgIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyBnZXREaXNwbGF5TmFtZShBcHApICsgXCIgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gYGdldEluaXRpYWxQcm9wc2AuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFNUID0gU1AgJiYgW1xuICAgIFwibWFya1wiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogXCIgKyBwYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiBcIiArIHBhZ2UgKyBcIiBcIiArIG1lc3NhZ2U7XG4gICAgfVxufVxuY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJpc0Fic29sdXRlVXJsIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTUCIsIlNUIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsInN0cmluZ2lmeUVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiX0FwcF9wcm90b3R5cGUiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/(auth)/AuthSessionStatus.js":
/*!*********************************************!*\
  !*** ./src/app/(auth)/AuthSessionStatus.js ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst AuthSessionStatus = (param)=>{\n    let { status, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: status && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"\".concat(className, \" font-medium text-sm text-green-600\"),\n            ...props,\n            children: status\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\(auth)\\\\AuthSessionStatus.js\",\n            lineNumber: 4,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false);\n};\n_c = AuthSessionStatus;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AuthSessionStatus);\nvar _c;\n$RefreshReg$(_c, \"AuthSessionStatus\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGF1dGgpL0F1dGhTZXNzaW9uU3RhdHVzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLE1BQU1BLG9CQUFvQjtRQUFDLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87eUJBQ3REO2tCQUNLRix3QkFDRyw4REFBQ0c7WUFDR0YsV0FBVyxHQUFhLE9BQVZBLFdBQVU7WUFDdkIsR0FBR0MsS0FBSztzQkFDUkY7Ozs7Ozs7O0tBTlhEO0FBWU4sK0RBQWVBLGlCQUFpQkEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwLyhhdXRoKS9BdXRoU2Vzc2lvblN0YXR1cy5qcz8wNGE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEF1dGhTZXNzaW9uU3RhdHVzID0gKHsgc3RhdHVzLCBjbGFzc05hbWUsIC4uLnByb3BzIH0pID0+IChcbiAgICA8PlxuICAgICAgICB7c3RhdHVzICYmIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2NsYXNzTmFtZX0gZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMGB9XG4gICAgICAgICAgICAgICAgey4uLnByb3BzfT5cbiAgICAgICAgICAgICAgICB7c3RhdHVzfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgPC8+XG4pXG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhTZXNzaW9uU3RhdHVzXG4iXSwibmFtZXMiOlsiQXV0aFNlc3Npb25TdGF0dXMiLCJzdGF0dXMiLCJjbGFzc05hbWUiLCJwcm9wcyIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(auth)/AuthSessionStatus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/matching/Loading.js":
/*!*************************************!*\
  !*** ./src/app/matching/Loading.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Loading = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-center bg-gray-100 rounded-full\",\n        children: \"Loading...\"\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\Loading.js\",\n        lineNumber: 3,\n        columnNumber: 9\n    }, undefined);\n};\n_c = Loading;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loading);\nvar _c;\n$RefreshReg$(_c, \"Loading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0Y2hpbmcvTG9hZGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxNQUFNQSxVQUFVO0lBQ1oscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7a0JBQTREOzs7Ozs7QUFJbkY7S0FOTUY7QUFRTiwrREFBZUEsT0FBT0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL21hdGNoaW5nL0xvYWRpbmcuanM/MWUxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2FkaW5nID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctZ3JheS0xMDAgcm91bmRlZC1mdWxsXCI+XG4gICAgICAgICAgICBMb2FkaW5nLi4uXG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9hZGluZ1xuIl0sIm5hbWVzIjpbIkxvYWRpbmciLCJkaXYiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matching/Loading.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/matching/Navigation.js":
/*!****************************************!*\
  !*** ./src/app/matching/Navigation.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_tinder_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../styles/tinder.css */ \"(app-pages-browser)/./src/styles/tinder.css\");\n/* harmony import */ var _src_hooks_avatar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/hooks/avatar */ \"(app-pages-browser)/./src/hooks/avatar.js\");\n/* harmony import */ var _users_page__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../users/page */ \"(app-pages-browser)/./src/app/users/page.js\");\n/* harmony import */ var _styles_dashboard_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../styles/dashboard.css */ \"(app-pages-browser)/./src/styles/dashboard.css\");\n/* harmony import */ var _app_matching_Loading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../app/matching/Loading */ \"(app-pages-browser)/./src/app/matching/Loading.js\");\n\n\n\n // Import tệp CSS\n\n\n\n\n// Define the Header component\nconst Navigation = (param)=>{\n    let { id } = param;\n    const { first_image_path } = (0,_src_hooks_avatar__WEBPACK_IMPORTED_MODULE_4__.userAvatar)({\n        middleware: \"auth\",\n        id\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"user-profile\",\n        children: first_image_path ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n            src: \"http://127.0.0.1:8000/\".concat(first_image_path === null || first_image_path === void 0 ? void 0 : first_image_path.first_image_path),\n            alt: \"profile.image_path\",\n            className: \"rounded-image\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\Navigation.js\",\n            lineNumber: 17,\n            columnNumber: 21\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_matching_Loading__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\Navigation.js\",\n            lineNumber: 19,\n            columnNumber: 25\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\Navigation.js\",\n        lineNumber: 15,\n        columnNumber: 17\n    }, undefined);\n};\n_c = Navigation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navigation);\nvar _c;\n$RefreshReg$(_c, \"Navigation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0Y2hpbmcvTmF2aWdhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE2QjtBQUNJO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDSTtBQUN0QjtBQUNFO0FBQ2E7QUFDaEQsOEJBQThCO0FBQzlCLE1BQU1LLGFBQWE7UUFBRSxFQUFDQyxFQUFFLEVBQUM7SUFDckIsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHTCw2REFBVUEsQ0FBQztRQUFFTSxZQUFZO1FBQU9GO0lBQUc7SUFFaEUscUJBR1ksOERBQUNHO1FBQUlDLFdBQVU7a0JBQ05ILGlDQUNMLDhEQUFDSTtZQUFJQyxLQUFLLHlCQUE0RCxPQUFuQ0wsNkJBQUFBLHVDQUFBQSxpQkFBa0JBLGdCQUFnQjtZQUFJTSxLQUFJO1lBQXFCSCxXQUFVOzs7OztzQ0FFeEcsOERBQUNOLDZEQUFPQTs7Ozs7Ozs7OztBQU9oQztLQWpCTUM7QUFrQk4sK0RBQWVBLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9tYXRjaGluZy9OYXZpZ2F0aW9uLmpzP2UxMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBcIi4uLy4uL3N0eWxlcy90aW5kZXIuY3NzXCI7IC8vIEltcG9ydCB04buHcCBDU1NcbmltcG9ydCB7IHVzZXJBdmF0YXIgfSBmcm9tICcuLi8uLi8uLi9zcmMvaG9va3MvYXZhdGFyJztcbmltcG9ydCBMaWtlcyBmcm9tIFwiLi4vdXNlcnMvcGFnZVwiXG5pbXBvcnQgJy4uLy4uL3N0eWxlcy9kYXNoYm9hcmQuY3NzJ1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnLi4vLi4vYXBwL21hdGNoaW5nL0xvYWRpbmcnXG4vLyBEZWZpbmUgdGhlIEhlYWRlciBjb21wb25lbnRcbmNvbnN0IE5hdmlnYXRpb24gPSAoIHtpZH0pID0+IHtcbiAgICBjb25zdCB7IGZpcnN0X2ltYWdlX3BhdGggfSA9IHVzZXJBdmF0YXIoeyBtaWRkbGV3YXJlOiAnYXV0aCcsaWQgfSk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgXG4gICBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXItcHJvZmlsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2ZpcnN0X2ltYWdlX3BhdGggPyAoXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtgaHR0cDovLzEyNy4wLjAuMTo4MDAwLyR7Zmlyc3RfaW1hZ2VfcGF0aD8uZmlyc3RfaW1hZ2VfcGF0aH1gfSBhbHQ9J3Byb2ZpbGUuaW1hZ2VfcGF0aCcgY2xhc3NOYW1lPVwicm91bmRlZC1pbWFnZVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGluZyAvPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgXG5cbiBcbiAgICApO1xufVxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvbjtcblxuIl0sIm5hbWVzIjpbIkxpbmsiLCJ1c2VTdGF0ZSIsInVzZXJBdmF0YXIiLCJMaWtlcyIsIkxvYWRpbmciLCJOYXZpZ2F0aW9uIiwiaWQiLCJmaXJzdF9pbWFnZV9wYXRoIiwibWlkZGxld2FyZSIsImRpdiIsImNsYXNzTmFtZSIsImltZyIsInNyYyIsImFsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matching/Navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/matching/page.js":
/*!**********************************!*\
  !*** ./src/app/matching/page.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _src_hooks_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/hooks/match */ \"(app-pages-browser)/./src/hooks/match.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _app_messages_id_page__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../app/messages/[id]/page */ \"(app-pages-browser)/./src/app/messages/[id]/page.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global.css */ \"(app-pages-browser)/./src/app/matching/global.css\");\n/* harmony import */ var _app_matching_Navigation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../app/matching/Navigation */ \"(app-pages-browser)/./src/app/matching/Navigation.js\");\n// Import dependencies with correct paths\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst Matching = (param)=>{\n    let { onUserSelect, likesStatus, messageStatus } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const { matchedUsers, error, mutate } = (0,_src_hooks_match__WEBPACK_IMPORTED_MODULE_1__.userMatch)({\n        middleware: \"auth\"\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (likesStatus) {\n            console.log(\"Likes Status changed:\", likesStatus);\n            mutate(); // Cập nhật dữ liệu matchedUsers khi status thay đổi và có giá trị 'Liked'\n        }\n    // Call any function or perform any action when likesStatus changes\n    }, [\n        likesStatus\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (messageStatus) {\n            console.log(\"Likes Status changed:\", messageStatus);\n            mutate(); // Cập nhật dữ liệu message khi status thay đổi và có giá trị 'Liked'\n        }\n    // Call any function or perform any action when messageStatus changes\n    }, [\n        messageStatus\n    ]);\n    // const [selectedUserId, setSelectedUserId] = useState(null);\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Error loading data\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n            lineNumber: 36,\n            columnNumber: 16\n        }, undefined);\n    }\n    if (!matchedUsers) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n            lineNumber: 40,\n            columnNumber: 16\n        }, undefined);\n    }\n    console.log(\"Likes Status in Matching:\", likesStatus);\n    console.log(\"Likes Status in Message:\", messageStatus);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"matched-user\",\n        children: matchedUsers.map((match)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_matching_Navigation__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                        id: match.id\n                    }, void 0, false, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                        lineNumber: 48,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        href: \"/messages/\".concat(match.id),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            children: [\n                                \"Name: \",\n                                match.name\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                            lineNumber: 51,\n                            columnNumber: 22\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                        lineNumber: 49,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"Email: \",\n                            match.email\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                        lineNumber: 54,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            onUserSelect(match.id);\n                        },\n                        children: match.id\n                    }, void 0, false, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                        lineNumber: 56,\n                        columnNumber: 21\n                    }, undefined)\n                ]\n            }, match.id, true, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n                lineNumber: 47,\n                columnNumber: 17\n            }, undefined))\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\matching\\\\page.js\",\n        lineNumber: 45,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Matching, \"TvQOAa6MuxS5wkANqefpxaThEc4=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = Matching;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Matching);\nvar _c;\n$RefreshReg$(_c, \"Matching\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0Y2hpbmcvcGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEseUNBQXlDOzs7QUFFWTtBQUNWO0FBQ087QUFDUDtBQUNkO0FBQ1I7QUFDaUM7QUFDdEQsTUFBTU8sV0FBVztRQUFDLEVBQUVDLFlBQVksRUFBQ0MsV0FBVyxFQUFDQyxhQUFhLEVBQUU7O0lBQ3hELE1BQU1DLFNBQVNWLDBEQUFTQTtJQUN4QixNQUFNLEVBQUVXLFlBQVksRUFBRUMsS0FBSyxFQUFDQyxNQUFNLEVBQUUsR0FBR2QsMkRBQVNBLENBQUM7UUFDN0NlLFlBQVk7SUFDaEI7SUFFSlosZ0RBQVNBLENBQUM7UUFDTixJQUFJTSxhQUFhO1lBQ2JPLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJSO1lBQ3JDSyxVQUFVLDBFQUEwRTtRQUN4RjtJQUVBLG1FQUFtRTtJQUN2RSxHQUFHO1FBQUNMO0tBQVk7SUFFaEJOLGdEQUFTQSxDQUFDO1FBQ04sSUFBSU8sZUFBZTtZQUNmTSxRQUFRQyxHQUFHLENBQUMseUJBQXlCUDtZQUNyQ0ksVUFBVSxxRUFBcUU7UUFDbkY7SUFFQSxxRUFBcUU7SUFDekUsR0FBRztRQUFDSjtLQUFjO0lBQ2QsOERBQThEO0lBRTlELElBQUlHLE9BQU87UUFDUCxxQkFBTyw4REFBQ0s7c0JBQUk7Ozs7OztJQUNoQjtJQUVBLElBQUksQ0FBQ04sY0FBYztRQUNmLHFCQUFPLDhEQUFDTTtzQkFBSTs7Ozs7O0lBQ2hCO0lBQ0FGLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJSO0lBQ3pDTyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCUDtJQUN4QyxxQkFDSSw4REFBQ1E7UUFBSUMsV0FBVTtrQkFDVlAsYUFBYVEsR0FBRyxDQUFDQyxDQUFBQSxzQkFDZCw4REFBQ0g7O2tDQUNHLDhEQUFDWixnRUFBVUE7d0JBQUNnQixJQUFJRCxNQUFNQyxFQUFFOzs7Ozs7a0NBQ3hCLDhEQUFDakIsaURBQUlBO3dCQUFDa0IsTUFBTSxhQUFzQixPQUFURixNQUFNQyxFQUFFO2tDQUVoQyw0RUFBQ0U7O2dDQUFFO2dDQUFPSCxNQUFNSSxJQUFJOzs7Ozs7Ozs7Ozs7a0NBR3JCLDhEQUFDRDs7NEJBQUU7NEJBQVFILE1BQU1LLEtBQUs7Ozs7Ozs7a0NBRXRCLDhEQUFDQzt3QkFBT0MsU0FBUzs0QkFBU3BCLGFBQWFhLE1BQU1DLEVBQUU7d0JBQUc7a0NBQUlELE1BQU1DLEVBQUU7Ozs7Ozs7ZUFUeERELE1BQU1DLEVBQUU7Ozs7Ozs7Ozs7QUFlbEM7R0FwRE1mOztRQUNhTixzREFBU0E7OztLQUR0Qk07QUFzRE4sK0RBQWVBLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9tYXRjaGluZy9wYWdlLmpzP2JjMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IGRlcGVuZGVuY2llcyB3aXRoIGNvcnJlY3QgcGF0aHNcclxuJ3VzZSBjbGllbnQnXHJcbmltcG9ydCB7IHVzZXJNYXRjaCB9IGZyb20gJy4uLy4uLy4uL3NyYy9ob29rcy9tYXRjaCc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IE1lc3NhZ2UgZnJvbSBcIi4uLy4uL2FwcC9tZXNzYWdlcy9baWRdL3BhZ2VcIlxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCBcIi4vZ2xvYmFsLmNzc1wiXHJcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uLy4uL2FwcC9tYXRjaGluZy9OYXZpZ2F0aW9uJ1xyXG5jb25zdCBNYXRjaGluZyA9ICh7IG9uVXNlclNlbGVjdCxsaWtlc1N0YXR1cyxtZXNzYWdlU3RhdHVzIH0gKSA9PiB7XHJcbiAgICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuICAgIGNvbnN0IHsgbWF0Y2hlZFVzZXJzLCBlcnJvcixtdXRhdGUgfSA9IHVzZXJNYXRjaCh7XHJcbiAgICAgICAgbWlkZGxld2FyZTogJ2F1dGgnLFxyXG4gICAgfSk7XHJcblxyXG51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGxpa2VzU3RhdHVzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xpa2VzIFN0YXR1cyBjaGFuZ2VkOicsIGxpa2VzU3RhdHVzKTtcclxuICAgICAgICBtdXRhdGUoKTsgLy8gQ+G6rXAgbmjhuq10IGThu68gbGnhu4d1IG1hdGNoZWRVc2VycyBraGkgc3RhdHVzIHRoYXkgxJHhu5VpIHbDoCBjw7MgZ2nDoSB0cuG7iyAnTGlrZWQnXHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBDYWxsIGFueSBmdW5jdGlvbiBvciBwZXJmb3JtIGFueSBhY3Rpb24gd2hlbiBsaWtlc1N0YXR1cyBjaGFuZ2VzXHJcbn0sIFtsaWtlc1N0YXR1c10pO1xyXG5cclxudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChtZXNzYWdlU3RhdHVzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xpa2VzIFN0YXR1cyBjaGFuZ2VkOicsIG1lc3NhZ2VTdGF0dXMpO1xyXG4gICAgICAgIG11dGF0ZSgpOyAvLyBD4bqtcCBuaOG6rXQgZOG7ryBsaeG7h3UgbWVzc2FnZSBraGkgc3RhdHVzIHRoYXkgxJHhu5VpIHbDoCBjw7MgZ2nDoSB0cuG7iyAnTGlrZWQnXHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBDYWxsIGFueSBmdW5jdGlvbiBvciBwZXJmb3JtIGFueSBhY3Rpb24gd2hlbiBtZXNzYWdlU3RhdHVzIGNoYW5nZXNcclxufSwgW21lc3NhZ2VTdGF0dXNdKTtcclxuICAgIC8vIGNvbnN0IFtzZWxlY3RlZFVzZXJJZCwgc2V0U2VsZWN0ZWRVc2VySWRdID0gdXNlU3RhdGUobnVsbCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXY+RXJyb3IgbG9hZGluZyBkYXRhPC9kaXY+O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWF0Y2hlZFVzZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKFwiTGlrZXMgU3RhdHVzIGluIE1hdGNoaW5nOlwiLCBsaWtlc1N0YXR1cyk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkxpa2VzIFN0YXR1cyBpbiBNZXNzYWdlOlwiLCBtZXNzYWdlU3RhdHVzKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXRjaGVkLXVzZXJcIj5cclxuICAgICAgICAgICAge21hdGNoZWRVc2Vycy5tYXAobWF0Y2ggPT4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e21hdGNoLmlkfT5cclxuICAgICAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbiBpZD17bWF0Y2guaWR9Lz5cclxuICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPXtgL21lc3NhZ2VzLyR7bWF0Y2guaWR9YH0gPlxyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgPHA+TmFtZToge21hdGNoLm5hbWV9PC9wPlxyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgPHA+RW1haWw6IHttYXRjaC5lbWFpbH08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgey8qIDxidXR0b24gb25DbGljaz17KCkgPT4geyBzZXRTZWxlY3RlZFVzZXJJZChtYXRjaC5pZCk7IG9uVXNlclNlbGVjdChtYXRjaC5pZCk7IH19PnttYXRjaC5pZH08L2J1dHRvbj4gKi99XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB7ICBvblVzZXJTZWxlY3QobWF0Y2guaWQpOyB9fT57bWF0Y2guaWR9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgIHsvKiB7c2VsZWN0ZWRVc2VySWQgJiYgPE1lc3NhZ2UgaWQ9e3NlbGVjdGVkVXNlcklkfSAvPn0gKi99XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWF0Y2hpbmc7Il0sIm5hbWVzIjpbInVzZXJNYXRjaCIsInVzZVJvdXRlciIsIk1lc3NhZ2UiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkxpbmsiLCJOYXZpZ2F0aW9uIiwiTWF0Y2hpbmciLCJvblVzZXJTZWxlY3QiLCJsaWtlc1N0YXR1cyIsIm1lc3NhZ2VTdGF0dXMiLCJyb3V0ZXIiLCJtYXRjaGVkVXNlcnMiLCJlcnJvciIsIm11dGF0ZSIsIm1pZGRsZXdhcmUiLCJjb25zb2xlIiwibG9nIiwiZGl2IiwiY2xhc3NOYW1lIiwibWFwIiwibWF0Y2giLCJpZCIsImhyZWYiLCJwIiwibmFtZSIsImVtYWlsIiwiYnV0dG9uIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matching/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/messages/[id]/page.js":
/*!***************************************!*\
  !*** ./src/app/messages/[id]/page.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_messege__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../hooks/messege */ \"(app-pages-browser)/./src/hooks/messege.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/Button */ \"(app-pages-browser)/./src/components/Button.js\");\n/* harmony import */ var _components_Input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/Input */ \"(app-pages-browser)/./src/components/Input.js\");\n/* harmony import */ var _components_InputError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../components/InputError */ \"(app-pages-browser)/./src/components/InputError.js\");\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./global.css */ \"(app-pages-browser)/./src/app/messages/[id]/global.css\");\n/* harmony import */ var _deleteMatch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../deleteMatch */ \"(app-pages-browser)/./src/app/messages/deleteMatch.js\");\n/* harmony import */ var pusher_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! pusher-js */ \"(app-pages-browser)/./node_modules/pusher-js/dist/web/pusher.js\");\n/* harmony import */ var pusher_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(pusher_js__WEBPACK_IMPORTED_MODULE_9__);\n// Import dependencies with correct paths\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Message = (param)=>{\n    let { id, onStatusChange } = param;\n    _s();\n    const { conversation, matchedUser, loggedInUser, match, error, sendMessage, mutate } = (0,_hooks_messege__WEBPACK_IMPORTED_MODULE_1__.userMessenger)({\n        middleware: \"auth\",\n        redirectIfAuthenticated: \"/messages/\".concat(id),\n        id\n    });\n    const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [newMessage, setNewMessage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        (pusher_js__WEBPACK_IMPORTED_MODULE_9___default().logToConsole) = true;\n        const pusher = new (pusher_js__WEBPACK_IMPORTED_MODULE_9___default())(\"e974a70ed739866f2773\", {\n            cluster: \"eu\"\n        });\n        const channel = pusher.subscribe(\"my-channel\");\n        channel.bind(\"my-event\", function(data) {\n            setNewMessage(data);\n        });\n        return ()=>{\n            channel.unbind(\"my-event\");\n            pusher.unsubscribe(\"my-channel\");\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (newMessage) {\n            // Update conversation state with new message\n            mutate();\n        }\n    }, [\n        newMessage\n    ]);\n    const receiverId = (matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.id) || id;\n    const handleSubmit = async (e)=>{\n        e.preventDefault();\n        if (!content.trim()) return;\n        // // Lấy giá trị của receiver_id dựa vào điều kiện có matchedUser hay không\n        // const receiverId = matchedUser ? matchedUser.id : id;\n        await sendMessage({\n            receiver_id: receiverId,\n            content,\n            setErrors,\n            setStatus\n        });\n        setContent(\"\");\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        // Cập nhật dữ liệu tin nhắn sau khi gửi tin nhắn thành công\n        if (status === \"success\") {\n            mutate();\n            onStatusChange(\"\".concat(status, \" by \").concat(receiverId));\n        }\n    }, [\n        status\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        // Cuộn xuống tin nhắn mới nhất khi tin nhắn được gửi hoặc nhận\n        const chatList = document.querySelector(\".chat-list\");\n        chatList.scrollTop = chatList.scrollHeight;\n    }, [\n        conversation\n    ]); // Kích hoạt lại mỗi khi số lượng tin nhắn trong cuộc trò chuyện thay đổi\n    const date = match === null || match === void 0 ? void 0 : match.created_at.slice(0, 10);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"header-message\",\n                    children: [\n                        \"Conversation with \",\n                        matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.name,\n                        \" on \",\n                        date\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 79,\n                    columnNumber: 13\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_deleteMatch__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                    id: matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.id\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 80,\n                    columnNumber: 13\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"chat-list\",\n                    children: conversation && conversation.map((message)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: (loggedInUser === null || loggedInUser === void 0 ? void 0 : loggedInUser.id) === message.sender_id ? \"sent-message\" : \"received-message\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: [\n                                        (loggedInUser === null || loggedInUser === void 0 ? void 0 : loggedInUser.id) === message.sender_id ? loggedInUser === null || loggedInUser === void 0 ? void 0 : loggedInUser.name : matchedUser === null || matchedUser === void 0 ? void 0 : matchedUser.name,\n                                        \":\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                                    lineNumber: 84,\n                                    columnNumber: 25\n                                }, undefined),\n                                \" \",\n                                message.content\n                            ]\n                        }, message.id, true, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                            lineNumber: 83,\n                            columnNumber: 21\n                        }, undefined))\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 81,\n                    columnNumber: 13\n                }, undefined),\n                status === \"success\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-4 font-medium text-sm text-green-600 text-right\",\n                    children: \"Send sussessful\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 89,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                    onSubmit: handleSubmit,\n                    className: \"message-form\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Input__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            type: \"text\",\n                            value: content,\n                            onChange: (e)=>setContent(e.target.value),\n                            placeholder: \"Type your message...\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                            lineNumber: 96,\n                            columnNumber: 17\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_InputError__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            messages: errors.content,\n                            className: \"mt-2\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                            lineNumber: 102,\n                            columnNumber: 17\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_InputError__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            messages: errors.receiver_id,\n                            className: \"mt-2\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                            lineNumber: 103,\n                            columnNumber: 17\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            type: \"submit\",\n                            children: \"Send Message\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                            lineNumber: 104,\n                            columnNumber: 17\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 95,\n                    columnNumber: 13\n                }, undefined),\n                status === \"error\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-4 font-medium text-sm text-red-600 text-right\",\n                    children: \"You can only send messages to matched users.\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n                    lineNumber: 107,\n                    columnNumber: 16\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n            lineNumber: 78,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\[id]\\\\page.js\",\n        lineNumber: 77,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Message, \"wcdKbjbTUaqlSxFVHhTNVfrZnec=\");\n_c = Message;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Message);\nvar _c;\n$RefreshReg$(_c, \"Message\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWVzc2FnZXMvW2lkXS9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBeUM7OztBQUVjO0FBQ1o7QUFDTztBQUNIO0FBQ0Y7QUFDVTtBQUNsQztBQUNvQjtBQUNWO0FBQy9CLE1BQU1VLFVBQVU7UUFBQyxFQUFFQyxFQUFFLEVBQUdDLGNBQWMsRUFBRTs7SUFDcEMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxNQUFNLEVBQUUsR0FBR25CLDZEQUFhQSxDQUFDO1FBQUVvQixZQUFZO1FBQVFDLHlCQUF5QixhQUFnQixPQUFIVjtRQUFNQTtJQUFHO0lBRzFLLE1BQU0sQ0FBQ1csU0FBU0MsV0FBVyxHQUFHcEIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDcUIsUUFBUUMsVUFBVSxHQUFHdEIsK0NBQVFBLENBQUMsRUFBRTtJQUN2QyxNQUFNLENBQUN1QixRQUFRQyxVQUFVLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUN5QixZQUFZQyxjQUFjLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUU3Q0QsZ0RBQVNBLENBQUM7UUFDTk8sK0RBQW1CLEdBQUc7UUFFdEIsTUFBTXNCLFNBQVMsSUFBSXRCLGtEQUFNQSxDQUFDLHdCQUF3QjtZQUM5Q3VCLFNBQVM7UUFDYjtRQUVBLE1BQU1DLFVBQVVGLE9BQU9HLFNBQVMsQ0FBQztRQUNqQ0QsUUFBUUUsSUFBSSxDQUFDLFlBQVksU0FBU0MsSUFBSTtZQUNsQ1AsY0FBY087UUFDbEI7UUFFQSxPQUFPO1lBQ0hILFFBQVFJLE1BQU0sQ0FBQztZQUNmTixPQUFPTyxXQUFXLENBQUM7UUFDdkI7SUFDSixHQUFHLEVBQUU7SUFFTHBDLGdEQUFTQSxDQUFDO1FBQ04sSUFBSTBCLFlBQVk7WUFDWiw2Q0FBNkM7WUFDN0NUO1FBQ0o7SUFDSixHQUFHO1FBQUNTO0tBQVc7SUFDZixNQUFNVyxhQUFhekIsQ0FBQUEsd0JBQUFBLGtDQUFBQSxZQUFhSCxFQUFFLEtBQUlBO0lBQ3RDLE1BQU02QixlQUFlLE9BQU9DO1FBQ3hCQSxFQUFFQyxjQUFjO1FBQ2hCLElBQUksQ0FBQ3BCLFFBQVFxQixJQUFJLElBQUk7UUFHekIsNEVBQTRFO1FBQzVFLHdEQUF3RDtRQUNwRCxNQUFNekIsWUFBWTtZQUNkMEIsYUFBYUw7WUFDYmpCO1lBQ0FHO1lBQ0FFO1FBQ0o7UUFFQUosV0FBVztJQUNmO0lBRUFyQixnREFBU0EsQ0FBQztRQUNOLDREQUE0RDtRQUM1RCxJQUFJd0IsV0FBVyxXQUFXO1lBQ3RCUDtZQUNBUCxlQUFlLEdBQWdCMkIsT0FBYmIsUUFBTyxRQUFpQixPQUFYYTtRQUNuQztJQUNKLEdBQUc7UUFBQ2I7S0FBTztJQUNYeEIsZ0RBQVNBLENBQUM7UUFDTiwrREFBK0Q7UUFDL0QsTUFBTTJDLFdBQVdDLFNBQVNDLGFBQWEsQ0FBQztRQUN4Q0YsU0FBU0csU0FBUyxHQUFHSCxTQUFTSSxZQUFZO0lBQzlDLEdBQUc7UUFBQ3BDO0tBQWEsR0FBRyx5RUFBeUU7SUFDN0YsTUFBTXFDLE9BQU9sQyxrQkFBQUEsNEJBQUFBLE1BQU9tQyxVQUFVLENBQUNDLEtBQUssQ0FBQyxHQUFHO0lBQ3hDLHFCQUNJLDhEQUFDQztRQUFJQyxXQUFVO2tCQUNYLDRFQUFDRDs7OEJBQ0QsOERBQUNFO29CQUFHRCxXQUFVOzt3QkFBaUI7d0JBQW1CeEMsd0JBQUFBLGtDQUFBQSxZQUFhMEMsSUFBSTt3QkFBQzt3QkFBS047Ozs7Ozs7OEJBQ3pFLDhEQUFDMUMsb0RBQVlBO29CQUFDRyxFQUFFLEVBQUVHLHdCQUFBQSxrQ0FBQUEsWUFBYUgsRUFBRTs7Ozs7OzhCQUNqQyw4REFBQzhDO29CQUFHSCxXQUFVOzhCQUNUekMsZ0JBQWdCQSxhQUFhNkMsR0FBRyxDQUFDQyxDQUFBQSx3QkFDOUIsOERBQUNDOzRCQUFHTixXQUFXdkMsQ0FBQUEseUJBQUFBLG1DQUFBQSxhQUFjSixFQUFFLE1BQUtnRCxRQUFRRSxTQUFTLEdBQUcsaUJBQWlCOzs4Q0FDckUsOERBQUNDOzt3Q0FBUS9DLENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY0osRUFBRSxNQUFLZ0QsUUFBUUUsU0FBUyxHQUFHOUMseUJBQUFBLG1DQUFBQSxhQUFjeUMsSUFBSSxHQUFHMUMsd0JBQUFBLGtDQUFBQSxZQUFhMEMsSUFBSTt3Q0FBQzs7Ozs7OztnQ0FBVTtnQ0FBRUcsUUFBUXJDLE9BQU87OzJCQUR0QnFDLFFBQVFoRCxFQUFFOzs7Ozs7Ozs7O2dCQUtuSGUsV0FBVywyQkFDUiw4REFBQzJCO29CQUFJQyxXQUFVOzhCQUFxRDs7Ozs7OzhCQU14RSw4REFBQ1M7b0JBQUtDLFVBQVV4QjtvQkFBY2MsV0FBVTs7c0NBQ3BDLDhEQUFDaEQseURBQUtBOzRCQUNGMkQsTUFBSzs0QkFDTEMsT0FBTzVDOzRCQUNQNkMsVUFBVSxDQUFDMUIsSUFBTWxCLFdBQVdrQixFQUFFMkIsTUFBTSxDQUFDRixLQUFLOzRCQUMxQ0csYUFBWTs7Ozs7O3NDQUVoQiw4REFBQzlELDhEQUFVQTs0QkFBQytELFVBQVU5QyxPQUFPRixPQUFPOzRCQUFFZ0MsV0FBVTs7Ozs7O3NDQUNoRCw4REFBQy9DLDhEQUFVQTs0QkFBQytELFVBQVU5QyxPQUFPb0IsV0FBVzs0QkFBRVUsV0FBVTs7Ozs7O3NDQUNwRCw4REFBQ2pELDBEQUFNQTs0QkFBQzRELE1BQUs7c0NBQVM7Ozs7Ozs7Ozs7OztnQkFFekJ2QyxXQUFXLHlCQUNULDhEQUFDMkI7b0JBQUlDLFdBQVU7OEJBQW1EOzs7Ozs7Ozs7Ozs7Ozs7OztBQVFqRjtHQXZHTTVDO0tBQUFBO0FBeUdOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvbWVzc2FnZXMvW2lkXS9wYWdlLmpzPzY0ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IGRlcGVuZGVuY2llcyB3aXRoIGNvcnJlY3QgcGF0aHNcclxuJ3VzZSBjbGllbnQnXHJcbmltcG9ydCB7IHVzZXJNZXNzZW5nZXIgfSBmcm9tICcuLi8uLi8uLi9ob29rcy9tZXNzZWdlJztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvQnV0dG9uJ1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9JbnB1dCdcclxuaW1wb3J0IElucHV0RXJyb3IgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9JbnB1dEVycm9yJ1xyXG5pbXBvcnQgJy4vZ2xvYmFsLmNzcydcclxuaW1wb3J0IERlc3Ryb3lNYXRjaCBmcm9tICcuLi9kZWxldGVNYXRjaCdcclxuaW1wb3J0IFB1c2hlciBmcm9tICdwdXNoZXItanMnO1xyXG5jb25zdCBNZXNzYWdlID0gKHsgaWQgLCBvblN0YXR1c0NoYW5nZSB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGNvbnZlcnNhdGlvbiwgbWF0Y2hlZFVzZXIsIGxvZ2dlZEluVXNlciwgbWF0Y2gsIGVycm9yLCBzZW5kTWVzc2FnZSwgbXV0YXRlIH0gPSB1c2VyTWVzc2VuZ2VyKHsgbWlkZGxld2FyZTogJ2F1dGgnLCByZWRpcmVjdElmQXV0aGVudGljYXRlZDogYC9tZXNzYWdlcy8ke2lkfWAsIGlkIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgICBjb25zdCBbZXJyb3JzLCBzZXRFcnJvcnNdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW25ld01lc3NhZ2UsIHNldE5ld01lc3NhZ2VdID0gdXNlU3RhdGUobnVsbCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBQdXNoZXIubG9nVG9Db25zb2xlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgY29uc3QgcHVzaGVyID0gbmV3IFB1c2hlcignZTk3NGE3MGVkNzM5ODY2ZjI3NzMnLCB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXI6ICdldSdcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHB1c2hlci5zdWJzY3JpYmUoJ215LWNoYW5uZWwnKTtcclxuICAgICAgICBjaGFubmVsLmJpbmQoJ215LWV2ZW50JywgZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICBzZXROZXdNZXNzYWdlKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjaGFubmVsLnVuYmluZCgnbXktZXZlbnQnKTtcclxuICAgICAgICAgICAgcHVzaGVyLnVuc3Vic2NyaWJlKCdteS1jaGFubmVsJyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChuZXdNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb252ZXJzYXRpb24gc3RhdGUgd2l0aCBuZXcgbWVzc2FnZVxyXG4gICAgICAgICAgICBtdXRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbbmV3TWVzc2FnZV0pO1xyXG4gICAgY29uc3QgcmVjZWl2ZXJJZCA9IG1hdGNoZWRVc2VyPy5pZCB8fCBpZDtcclxuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmICghY29udGVudC50cmltKCkpIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgXHJcbiAgICAvLyAvLyBM4bqleSBnacOhIHRy4buLIGPhu6dhIHJlY2VpdmVyX2lkIGThu7FhIHbDoG8gxJFp4buBdSBraeG7h24gY8OzIG1hdGNoZWRVc2VyIGhheSBraMO0bmdcclxuICAgIC8vIGNvbnN0IHJlY2VpdmVySWQgPSBtYXRjaGVkVXNlciA/IG1hdGNoZWRVc2VyLmlkIDogaWQ7XHJcbiAgICAgICAgYXdhaXQgc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgc2V0RXJyb3JzLFxyXG4gICAgICAgICAgICBzZXRTdGF0dXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICBzZXRDb250ZW50KCcnKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gQ+G6rXAgbmjhuq10IGThu68gbGnhu4d1IHRpbiBuaOG6r24gc2F1IGtoaSBn4butaSB0aW4gbmjhuq9uIHRow6BuaCBjw7RuZ1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICBtdXRhdGUoKTtcclxuICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2UoYCR7c3RhdHVzfSBieSAke3JlY2VpdmVySWR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3N0YXR1c10pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAvLyBDdeG7mW4geHXhu5FuZyB0aW4gbmjhuq9uIG3hu5tpIG5o4bqldCBraGkgdGluIG5o4bqvbiDEkcaw4bujYyBn4butaSBob+G6t2Mgbmjhuq1uXHJcbiAgICAgICAgY29uc3QgY2hhdExpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2hhdC1saXN0Jyk7XHJcbiAgICAgICAgY2hhdExpc3Quc2Nyb2xsVG9wID0gY2hhdExpc3Quc2Nyb2xsSGVpZ2h0O1xyXG4gICAgfSwgW2NvbnZlcnNhdGlvbl0pOyAvLyBLw61jaCBob+G6oXQgbOG6oWkgbeG7l2kga2hpIHPhu5EgbMaw4bujbmcgdGluIG5o4bqvbiB0cm9uZyBjdeG7mWMgdHLDsiBjaHV54buHbiB0aGF5IMSR4buVaVxyXG4gICAgY29uc3QgZGF0ZSA9IG1hdGNoPy5jcmVhdGVkX2F0LnNsaWNlKDAsIDEwKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cImhlYWRlci1tZXNzYWdlXCI+Q29udmVyc2F0aW9uIHdpdGgge21hdGNoZWRVc2VyPy5uYW1lfSBvbiB7ZGF0ZX08L2gxPlxyXG4gICAgICAgICAgICA8RGVzdHJveU1hdGNoIGlkPXttYXRjaGVkVXNlcj8uaWR9IC8+XHJcbiAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJjaGF0LWxpc3RcIj5cclxuICAgICAgICAgICAgICAgIHtjb252ZXJzYXRpb24gJiYgY29udmVyc2F0aW9uLm1hcChtZXNzYWdlID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPXtsb2dnZWRJblVzZXI/LmlkID09PSBtZXNzYWdlLnNlbmRlcl9pZCA/ICdzZW50LW1lc3NhZ2UnIDogJ3JlY2VpdmVkLW1lc3NhZ2UnfSBrZXk9e21lc3NhZ2UuaWR9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPntsb2dnZWRJblVzZXI/LmlkID09PSBtZXNzYWdlLnNlbmRlcl9pZCA/IGxvZ2dlZEluVXNlcj8ubmFtZSA6IG1hdGNoZWRVc2VyPy5uYW1lfTo8L3N0cm9uZz4ge21lc3NhZ2UuY29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIHtzdGF0dXMgPT09ICdzdWNjZXNzJyAmJiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTQgZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCB0ZXh0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgU2VuZCBzdXNzZXNzZnVsXHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJtZXNzYWdlLWZvcm1cIj5cclxuICAgICAgICAgICAgICAgIDxJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldENvbnRlbnQoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSB5b3VyIG1lc3NhZ2UuLi5cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxJbnB1dEVycm9yIG1lc3NhZ2VzPXtlcnJvcnMuY29udGVudH0gY2xhc3NOYW1lPVwibXQtMlwiIC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXRFcnJvciBtZXNzYWdlcz17ZXJyb3JzLnJlY2VpdmVyX2lkfSBjbGFzc05hbWU9XCJtdC0yXCIgLz5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gdHlwZT1cInN1Ym1pdFwiPlNlbmQgTWVzc2FnZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgIHtzdGF0dXMgPT09ICdlcnJvcicgJiYgKFxyXG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTQgZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LXJlZC02MDAgdGV4dC1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gb25seSBzZW5kIG1lc3NhZ2VzIHRvIG1hdGNoZWQgdXNlcnMuXHJcblxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2U7ICJdLCJuYW1lcyI6WyJ1c2VyTWVzc2VuZ2VyIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJCdXR0b24iLCJJbnB1dCIsIklucHV0RXJyb3IiLCJEZXN0cm95TWF0Y2giLCJQdXNoZXIiLCJNZXNzYWdlIiwiaWQiLCJvblN0YXR1c0NoYW5nZSIsImNvbnZlcnNhdGlvbiIsIm1hdGNoZWRVc2VyIiwibG9nZ2VkSW5Vc2VyIiwibWF0Y2giLCJlcnJvciIsInNlbmRNZXNzYWdlIiwibXV0YXRlIiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwiY29udGVudCIsInNldENvbnRlbnQiLCJlcnJvcnMiLCJzZXRFcnJvcnMiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJuZXdNZXNzYWdlIiwic2V0TmV3TWVzc2FnZSIsImxvZ1RvQ29uc29sZSIsInB1c2hlciIsImNsdXN0ZXIiLCJjaGFubmVsIiwic3Vic2NyaWJlIiwiYmluZCIsImRhdGEiLCJ1bmJpbmQiLCJ1bnN1YnNjcmliZSIsInJlY2VpdmVySWQiLCJoYW5kbGVTdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJ0cmltIiwicmVjZWl2ZXJfaWQiLCJjaGF0TGlzdCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInNjcm9sbFRvcCIsInNjcm9sbEhlaWdodCIsImRhdGUiLCJjcmVhdGVkX2F0Iiwic2xpY2UiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsIm5hbWUiLCJ1bCIsIm1hcCIsIm1lc3NhZ2UiLCJsaSIsInNlbmRlcl9pZCIsInN0cm9uZyIsImZvcm0iLCJvblN1Ym1pdCIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwidGFyZ2V0IiwicGxhY2Vob2xkZXIiLCJtZXNzYWdlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/messages/[id]/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/messages/deleteMatch.js":
/*!*****************************************!*\
  !*** ./src/app/messages/deleteMatch.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_messege__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks/messege */ \"(app-pages-browser)/./src/hooks/messege.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/Button */ \"(app-pages-browser)/./src/components/Button.js\");\n/* harmony import */ var _components_Input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/Input */ \"(app-pages-browser)/./src/components/Input.js\");\n/* harmony import */ var _components_InputError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/InputError */ \"(app-pages-browser)/./src/components/InputError.js\");\n/* harmony import */ var _id_global_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./[id]/global.css */ \"(app-pages-browser)/./src/app/messages/[id]/global.css\");\n// Import dependencies with correct paths\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst DestroyMatch = (param)=>{\n    let { id } = param;\n    _s();\n    const { deleteMatch } = (0,_hooks_messege__WEBPACK_IMPORTED_MODULE_1__.userMessenger)({\n        middleware: \"auth\",\n        redirectIfAuthenticated: \"/matches/\".concat(id),\n        id\n    });\n    const [showModal, setShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false); // State để quản lý trạng thái của modal\n    const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const handleDeleteMatch = async ()=>{\n        await deleteMatch({\n            id,\n            setErrors,\n            setStatus\n        });\n        setShowModal(false); // Sau khi xóa, đóng modal\n    };\n    const handleModalClose = ()=>{\n        setShowModal(false); // Đóng modal khi người dùng bấm \"No\"\n    };\n    const handleSubmit = async (e)=>{\n        e.preventDefault();\n        setShowModal(true); // Hiển thị modal khi người dùng nhấn nút \"Destroy Match\"\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                onSubmit: handleSubmit,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                    type: \"submit\",\n                    children: \"Destroy Match\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                    lineNumber: 38,\n                    columnNumber: 17\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                lineNumber: 36,\n                columnNumber: 13\n            }, undefined),\n            showModal && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"modal\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"modal-content\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            children: \"Are you sure you want to delete this match?\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                            lineNumber: 45,\n                            columnNumber: 25\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            onClick: handleDeleteMatch,\n                            children: \"Yes\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                            lineNumber: 46,\n                            columnNumber: 25\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            onClick: handleModalClose,\n                            children: \"No\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                            lineNumber: 47,\n                            columnNumber: 25\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                    lineNumber: 44,\n                    columnNumber: 21\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n                lineNumber: 43,\n                columnNumber: 17\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\messages\\\\deleteMatch.js\",\n        lineNumber: 35,\n        columnNumber: 9\n    }, undefined);\n};\n_s(DestroyMatch, \"OTEVM6/OjiPUwZvr8uqCPRo09F8=\");\n_c = DestroyMatch;\n/* harmony default export */ __webpack_exports__[\"default\"] = (DestroyMatch);\nvar _c;\n$RefreshReg$(_c, \"DestroyMatch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWVzc2FnZXMvZGVsZXRlTWF0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHlDQUF5Qzs7O0FBRVc7QUFDVDtBQUNBO0FBQ0M7QUFDRjtBQUNVO0FBQzFCO0FBRTFCLE1BQU1PLGVBQWU7UUFBQyxFQUFFQyxFQUFFLEVBQUU7O0lBQ3hCLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdULDZEQUFhQSxDQUFDO1FBQUVVLFlBQVk7UUFBUUMseUJBQXlCLFlBQWUsT0FBSEg7UUFBTUE7SUFBRztJQUMxRyxNQUFNLENBQUNJLFdBQVdDLGFBQWEsR0FBR1YsK0NBQVFBLENBQUMsUUFBUSx3Q0FBd0M7SUFDM0YsTUFBTSxDQUFDVyxRQUFRQyxVQUFVLEdBQUdaLCtDQUFRQSxDQUFDLEVBQUU7SUFDdkMsTUFBTSxDQUFDYSxRQUFRQyxVQUFVLEdBQUdkLCtDQUFRQSxDQUFDO0lBRXJDLE1BQU1lLG9CQUFvQjtRQUN0QixNQUFNVCxZQUFZO1lBQ2JEO1lBQ0RPO1lBQ0FFO1FBQVc7UUFDZkosYUFBYSxRQUFRLDBCQUEwQjtJQUNuRDtJQUVBLE1BQU1NLG1CQUFtQjtRQUNyQk4sYUFBYSxRQUFRLHFDQUFxQztJQUM5RDtJQUVBLE1BQU1PLGVBQWUsT0FBT0M7UUFDeEJBLEVBQUVDLGNBQWM7UUFDaEJULGFBQWEsT0FBTyx5REFBeUQ7SUFDakY7SUFFQSxxQkFDSSw4REFBQ1U7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNDO2dCQUFLQyxVQUFVTjswQkFFWiw0RUFBQ2hCLDBEQUFNQTtvQkFBQ3VCLE1BQUs7OEJBQVM7Ozs7Ozs7Ozs7O1lBSXpCZiwyQkFDRyw4REFBQ1c7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNEO29CQUFJQyxXQUFVOztzQ0FDWCw4REFBQ0k7c0NBQUU7Ozs7OztzQ0FDSCw4REFBQ3hCLDBEQUFNQTs0QkFBQ3lCLFNBQVNYO3NDQUFtQjs7Ozs7O3NDQUNwQyw4REFBQ2QsMERBQU1BOzRCQUFDeUIsU0FBU1Y7c0NBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU0zRDtHQTFDTVo7S0FBQUE7QUE0Q04sK0RBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9tZXNzYWdlcy9kZWxldGVNYXRjaC5qcz8yNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydCBkZXBlbmRlbmNpZXMgd2l0aCBjb3JyZWN0IHBhdGhzXHJcbid1c2UgY2xpZW50J1xyXG5pbXBvcnQgeyB1c2VyTWVzc2VuZ2VyIH0gZnJvbSAnLi4vLi4vaG9va3MvbWVzc2VnZSc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQnV0dG9uJ1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9JbnB1dCdcclxuaW1wb3J0IElucHV0RXJyb3IgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9JbnB1dEVycm9yJ1xyXG5pbXBvcnQgJy4vW2lkXS9nbG9iYWwuY3NzJ1xyXG5cclxuY29uc3QgRGVzdHJveU1hdGNoID0gKHsgaWQgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBkZWxldGVNYXRjaCB9ID0gdXNlck1lc3Nlbmdlcih7IG1pZGRsZXdhcmU6ICdhdXRoJywgcmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQ6IGAvbWF0Y2hlcy8ke2lkfWAsIGlkIH0pO1xyXG4gICAgY29uc3QgW3Nob3dNb2RhbCwgc2V0U2hvd01vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gU3RhdGUgxJHhu4MgcXXhuqNuIGzDvSB0cuG6oW5nIHRow6FpIGPhu6dhIG1vZGFsXHJcbiAgICBjb25zdCBbZXJyb3JzLCBzZXRFcnJvcnNdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKG51bGwpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZURlbGV0ZU1hdGNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRlbGV0ZU1hdGNoKHtcclxuICAgICAgICAgICAgIGlkLCBcclxuICAgICAgICAgICAgc2V0RXJyb3JzLFxyXG4gICAgICAgICAgICBzZXRTdGF0dXMsIH0pO1xyXG4gICAgICAgIHNldFNob3dNb2RhbChmYWxzZSk7IC8vIFNhdSBraGkgeMOzYSwgxJHDs25nIG1vZGFsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vZGFsQ2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0U2hvd01vZGFsKGZhbHNlKTsgLy8gxJDDs25nIG1vZGFsIGtoaSBuZ8aw4budaSBkw7luZyBi4bqlbSBcIk5vXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgc2V0U2hvd01vZGFsKHRydWUpOyAvLyBIaeG7g24gdGjhu4sgbW9kYWwga2hpIG5nxrDhu51pIGTDuW5nIG5o4bqlbiBuw7p0IFwiRGVzdHJveSBNYXRjaFwiXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cclxuICAgICAgICAgICAgICAgIHsvKiBGb3JtIGlucHV0cyBhbmQgYnV0dG9ucyBjYW4gYmUgYWRkZWQgaGVyZSAqL31cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gdHlwZT1cInN1Ym1pdFwiPkRlc3Ryb3kgTWF0Y2g8L0J1dHRvbj5cclxuICAgICAgICAgICAgPC9mb3JtPlxyXG5cclxuICAgICAgICAgICAgey8qIE1vZGFsICovfVxyXG4gICAgICAgICAgICB7c2hvd01vZGFsICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWxcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+QXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIG1hdGNoPzwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVEZWxldGVNYXRjaH0+WWVzPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17aGFuZGxlTW9kYWxDbG9zZX0+Tm88L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlc3Ryb3lNYXRjaDsiXSwibmFtZXMiOlsidXNlck1lc3NlbmdlciIsInVzZVJvdXRlciIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQnV0dG9uIiwiSW5wdXQiLCJJbnB1dEVycm9yIiwiRGVzdHJveU1hdGNoIiwiaWQiLCJkZWxldGVNYXRjaCIsIm1pZGRsZXdhcmUiLCJyZWRpcmVjdElmQXV0aGVudGljYXRlZCIsInNob3dNb2RhbCIsInNldFNob3dNb2RhbCIsImVycm9ycyIsInNldEVycm9ycyIsInN0YXR1cyIsInNldFN0YXR1cyIsImhhbmRsZURlbGV0ZU1hdGNoIiwiaGFuZGxlTW9kYWxDbG9zZSIsImhhbmRsZVN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImRpdiIsImNsYXNzTmFtZSIsImZvcm0iLCJvblN1Ym1pdCIsInR5cGUiLCJwIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/messages/deleteMatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/profile/[id]/page.js":
/*!**************************************!*\
  !*** ./src/app/profile/[id]/page.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_Info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../hooks/Info */ \"(app-pages-browser)/./src/hooks/Info.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var slick_carousel_slick_slick_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slick-carousel/slick/slick.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\");\n/* harmony import */ var slick_carousel_slick_slick_theme_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! slick-carousel/slick/slick-theme.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\");\n/* harmony import */ var react_slick__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-slick */ \"(app-pages-browser)/./node_modules/react-slick/lib/index.js\");\n/* harmony import */ var _users_global_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../users/global.css */ \"(app-pages-browser)/./src/app/users/global.css\");\n// Import dependencies with correct paths\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\nconst User = (param)=>{\n    let { id } = param;\n    const { user, error, mutate } = (0,_hooks_Info__WEBPACK_IMPORTED_MODULE_1__.userInfo)({\n        middleware: \"auth\",\n        redirectIfAuthenticated: \"/users/\".concat(id),\n        id\n    });\n    // console.log(\"User infor: \", user);\n    const settings = {\n        dots: true,\n        infinite: true,\n        speed: 500,\n        slidesToShow: 1,\n        slidesToScroll: 1\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"frame\",\n        children: user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"card\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"Images:\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 26,\n                                columnNumber: 25\n                            }, undefined),\n                            user.profile.image_path.includes(\",\") ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_slick__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                ...settings,\n                                children: user.profile.image_path.split(\",\").map((image, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        src: \"http://127.0.0.1:8000/\".concat(image),\n                                        alt: \"Image \".concat(index),\n                                        style: {\n                                            maxWidth: \"300px\"\n                                        }\n                                    }, index, false, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                        lineNumber: 30,\n                                        columnNumber: 33\n                                    }, undefined))\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 28,\n                                columnNumber: 25\n                            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                src: \"http://127.0.0.1:8000/\".concat(user.profile.image_path),\n                                alt: \"Image\",\n                                style: {\n                                    maxWidth: \"300px\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 39,\n                                columnNumber: 29\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                        lineNumber: 25,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Hello, \",\n                                    user.name\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 47,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Email: \",\n                                    user.email\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 48,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Age: \",\n                                    user.profile.age\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 49,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Gender: \",\n                                    user.profile.gender === 1 ? \"Male\" : \"Female\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                                lineNumber: 50,\n                                columnNumber: 25\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                        lineNumber: 46,\n                        columnNumber: 21\n                    }, undefined)\n                ]\n            }, user.id, true, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n                lineNumber: 24,\n                columnNumber: 17\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n            lineNumber: 23,\n            columnNumber: 13\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n            lineNumber: 58,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\profile\\\\[id]\\\\page.js\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, undefined);\n};\n_c = User;\n/* harmony default export */ __webpack_exports__[\"default\"] = (User);\nvar _c;\n$RefreshReg$(_c, \"User\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcHJvZmlsZS9baWRdL3BhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHlDQUF5Qzs7QUFFTTtBQUNKO0FBQ0E7QUFDSDtBQUNNO0FBQ2I7QUFDRDtBQUNoQyxNQUFNSyxPQUFPO1FBQUMsRUFBRUMsRUFBRSxFQUFFO0lBQ2hCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHVCxxREFBUUEsQ0FBQztRQUFFVSxZQUFZO1FBQVFDLHlCQUF5QixVQUFhLE9BQUhMO1FBQU1BO0lBQUc7SUFDL0cscUNBQXFDO0lBQ3JDLE1BQU1NLFdBQVc7UUFDYkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLE9BQU87UUFDUEMsY0FBYztRQUNkQyxnQkFBZ0I7SUFDbEI7SUFDRixxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDVloscUJBQ0csOERBQUNXO3NCQUNHLDRFQUFDQTtnQkFBSUMsV0FBVTs7a0NBQ1gsOERBQUNEOzswQ0FDRyw4REFBQ0U7MENBQUU7Ozs7Ozs0QkFDRmIsS0FBS2MsT0FBTyxDQUFDQyxVQUFVLENBQUNDLFFBQVEsQ0FBQyxxQkFDbEMsOERBQUNuQixtREFBTUE7Z0NBQUUsR0FBR1EsUUFBUTswQ0FDZkwsS0FBS2MsT0FBTyxDQUFDQyxVQUFVLENBQUNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsT0FBT0Msc0JBQzVDLDhEQUFDQzt3Q0FFR0MsS0FBSyx5QkFBK0IsT0FBTkg7d0NBQzlCSSxLQUFLLFNBQWUsT0FBTkg7d0NBQ2RJLE9BQU87NENBQUVDLFVBQVU7d0NBQVE7dUNBSHRCTDs7Ozs7Ozs7OzBEQVFiLDhEQUFDQztnQ0FDQ0MsS0FBSyx5QkFBaUQsT0FBeEJ0QixLQUFLYyxPQUFPLENBQUNDLFVBQVU7Z0NBQ3JEUSxLQUFJO2dDQUNKQyxPQUFPO29DQUFFQyxVQUFVO2dDQUFROzs7Ozs7Ozs7Ozs7a0NBSXJDLDhEQUFDZDs7MENBQ0csOERBQUNBOztvQ0FBSTtvQ0FBUVgsS0FBSzBCLElBQUk7Ozs7Ozs7MENBQ3RCLDhEQUFDZjs7b0NBQUk7b0NBQVFYLEtBQUsyQixLQUFLOzs7Ozs7OzBDQUN2Qiw4REFBQ2hCOztvQ0FBSTtvQ0FBTVgsS0FBS2MsT0FBTyxDQUFDYyxHQUFHOzs7Ozs7OzBDQUMzQiw4REFBQ2pCOztvQ0FBSTtvQ0FBU1gsS0FBS2MsT0FBTyxDQUFDZSxNQUFNLEtBQUssSUFBSSxTQUFTOzs7Ozs7Ozs7Ozs7OztlQTFCaEM3QixLQUFLRCxFQUFFOzs7Ozs7Ozs7c0NBa0N0Qyw4REFBQ1k7c0JBQUk7Ozs7Ozs7Ozs7O0FBSWpCO0tBcERNYjtBQXNETiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3Byb2ZpbGUvW2lkXS9wYWdlLmpzP2MwZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IGRlcGVuZGVuY2llcyB3aXRoIGNvcnJlY3QgcGF0aHNcclxuJ3VzZSBjbGllbnQnXHJcbmltcG9ydCB7IHVzZXJJbmZvIH0gZnJvbSAnLi4vLi4vLi4vaG9va3MvSW5mbyc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgJ3NsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLmNzcyc7XHJcbmltcG9ydCAnc2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2stdGhlbWUuY3NzJztcclxuaW1wb3J0IFNsaWRlciBmcm9tICdyZWFjdC1zbGljayc7XHJcbmltcG9ydCAnLi4vLi4vdXNlcnMvZ2xvYmFsLmNzcyc7XHJcbmNvbnN0IFVzZXIgPSAoeyBpZCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHVzZXIsIGVycm9yLCBtdXRhdGUgfSA9IHVzZXJJbmZvKHsgbWlkZGxld2FyZTogJ2F1dGgnLCByZWRpcmVjdElmQXV0aGVudGljYXRlZDogYC91c2Vycy8ke2lkfWAsIGlkIH0pO1xyXG4vLyBjb25zb2xlLmxvZyhcIlVzZXIgaW5mb3I6IFwiLCB1c2VyKTtcclxuY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICBkb3RzOiB0cnVlLFxyXG4gICAgaW5maW5pdGU6IHRydWUsXHJcbiAgICBzcGVlZDogNTAwLFxyXG4gICAgc2xpZGVzVG9TaG93OiAxLFxyXG4gICAgc2xpZGVzVG9TY3JvbGw6IDFcclxuICB9O1xyXG5yZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmcmFtZVwiPlxyXG4gICAgICAgIHt1c2VyID8gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCIga2V5PXt1c2VyLmlkfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5JbWFnZXM6PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dXNlci5wcm9maWxlLmltYWdlX3BhdGguaW5jbHVkZXMoJywnKSA/IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNsaWRlciB7Li4uc2V0dGluZ3N9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3VzZXIucHJvZmlsZS5pbWFnZV9wYXRoLnNwbGl0KCcsJykubWFwKChpbWFnZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17YGh0dHA6Ly8xMjcuMC4wLjE6ODAwMC8ke2ltYWdlfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17YEltYWdlICR7aW5kZXh9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWF4V2lkdGg6ICczMDBweCcgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU2xpZGVyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXtgaHR0cDovLzEyNy4wLjAuMTo4MDAwLyR7dXNlci5wcm9maWxlLmltYWdlX3BhdGh9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiSW1hZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXhXaWR0aDogJzMwMHB4JyB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SGVsbG8sIHt1c2VyLm5hbWV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+RW1haWw6IHt1c2VyLmVtYWlsfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PkFnZToge3VzZXIucHJvZmlsZS5hZ2V9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+R2VuZGVyOiB7dXNlci5wcm9maWxlLmdlbmRlciA9PT0gMSA/IFwiTWFsZVwiIDogXCJGZW1hbGVcIn08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgey8qIEFkZCBhZGRpdGlvbmFsIGZpZWxkcyBhcyBuZWVkZWQgKi99XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgey8qIEFkZCBhZGRpdGlvbmFsIFVJIGVsZW1lbnRzIG9yIGJ1dHRvbnMgKi99XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgPGRpdj5Mb2FkaW5nLi4uPC9kaXY+XHJcbiAgICAgICAgKX1cclxuICAgIDwvZGl2PlxyXG4pO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVXNlcjsgIl0sIm5hbWVzIjpbInVzZXJJbmZvIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJTbGlkZXIiLCJVc2VyIiwiaWQiLCJ1c2VyIiwiZXJyb3IiLCJtdXRhdGUiLCJtaWRkbGV3YXJlIiwicmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQiLCJzZXR0aW5ncyIsImRvdHMiLCJpbmZpbml0ZSIsInNwZWVkIiwic2xpZGVzVG9TaG93Iiwic2xpZGVzVG9TY3JvbGwiLCJkaXYiLCJjbGFzc05hbWUiLCJwIiwicHJvZmlsZSIsImltYWdlX3BhdGgiLCJpbmNsdWRlcyIsInNwbGl0IiwibWFwIiwiaW1hZ2UiLCJpbmRleCIsImltZyIsInNyYyIsImFsdCIsInN0eWxlIiwibWF4V2lkdGgiLCJuYW1lIiwiZW1haWwiLCJhZ2UiLCJnZW5kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/profile/[id]/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/recent-messages/page.js":
/*!*****************************************!*\
  !*** ./src/app/recent-messages/page.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_recent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks/recent */ \"(app-pages-browser)/./src/hooks/recent.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global.css */ \"(app-pages-browser)/./src/app/recent-messages/global.css\");\n/* harmony import */ var _app_messages_id_page__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../app/messages/[id]/page */ \"(app-pages-browser)/./src/app/messages/[id]/page.js\");\n/* harmony import */ var _app_matching_Navigation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../app/matching/Navigation */ \"(app-pages-browser)/./src/app/matching/Navigation.js\");\n/* harmony import */ var _app_subscription_plans_page__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../app/subscription_plans/page */ \"(app-pages-browser)/./src/app/subscription_plans/page.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst MessengerComponent = (param)=>{\n    let { onUserSelect, messageStatus } = param;\n    _s();\n    const { recentMessages, error, mutate } = (0,_hooks_recent__WEBPACK_IMPORTED_MODULE_1__.userRecent)({\n        middleware: \"auth\",\n        redirectIfAuthenticated: \"/dashboard\"\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (messageStatus) {\n            console.log(\"Likes Status changed in New messege:\", messageStatus);\n            mutate(); // Cập nhật dữ liệu message khi status thay đổi và có giá trị 'Liked'\n        }\n    // Call any function or perform any action when messageStatus changes\n    }, [\n        messageStatus\n    ]);\n    // const [selectedUserId, setSelectedUserId] = useState(null);\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                \"Error fetching recent messages: \",\n                error.message\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n            lineNumber: 26,\n            columnNumber: 16\n        }, undefined);\n    }\n    if (!recentMessages) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n            lineNumber: 30,\n            columnNumber: 16\n        }, undefined);\n    }\n    const messagesArray = Object.values(recentMessages);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"messenger-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                href: \"/subscription_plans\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"user-names\",\n                    children: \"Buy tinder gold\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                    lineNumber: 37,\n                    columnNumber: 25\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                lineNumber: 36,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_subscription_plans_page__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                lineNumber: 39,\n                columnNumber: 21\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"messenger-header\",\n                children: \"Recent Messages\"\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                lineNumber: 40,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"message-list\",\n                children: messagesArray.map((message, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"message-item\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_matching_Navigation__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                id: message.user.id\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                                lineNumber: 44,\n                                columnNumber: 23\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                href: \"/messages/\".concat(message.user.id),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"user-names\",\n                                    children: [\n                                        \"User: \",\n                                        message.user.name\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                                    lineNumber: 46,\n                                    columnNumber: 25\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                                lineNumber: 45,\n                                columnNumber: 21\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"last-message\",\n                                children: [\n                                    \"Last Message: \",\n                                    message.last_message.content\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                                lineNumber: 48,\n                                columnNumber: 21\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>{\n                                    onUserSelect(message.user.id);\n                                },\n                                children: message.user.id\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                                lineNumber: 50,\n                                columnNumber: 21\n                            }, undefined)\n                        ]\n                    }, index, true, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                        lineNumber: 43,\n                        columnNumber: 17\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n                lineNumber: 41,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\recent-messages\\\\page.js\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, undefined);\n};\n_s(MessengerComponent, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = MessengerComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MessengerComponent);\nvar _c;\n$RefreshReg$(_c, \"MessengerComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcmVjZW50LW1lc3NhZ2VzL3BhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVnRDtBQUNMO0FBQ0E7QUFDZDtBQUNSO0FBQzZCO0FBQ0k7QUFDQztBQUN2RCxNQUFNUSxxQkFBcUI7UUFBQyxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBRTs7SUFDdkQsTUFBTSxFQUFFQyxjQUFjLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdiLHlEQUFVQSxDQUFDO1FBQ2pEYyxZQUFZO1FBQ1pDLHlCQUF5QjtJQUM3QjtJQUNBYixnREFBU0EsQ0FBQztRQUNOLElBQUlRLGVBQWU7WUFDZk0sUUFBUUMsR0FBRyxDQUFDLHdDQUF3Q1A7WUFDcERHLFVBQVUscUVBQXFFO1FBQ25GO0lBRUEscUVBQXFFO0lBQ3pFLEdBQUc7UUFBQ0g7S0FBYztJQUNsQiw4REFBOEQ7SUFDOUQsSUFBSUUsT0FBTztRQUNQLHFCQUFPLDhEQUFDTTs7Z0JBQUk7Z0JBQWlDTixNQUFNTyxPQUFPOzs7Ozs7O0lBQzlEO0lBRUEsSUFBSSxDQUFDUixnQkFBZ0I7UUFDakIscUJBQU8sOERBQUNPO3NCQUFJOzs7Ozs7SUFDaEI7SUFDSixNQUFNRSxnQkFBZ0JDLE9BQU9DLE1BQU0sQ0FBQ1g7SUFFcEMscUJBQ0ksOERBQUNPO1FBQUlLLFdBQVU7OzBCQUNYLDhEQUFDbkIsaURBQUlBO2dCQUFDb0IsTUFBTzswQkFDRyw0RUFBQ047b0JBQUlLLFdBQVU7OEJBQWE7Ozs7Ozs7Ozs7OzBCQUVoQyw4REFBQ2hCLG9FQUFPQTs7Ozs7MEJBQ3BCLDhEQUFDa0I7Z0JBQUdGLFdBQVU7MEJBQW1COzs7Ozs7MEJBQ2pDLDhEQUFDRztnQkFBR0gsV0FBVTswQkFDVEgsY0FBY08sR0FBRyxDQUFDLENBQUNSLFNBQVNTLHNCQUN6Qiw4REFBQ0M7d0JBQWVOLFdBQVU7OzBDQUNwQiw4REFBQ2pCLGdFQUFVQTtnQ0FBQ3dCLElBQUlYLFFBQVFZLElBQUksQ0FBQ0QsRUFBRTs7Ozs7OzBDQUNqQyw4REFBQzFCLGlEQUFJQTtnQ0FBQ29CLE1BQU0sYUFBNkIsT0FBaEJMLFFBQVFZLElBQUksQ0FBQ0QsRUFBRTswQ0FDcEMsNEVBQUNaO29DQUFJSyxXQUFVOzt3Q0FBYTt3Q0FBT0osUUFBUVksSUFBSSxDQUFDQyxJQUFJOzs7Ozs7Ozs7Ozs7MENBRXhELDhEQUFDZDtnQ0FBSUssV0FBVTs7b0NBQWU7b0NBQWVKLFFBQVFjLFlBQVksQ0FBQ0MsT0FBTzs7Ozs7OzswQ0FFekUsOERBQUNDO2dDQUFPQyxTQUFTO29DQUFPM0IsYUFBYVUsUUFBUVksSUFBSSxDQUFDRCxFQUFFO2dDQUFHOzBDQUFJWCxRQUFRWSxJQUFJLENBQUNELEVBQUU7Ozs7Ozs7dUJBUHJFRjs7Ozs7Ozs7Ozs7Ozs7OztBQWN6QjtHQTlDTXBCO0tBQUFBO0FBaUROLCtEQUFlQSxrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9yZWNlbnQtbWVzc2FnZXMvcGFnZS5qcz83MzA0Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG4ndXNlIGNsaWVudCdcclxuaW1wb3J0IHsgdXNlclJlY2VudCB9IGZyb20gJy4uLy4uL2hvb2tzL3JlY2VudCc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5pbXBvcnQgXCIuL2dsb2JhbC5jc3NcIlxyXG5pbXBvcnQgTWVzc2FnZSBmcm9tIFwiLi4vLi4vYXBwL21lc3NhZ2VzL1tpZF0vcGFnZVwiXHJcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uLy4uL2FwcC9tYXRjaGluZy9OYXZpZ2F0aW9uJ1xyXG5pbXBvcnQgUGF5bWVudCBmcm9tICcuLi8uLi9hcHAvc3Vic2NyaXB0aW9uX3BsYW5zL3BhZ2UnXHJcbmNvbnN0IE1lc3NlbmdlckNvbXBvbmVudCA9ICh7IG9uVXNlclNlbGVjdCwgbWVzc2FnZVN0YXR1cyB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHJlY2VudE1lc3NhZ2VzLCBlcnJvciwgbXV0YXRlIH0gPSB1c2VyUmVjZW50KHsgIFxyXG4gICAgICAgIG1pZGRsZXdhcmU6ICdhdXRoJyxcclxuICAgICAgICByZWRpcmVjdElmQXV0aGVudGljYXRlZDogJy9kYXNoYm9hcmQnLCAvLyBUaMOqbSBk4bqldSAnKScg4bufIGN14buRaSDEkcOieVxyXG4gICAgfSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChtZXNzYWdlU3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMaWtlcyBTdGF0dXMgY2hhbmdlZCBpbiBOZXcgbWVzc2VnZTonLCBtZXNzYWdlU3RhdHVzKTtcclxuICAgICAgICAgICAgbXV0YXRlKCk7IC8vIEPhuq1wIG5o4bqtdCBk4buvIGxp4buHdSBtZXNzYWdlIGtoaSBzdGF0dXMgdGhheSDEkeG7lWkgdsOgIGPDsyBnacOhIHRy4buLICdMaWtlZCdcclxuICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIENhbGwgYW55IGZ1bmN0aW9uIG9yIHBlcmZvcm0gYW55IGFjdGlvbiB3aGVuIG1lc3NhZ2VTdGF0dXMgY2hhbmdlc1xyXG4gICAgfSwgW21lc3NhZ2VTdGF0dXNdKTtcclxuICAgIC8vIGNvbnN0IFtzZWxlY3RlZFVzZXJJZCwgc2V0U2VsZWN0ZWRVc2VySWRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gPGRpdj5FcnJvciBmZXRjaGluZyByZWNlbnQgbWVzc2FnZXM6IHtlcnJvci5tZXNzYWdlfTwvZGl2PjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlY2VudE1lc3NhZ2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcclxuICAgIH1cclxuY29uc3QgbWVzc2FnZXNBcnJheSA9IE9iamVjdC52YWx1ZXMocmVjZW50TWVzc2FnZXMpO1xyXG5cclxucmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWVzc2VuZ2VyLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxMaW5rIGhyZWY9e2Avc3Vic2NyaXB0aW9uX3BsYW5zYH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXNlci1uYW1lc1wiPkJ1eSB0aW5kZXIgZ29sZDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgICA8UGF5bWVudC8+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cIm1lc3Nlbmdlci1oZWFkZXJcIj5SZWNlbnQgTWVzc2FnZXM8L2gyPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJtZXNzYWdlLWxpc3RcIj5cclxuICAgICAgICAgICAge21lc3NhZ2VzQXJyYXkubWFwKChtZXNzYWdlLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgPGxpIGtleT17aW5kZXh9IGNsYXNzTmFtZT1cIm1lc3NhZ2UtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPE5hdmlnYXRpb24gaWQ9e21lc3NhZ2UudXNlci5pZH0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPXtgL21lc3NhZ2VzLyR7bWVzc2FnZS51c2VyLmlkfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXItbmFtZXNcIj5Vc2VyOiB7bWVzc2FnZS51c2VyLm5hbWV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGFzdC1tZXNzYWdlXCI+TGFzdCBNZXNzYWdlOiB7bWVzc2FnZS5sYXN0X21lc3NhZ2UuY29udGVudH08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICB7LyogPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB7IHNldFNlbGVjdGVkVXNlcklkKG1lc3NhZ2UudXNlci5pZCk7IG9uVXNlclNlbGVjdChtZXNzYWdlLnVzZXIuaWQpOyB9fT57bWVzc2FnZS51c2VyLmlkfTwvYnV0dG9uPiAqL31cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHtvblVzZXJTZWxlY3QobWVzc2FnZS51c2VyLmlkKTsgfX0+e21lc3NhZ2UudXNlci5pZH08L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgIHsvKiB7c2VsZWN0ZWRVc2VySWQgJiYgPE1lc3NhZ2UgaWQ9e3NlbGVjdGVkVXNlcklkfSAvPn0gKi99XHJcbiAgICAgICAgPC91bD5cclxuICAgIDwvZGl2PlxyXG4pO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NlbmdlckNvbXBvbmVudDsiXSwibmFtZXMiOlsidXNlclJlY2VudCIsInVzZVJvdXRlciIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiTGluayIsIk1lc3NhZ2UiLCJOYXZpZ2F0aW9uIiwiUGF5bWVudCIsIk1lc3NlbmdlckNvbXBvbmVudCIsIm9uVXNlclNlbGVjdCIsIm1lc3NhZ2VTdGF0dXMiLCJyZWNlbnRNZXNzYWdlcyIsImVycm9yIiwibXV0YXRlIiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwiY29uc29sZSIsImxvZyIsImRpdiIsIm1lc3NhZ2UiLCJtZXNzYWdlc0FycmF5IiwiT2JqZWN0IiwidmFsdWVzIiwiY2xhc3NOYW1lIiwiaHJlZiIsImgyIiwidWwiLCJtYXAiLCJpbmRleCIsImxpIiwiaWQiLCJ1c2VyIiwibmFtZSIsImxhc3RfbWVzc2FnZSIsImNvbnRlbnQiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/recent-messages/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/subscription_plans/page.js":
/*!********************************************!*\
  !*** ./src/app/subscription_plans/page.js ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_tinder_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../styles/tinder.css */ \"(app-pages-browser)/./src/styles/tinder.css\");\n/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/Button */ \"(app-pages-browser)/./src/components/Button.js\");\n/* harmony import */ var _src_hooks_payment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/hooks/payment */ \"(app-pages-browser)/./src/hooks/payment.js\");\n/* harmony import */ var _src_hooks_plan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/hooks/plan */ \"(app-pages-browser)/./src/hooks/plan.js\");\n/* harmony import */ var _styles_plan_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../styles/plan.css */ \"(app-pages-browser)/./src/styles/plan.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n // Import tệp CSS\n\n\n\n\nconst Payment = ()=>{\n    _s();\n    const { vnpay_payment } = (0,_src_hooks_payment__WEBPACK_IMPORTED_MODULE_4__.userPayment)({\n        middleware: \"auth\"\n    });\n    const { subscriptionPlans } = (0,_src_hooks_plan__WEBPACK_IMPORTED_MODULE_5__.userPlan)({\n        middleware: \"auth\"\n    });\n    const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedPlan, setSelectedPlan] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [planType, setPlanType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // Thêm biến planType\n    const handlePayment = async (event, plan, type)=>{\n        event.preventDefault();\n        setPlanType(type); // Cập nhật giá trị của biến planType khi người dùng chọn loại kế hoạch\n        // Lấy thông tin từ kế hoạch được chọn\n        const order_info = plan.name;\n        const subscription_plan_id = plan.id;\n        // Chọn giá theo loại kế hoạch\n        let amount;\n        if (type === \"weekly\") {\n            amount = plan.weekly_price;\n        } else if (type === \"monthly\") {\n            amount = plan.monthly_price;\n        } else if (type === \"yearly\") {\n            amount = plan.yearly_price;\n        }\n        await vnpay_payment({\n            order_info,\n            order_type: \"week\",\n            amount,\n            subscription_plan_id,\n            setErrors,\n            setStatus\n        });\n    };\n    const PlanArray = subscriptionPlans ? Object.values(subscriptionPlans) : [];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"payment-container\",\n            children: PlanArray.map((plan)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"payment-details\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            onClick: ()=>setSelectedPlan(plan),\n                            children: plan.name\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                            lineNumber: 56,\n                            columnNumber: 25\n                        }, undefined),\n                        selectedPlan && selectedPlan.id === plan.id && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"plan-details\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"left-column\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            children: [\n                                                \"Description: \",\n                                                plan.description\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 60,\n                                            columnNumber: 37\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            children: [\n                                                \"Weekly Price: \",\n                                                plan.weekly_price\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 61,\n                                            columnNumber: 37\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            children: [\n                                                \"Monthly Price: \",\n                                                plan.monthly_price\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 62,\n                                            columnNumber: 37\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            children: [\n                                                \"Yearly Price: \",\n                                                plan.yearly_price\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 63,\n                                            columnNumber: 37\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                    lineNumber: 59,\n                                    columnNumber: 33\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"right-column\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            onClick: (e)=>handlePayment(e, plan, \"weekly\"),\n                                            children: \"Select Weekly Plan\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 66,\n                                            columnNumber: 37\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            onClick: (e)=>handlePayment(e, plan, \"monthly\"),\n                                            children: \"Select Monthly Plan\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 67,\n                                            columnNumber: 37\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                            onClick: (e)=>handlePayment(e, plan, \"yearly\"),\n                                            children: \"Select Yearly Plan\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                            lineNumber: 68,\n                                            columnNumber: 37\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                                    lineNumber: 65,\n                                    columnNumber: 33\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                            lineNumber: 58,\n                            columnNumber: 29\n                        }, undefined)\n                    ]\n                }, plan.id, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n                    lineNumber: 55,\n                    columnNumber: 21\n                }, undefined))\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n            lineNumber: 53,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\subscription_plans\\\\page.js\",\n        lineNumber: 52,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Payment, \"/FNhmQHtC8bphHXTPuWxRuju/M0=\");\n_c = Payment;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Payment);\nvar _c;\n$RefreshReg$(_c, \"Payment\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3Vic2NyaXB0aW9uX3BsYW5zL3BhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFJaUM7QUFDQSxDQUFDLGlCQUFpQjtBQUNOO0FBQ1k7QUFDTjtBQUNyQjtBQUU5QixNQUFNSSxVQUFVOztJQUNaLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdILCtEQUFXQSxDQUFDO1FBQUVJLFlBQVk7SUFBTztJQUMzRCxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdKLHlEQUFRQSxDQUFDO1FBQUVHLFlBQVk7SUFBTztJQUU1RCxNQUFNLENBQUNFLFFBQVFDLFVBQVUsR0FBR1QsK0NBQVFBLENBQUMsRUFBRTtJQUN2QyxNQUFNLENBQUNVLFFBQVFDLFVBQVUsR0FBR1gsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDWSxjQUFjQyxnQkFBZ0IsR0FBR2IsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDYyxVQUFVQyxZQUFZLEdBQUdmLCtDQUFRQSxDQUFDLE9BQU8scUJBQXFCO0lBRXJFLE1BQU1nQixnQkFBZ0IsT0FBT0MsT0FBT0MsTUFBTUM7UUFDdENGLE1BQU1HLGNBQWM7UUFDcEJMLFlBQVlJLE9BQU8sdUVBQXVFO1FBRTFGLHNDQUFzQztRQUN0QyxNQUFNRSxhQUFhSCxLQUFLSSxJQUFJO1FBQzVCLE1BQU1DLHVCQUF1QkwsS0FBS00sRUFBRTtRQUVwQyw4QkFBOEI7UUFDOUIsSUFBSUM7UUFDSixJQUFJTixTQUFTLFVBQVU7WUFDbkJNLFNBQVNQLEtBQUtRLFlBQVk7UUFDOUIsT0FBTyxJQUFJUCxTQUFTLFdBQVc7WUFDM0JNLFNBQVNQLEtBQUtTLGFBQWE7UUFDL0IsT0FBTyxJQUFJUixTQUFTLFVBQVU7WUFDMUJNLFNBQVNQLEtBQUtVLFlBQVk7UUFDOUI7UUFFQSxNQUFNdkIsY0FBYztZQUNoQmdCO1lBQ0FRLFlBQVk7WUFDWko7WUFDQUY7WUFDQWQ7WUFDQUU7UUFDSjtJQUNKO0lBRUEsTUFBTW1CLFlBQVl2QixvQkFBb0J3QixPQUFPQyxNQUFNLENBQUN6QixxQkFBcUIsRUFBRTtJQUUzRSxxQkFDSSw4REFBQzBCO2tCQUNHLDRFQUFDQTtZQUFJQyxXQUFVO3NCQUNWSixVQUFVSyxHQUFHLENBQUNqQixDQUFBQSxxQkFDWCw4REFBQ2U7b0JBQUlDLFdBQVU7O3NDQUNYLDhEQUFDRTs0QkFBR0MsU0FBUyxJQUFNeEIsZ0JBQWdCSztzQ0FBUUEsS0FBS0ksSUFBSTs7Ozs7O3dCQUNuRFYsZ0JBQWdCQSxhQUFhWSxFQUFFLEtBQUtOLEtBQUtNLEVBQUUsa0JBQ3hDLDhEQUFDUzs0QkFBSUMsV0FBVTs7OENBQ1gsOERBQUNEO29DQUFJQyxXQUFVOztzREFDWCw4REFBQ0k7O2dEQUFFO2dEQUFjcEIsS0FBS3FCLFdBQVc7Ozs7Ozs7c0RBQ2pDLDhEQUFDRDs7Z0RBQUU7Z0RBQWVwQixLQUFLUSxZQUFZOzs7Ozs7O3NEQUNuQyw4REFBQ1k7O2dEQUFFO2dEQUFnQnBCLEtBQUtTLGFBQWE7Ozs7Ozs7c0RBQ3JDLDhEQUFDVzs7Z0RBQUU7Z0RBQWVwQixLQUFLVSxZQUFZOzs7Ozs7Ozs7Ozs7OzhDQUV2Qyw4REFBQ0s7b0NBQUlDLFdBQVU7O3NEQUNYLDhEQUFDakMsMERBQU1BOzRDQUFDb0MsU0FBUyxDQUFDRyxJQUFNeEIsY0FBY3dCLEdBQUd0QixNQUFNO3NEQUFXOzs7Ozs7c0RBQzFELDhEQUFDakIsMERBQU1BOzRDQUFDb0MsU0FBUyxDQUFDRyxJQUFNeEIsY0FBY3dCLEdBQUd0QixNQUFNO3NEQUFZOzs7Ozs7c0RBQzNELDhEQUFDakIsMERBQU1BOzRDQUFDb0MsU0FBUyxDQUFDRyxJQUFNeEIsY0FBY3dCLEdBQUd0QixNQUFNO3NEQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQWJwQ0EsS0FBS00sRUFBRTs7Ozs7Ozs7Ozs7Ozs7O0FBc0JqRTtHQWpFTXBCO0tBQUFBO0FBbUVOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvc3Vic2NyaXB0aW9uX3BsYW5zL3BhZ2UuanM/N2YxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IFwiLi4vLi4vc3R5bGVzL3RpbmRlci5jc3NcIjsgLy8gSW1wb3J0IHThu4dwIENTU1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQnV0dG9uJztcclxuaW1wb3J0IHsgdXNlclBheW1lbnQgfSBmcm9tICcuLi8uLi8uLi9zcmMvaG9va3MvcGF5bWVudCc7XHJcbmltcG9ydCB7IHVzZXJQbGFuIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2hvb2tzL3BsYW4nO1xyXG5pbXBvcnQgJy4uLy4uL3N0eWxlcy9wbGFuLmNzcydcclxuXHJcbmNvbnN0IFBheW1lbnQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHZucGF5X3BheW1lbnQgfSA9IHVzZXJQYXltZW50KHsgbWlkZGxld2FyZTogJ2F1dGgnIH0pO1xyXG4gICAgY29uc3QgeyBzdWJzY3JpcHRpb25QbGFucyB9ID0gdXNlclBsYW4oeyBtaWRkbGV3YXJlOiAnYXV0aCcgfSk7XHJcblxyXG4gICAgY29uc3QgW2Vycm9ycywgc2V0RXJyb3JzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtzZWxlY3RlZFBsYW4sIHNldFNlbGVjdGVkUGxhbl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwbGFuVHlwZSwgc2V0UGxhblR5cGVdID0gdXNlU3RhdGUobnVsbCk7IC8vIFRow6ptIGJp4bq/biBwbGFuVHlwZVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZVBheW1lbnQgPSBhc3luYyAoZXZlbnQsIHBsYW4sIHR5cGUpID0+IHsgLy8gVGjDqm0gdGhhbSBz4buRIHR5cGUgdsOgbyBow6BtIGhhbmRsZVBheW1lbnRcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldFBsYW5UeXBlKHR5cGUpOyAvLyBD4bqtcCBuaOG6rXQgZ2nDoSB0cuG7iyBj4bunYSBiaeG6v24gcGxhblR5cGUga2hpIG5nxrDhu51pIGTDuW5nIGNo4buNbiBsb+G6oWkga+G6vyBob+G6oWNoXHJcblxyXG4gICAgICAgIC8vIEzhuqV5IHRow7RuZyB0aW4gdOG7qyBr4bq/IGhv4bqhY2ggxJHGsOG7o2MgY2jhu41uXHJcbiAgICAgICAgY29uc3Qgb3JkZXJfaW5mbyA9IHBsYW4ubmFtZTtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25fcGxhbl9pZCA9IHBsYW4uaWQ7XHJcblxyXG4gICAgICAgIC8vIENo4buNbiBnacOhIHRoZW8gbG/huqFpIGvhur8gaG/huqFjaFxyXG4gICAgICAgIGxldCBhbW91bnQ7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICd3ZWVrbHknKSB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IHBsYW4ud2Vla2x5X3ByaWNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vbnRobHknKSB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IHBsYW4ubW9udGhseV9wcmljZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd5ZWFybHknKSB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IHBsYW4ueWVhcmx5X3ByaWNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdm5wYXlfcGF5bWVudCh7IFxyXG4gICAgICAgICAgICBvcmRlcl9pbmZvLFxyXG4gICAgICAgICAgICBvcmRlcl90eXBlOiAnd2VlaycsIC8vIFVwZGF0ZSBvcmRlcl90eXBlXHJcbiAgICAgICAgICAgIGFtb3VudCxcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uX3BsYW5faWQsXHJcbiAgICAgICAgICAgIHNldEVycm9ycyxcclxuICAgICAgICAgICAgc2V0U3RhdHVzIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBQbGFuQXJyYXkgPSBzdWJzY3JpcHRpb25QbGFucyA/IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uUGxhbnMpIDogW107XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBheW1lbnQtY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICB7UGxhbkFycmF5Lm1hcChwbGFuID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBheW1lbnQtZGV0YWlsc1wiIGtleT17cGxhbi5pZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMyBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZFBsYW4ocGxhbil9PntwbGFuLm5hbWV9PC9oMz5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3NlbGVjdGVkUGxhbiAmJiBzZWxlY3RlZFBsYW4uaWQgPT09IHBsYW4uaWQgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwbGFuLWRldGFpbHNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxlZnQtY29sdW1uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPkRlc2NyaXB0aW9uOiB7cGxhbi5kZXNjcmlwdGlvbn08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPldlZWtseSBQcmljZToge3BsYW4ud2Vla2x5X3ByaWNlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+TW9udGhseSBQcmljZToge3BsYW4ubW9udGhseV9wcmljZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlllYXJseSBQcmljZToge3BsYW4ueWVhcmx5X3ByaWNlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJpZ2h0LWNvbHVtblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eyhlKSA9PiBoYW5kbGVQYXltZW50KGUsIHBsYW4sICd3ZWVrbHknKX0+U2VsZWN0IFdlZWtseSBQbGFuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17KGUpID0+IGhhbmRsZVBheW1lbnQoZSwgcGxhbiwgJ21vbnRobHknKX0+U2VsZWN0IE1vbnRobHkgUGxhbjwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eyhlKSA9PiBoYW5kbGVQYXltZW50KGUsIHBsYW4sICd5ZWFybHknKX0+U2VsZWN0IFllYXJseSBQbGFuPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBheW1lbnQ7Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwiQnV0dG9uIiwidXNlclBheW1lbnQiLCJ1c2VyUGxhbiIsIlBheW1lbnQiLCJ2bnBheV9wYXltZW50IiwibWlkZGxld2FyZSIsInN1YnNjcmlwdGlvblBsYW5zIiwiZXJyb3JzIiwic2V0RXJyb3JzIiwic3RhdHVzIiwic2V0U3RhdHVzIiwic2VsZWN0ZWRQbGFuIiwic2V0U2VsZWN0ZWRQbGFuIiwicGxhblR5cGUiLCJzZXRQbGFuVHlwZSIsImhhbmRsZVBheW1lbnQiLCJldmVudCIsInBsYW4iLCJ0eXBlIiwicHJldmVudERlZmF1bHQiLCJvcmRlcl9pbmZvIiwibmFtZSIsInN1YnNjcmlwdGlvbl9wbGFuX2lkIiwiaWQiLCJhbW91bnQiLCJ3ZWVrbHlfcHJpY2UiLCJtb250aGx5X3ByaWNlIiwieWVhcmx5X3ByaWNlIiwib3JkZXJfdHlwZSIsIlBsYW5BcnJheSIsIk9iamVjdCIsInZhbHVlcyIsImRpdiIsImNsYXNzTmFtZSIsIm1hcCIsImgzIiwib25DbGljayIsInAiLCJkZXNjcmlwdGlvbiIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/subscription_plans/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/tinder/Loading.js":
/*!***********************************!*\
  !*** ./src/app/tinder/Loading.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Loading = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-center bg-pink-100 rounded-full\",\n        children: \"Loading...\"\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Loading.js\",\n        lineNumber: 3,\n        columnNumber: 9\n    }, undefined);\n};\n_c = Loading;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loading);\nvar _c;\n$RefreshReg$(_c, \"Loading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGluZGVyL0xvYWRpbmcuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsTUFBTUEsVUFBVTtJQUNaLHFCQUNJLDhEQUFDQztRQUFJQyxXQUFVO2tCQUE0RDs7Ozs7O0FBSW5GO0tBTk1GO0FBUU4sK0RBQWVBLE9BQU9BLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC90aW5kZXIvTG9hZGluZy5qcz9mN2QxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IExvYWRpbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1waW5rLTEwMCByb3VuZGVkLWZ1bGxcIj5cbiAgICAgICAgICAgIExvYWRpbmcuLi5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2FkaW5nXG4iXSwibmFtZXMiOlsiTG9hZGluZyIsImRpdiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/tinder/Loading.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/tinder/Navigation.js":
/*!**************************************!*\
  !*** ./src/app/tinder/Navigation.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_tinder_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../styles/tinder.css */ \"(app-pages-browser)/./src/styles/tinder.css\");\n/* harmony import */ var _src_hooks_profiles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/hooks/profiles */ \"(app-pages-browser)/./src/hooks/profiles.js\");\n/* harmony import */ var _users_page__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../users/page */ \"(app-pages-browser)/./src/app/users/page.js\");\n/* harmony import */ var _styles_dashboard_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../styles/dashboard.css */ \"(app-pages-browser)/./src/styles/dashboard.css\");\n/* harmony import */ var _app_tinder_Loading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../app/tinder/Loading */ \"(app-pages-browser)/./src/app/tinder/Loading.js\");\n\n\n\n // Import tệp CSS\n\n\n\n\n// Define the Header component\nconst Navigation = ()=>{\n    const { getFirstNameAndFirstImage } = (0,_src_hooks_profiles__WEBPACK_IMPORTED_MODULE_4__.userProfiles)({\n        middleware: \"auth\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"header\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"header-container\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"user-profile\",\n                    children: [\n                        getFirstNameAndFirstImage ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: \"http://127.0.0.1:8000/\".concat(getFirstNameAndFirstImage === null || getFirstNameAndFirstImage === void 0 ? void 0 : getFirstNameAndFirstImage.first_image_path),\n                            alt: \"profile.image_path\",\n                            className: \"rounded-image\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                            lineNumber: 17,\n                            columnNumber: 25\n                        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_tinder_Loading__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                            lineNumber: 19,\n                            columnNumber: 25\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"user-name\",\n                            children: getFirstNameAndFirstImage === null || getFirstNameAndFirstImage === void 0 ? void 0 : getFirstNameAndFirstImage.last_name\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                            lineNumber: 21,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                    lineNumber: 15,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                    href: \"/setting-profile\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Setting Profile\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                        lineNumber: 24,\n                        columnNumber: 21\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n                    lineNumber: 23,\n                    columnNumber: 17\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n            lineNumber: 14,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\Navigation.js\",\n        lineNumber: 13,\n        columnNumber: 9\n    }, undefined);\n};\n_c = Navigation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navigation);\nvar _c;\n$RefreshReg$(_c, \"Navigation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGluZGVyL05hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNkI7QUFDSTtBQUNBLENBQUMsaUJBQWlCO0FBQ1E7QUFDMUI7QUFDRTtBQUNXO0FBQzlDLDhCQUE4QjtBQUM5QixNQUFNSyxhQUFhO0lBQ2YsTUFBTSxFQUFFQyx5QkFBeUIsRUFBRSxHQUFHSixpRUFBWUEsQ0FBQztRQUFFSyxZQUFZO0lBQU87SUFFeEUscUJBQ0ksOERBQUNDO1FBQU9DLFdBQVU7a0JBQ2QsNEVBQUNDO1lBQUlELFdBQVU7OzhCQUNYLDhEQUFDQztvQkFBSUQsV0FBVTs7d0JBQ2RILDBDQUNPLDhEQUFDSzs0QkFBSUMsS0FBSyx5QkFBcUUsT0FBNUNOLHNDQUFBQSxnREFBQUEsMEJBQTJCTyxnQkFBZ0I7NEJBQUlDLEtBQUk7NEJBQXFCTCxXQUFVOzs7OztzREFFckgsOERBQUNMLDJEQUFPQTs7Ozs7c0NBRVosOERBQUNXOzRCQUFLTixXQUFVO3NDQUFhSCxzQ0FBQUEsZ0RBQUFBLDBCQUEyQlUsU0FBUzs7Ozs7Ozs7Ozs7OzhCQUVyRSw4REFBQ2hCLGlEQUFJQTtvQkFBQ2lCLE1BQU87OEJBQ1QsNEVBQUNDO2tDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS3ZCO0tBcEJNYjtBQXFCTiwrREFBZUEsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3RpbmRlci9OYXZpZ2F0aW9uLmpzPzZlMGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBcIi4uLy4uL3N0eWxlcy90aW5kZXIuY3NzXCI7IC8vIEltcG9ydCB04buHcCBDU1NcbmltcG9ydCB7IHVzZXJQcm9maWxlcyB9IGZyb20gJy4uLy4uLy4uL3NyYy9ob29rcy9wcm9maWxlcyc7XG5pbXBvcnQgTGlrZXMgZnJvbSBcIi4uL3VzZXJzL3BhZ2VcIlxuaW1wb3J0ICcuLi8uLi9zdHlsZXMvZGFzaGJvYXJkLmNzcydcbmltcG9ydCBMb2FkaW5nIGZyb20gJy4uLy4uL2FwcC90aW5kZXIvTG9hZGluZydcbi8vIERlZmluZSB0aGUgSGVhZGVyIGNvbXBvbmVudFxuY29uc3QgTmF2aWdhdGlvbiA9ICggKSA9PiB7XG4gICAgY29uc3QgeyBnZXRGaXJzdE5hbWVBbmRGaXJzdEltYWdlIH0gPSB1c2VyUHJvZmlsZXMoeyBtaWRkbGV3YXJlOiAnYXV0aCcgfSk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGhlYWRlciBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXNlci1wcm9maWxlXCI+XG4gICAgICAgICAgICAgICAge2dldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2UgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17YGh0dHA6Ly8xMjcuMC4wLjE6ODAwMC8ke2dldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2U/LmZpcnN0X2ltYWdlX3BhdGh9YH0gYWx0PSdwcm9maWxlLmltYWdlX3BhdGgnIGNsYXNzTmFtZT1cInJvdW5kZWQtaW1hZ2VcIiAvPlxuICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRpbmcgLz5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXNlci1uYW1lXCI+e2dldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2U/Lmxhc3RfbmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPExpbmsgaHJlZj17YC9zZXR0aW5nLXByb2ZpbGVgfSA+XG4gICAgICAgICAgICAgICAgICAgIDxwPlNldHRpbmcgUHJvZmlsZTwvcD5cbiAgICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9oZWFkZXI+XG4gICAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb247XG4iXSwibmFtZXMiOlsiTGluayIsInVzZVN0YXRlIiwidXNlclByb2ZpbGVzIiwiTGlrZXMiLCJMb2FkaW5nIiwiTmF2aWdhdGlvbiIsImdldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2UiLCJtaWRkbGV3YXJlIiwiaGVhZGVyIiwiY2xhc3NOYW1lIiwiZGl2IiwiaW1nIiwic3JjIiwiZmlyc3RfaW1hZ2VfcGF0aCIsImFsdCIsInNwYW4iLCJsYXN0X25hbWUiLCJocmVmIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/tinder/Navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/tinder/page.js":
/*!********************************!*\
  !*** ./src/app/tinder/page.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _recent_messages_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../recent-messages/page */ \"(app-pages-browser)/./src/app/recent-messages/page.js\");\n/* harmony import */ var _matching_page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../matching/page */ \"(app-pages-browser)/./src/app/matching/page.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _styles_tinder_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../styles/tinder.css */ \"(app-pages-browser)/./src/styles/tinder.css\");\n/* harmony import */ var _messages_id_page__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../messages/[id]/page */ \"(app-pages-browser)/./src/app/messages/[id]/page.js\");\n/* harmony import */ var _profile_id_page__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../profile/[id]/page */ \"(app-pages-browser)/./src/app/profile/[id]/page.js\");\n/* harmony import */ var _users_page__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../users/page */ \"(app-pages-browser)/./src/app/users/page.js\");\n/* harmony import */ var _app_tinder_Navigation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../app/tinder/Navigation */ \"(app-pages-browser)/./src/app/tinder/Navigation.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n // Import tệp CSS\n\n\n\n// import '../../styles/dashboard.css'\n\nconst Tinder = ()=>{\n    _s();\n    const [showMatching, setShowMatching] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const [selectedUserId, setSelectedUserId] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [likesStatus, setLikesStatus] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null); // State để lưu trữ status của likes\n    const [messageStatus, setMessageStatus] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // Load previous state from sessionStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const showMatchingState = sessionStorage.getItem(\"showMatching\");\n        if (showMatchingState !== null) {\n            setShowMatching(showMatchingState === \"true\");\n        }\n    }, []);\n    const toggleComponent = ()=>{\n        const newShowMatching = !showMatching;\n        setShowMatching(newShowMatching);\n        sessionStorage.setItem(\"showMatching\", newShowMatching.toString());\n    };\n    const handleUserSelect = (userId)=>{\n        setSelectedUserId(userId);\n        console.log(\"Selected User ID:\", userId);\n    };\n    const handleLikesStatusChange = (status)=>{\n        setLikesStatus(status); // Cập nhật status của likes từ component con\n        console.log(\"Likes Status:\", status); // Console log ra status của likes\n    };\n    const handleMessageStatusChange = (status)=>{\n        setMessageStatus(status); // Cập nhật status của Message từ component con\n        console.log(\"Message Status:\", status);\n    };\n    const handleMatchedUser = (matchedUser)=>{\n        // Xử lý thông tin về người dùng vừa được match\n        console.log(\"Matched User:\", matchedUser);\n    // Lưu thông tin người dùng vừa được match vào state hoặc thực hiện các hành động khác tùy ý\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-white  border-gray-200 containers\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"container-tinder\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_tinder_Navigation__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                    lineNumber: 55,\n                                    columnNumber: 29\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                                            className: \"nav\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                            className: showMatching ? \"active\" : \"\",\n                                                            onClick: toggleComponent,\n                                                            children: \"Show Matching\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                            lineNumber: 60,\n                                                            columnNumber: 45\n                                                        }, undefined)\n                                                    }, void 0, false, {\n                                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                        lineNumber: 59,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                            className: !showMatching ? \"active\" : \"\",\n                                                            onClick: toggleComponent,\n                                                            children: \"Show Messenger\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                            lineNumber: 63,\n                                                            columnNumber: 45\n                                                        }, undefined)\n                                                    }, void 0, false, {\n                                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                        lineNumber: 62,\n                                                        columnNumber: 41\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                lineNumber: 58,\n                                                columnNumber: 37\n                                            }, undefined)\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                            lineNumber: 57,\n                                            columnNumber: 33\n                                        }, undefined),\n                                        showMatching ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_matching_page__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                            onUserSelect: handleUserSelect,\n                                            messageStatus: messageStatus,\n                                            likesStatus: likesStatus\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                            lineNumber: 67,\n                                            columnNumber: 49\n                                        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_recent_messages_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                            onUserSelect: handleUserSelect,\n                                            messageStatus: messageStatus\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                            lineNumber: 67,\n                                            columnNumber: 152\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                    lineNumber: 56,\n                                    columnNumber: 29\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                            lineNumber: 54,\n                            columnNumber: 25\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"like\",\n                            children: selectedUserId ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"message-container\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"message-close\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_messages_id_page__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                                id: selectedUserId,\n                                                onStatusChange: handleMessageStatusChange\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                lineNumber: 73,\n                                                columnNumber: 67\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"close-button\",\n                                                onClick: ()=>setSelectedUserId(null),\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    \"aria-hidden\": \"true\",\n                                                    children: \"\\xd7\"\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                    lineNumber: 75,\n                                                    columnNumber: 41\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                lineNumber: 74,\n                                                columnNumber: 36\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                        lineNumber: 73,\n                                        columnNumber: 36\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            \" \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_profile_id_page__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                                id: selectedUserId\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                                lineNumber: 78,\n                                                columnNumber: 42\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                        lineNumber: 78,\n                                        columnNumber: 36\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                lineNumber: 72,\n                                columnNumber: 33\n                            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_users_page__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                onStatusChange: handleLikesStatusChange,\n                                onMatchedUser: handleMatchedUser\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                                lineNumber: 81,\n                                columnNumber: 36\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                            lineNumber: 70,\n                            columnNumber: 25\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                    lineNumber: 53,\n                    columnNumber: 21\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n                lineNumber: 52,\n                columnNumber: 17\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n            lineNumber: 51,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\tinder\\\\page.js\",\n        lineNumber: 50,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Tinder, \"SGTqYxO1zYovJhnrP4Polyg0mSw=\");\n_c = Tinder;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Tinder);\nvar _c;\n$RefreshReg$(_c, \"Tinder\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGluZGVyL3BhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUd5RDtBQUNqQjtBQUNHO0FBQ1YsQ0FBQyxpQkFBaUI7QUFDUDtBQUNKO0FBQ1A7QUFDakMsc0NBQXNDO0FBQ2M7QUFDcEQsTUFBTVEsU0FBUzs7SUFDWCxNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHUiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNTLGdCQUFnQkMsa0JBQWtCLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQ1csYUFBYUMsZUFBZSxHQUFHWiwrQ0FBUUEsQ0FBQyxPQUFPLG9DQUFvQztJQUMxRixNQUFNLENBQUNhLGVBQWVDLGlCQUFpQixHQUFHZCwrQ0FBUUEsQ0FBQztJQUNuRCwwQ0FBMEM7SUFDMUNDLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTWMsb0JBQW9CQyxlQUFlQyxPQUFPLENBQUM7UUFDakQsSUFBSUYsc0JBQXNCLE1BQU07WUFDNUJQLGdCQUFnQk8sc0JBQXNCO1FBQzFDO0lBQ0osR0FBRyxFQUFFO0lBRUwsTUFBTUcsa0JBQWtCO1FBQ3BCLE1BQU1DLGtCQUFrQixDQUFDWjtRQUN6QkMsZ0JBQWdCVztRQUNoQkgsZUFBZUksT0FBTyxDQUFDLGdCQUFnQkQsZ0JBQWdCRSxRQUFRO0lBQ25FO0lBRUUsTUFBTUMsbUJBQW1CLENBQUNDO1FBQ3RCYixrQkFBa0JhO1FBQ2xCQyxRQUFRQyxHQUFHLENBQUMscUJBQXFCRjtJQUNyQztJQUNBLE1BQU1HLDBCQUEwQixDQUFDQztRQUM3QmYsZUFBZWUsU0FBUyw2Q0FBNkM7UUFDckVILFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJFLFNBQVMsa0NBQWtDO0lBQzVFO0lBQ0EsTUFBTUMsNEJBQTRCLENBQUNEO1FBQy9CYixpQkFBaUJhLFNBQVMsK0NBQStDO1FBQ3pFSCxRQUFRQyxHQUFHLENBQUMsbUJBQW1CRTtJQUNqQztJQUNBLE1BQU1FLG9CQUFvQixDQUFDQztRQUN6QiwrQ0FBK0M7UUFDL0NOLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJLO0lBQzdCLDRGQUE0RjtJQUM5RjtJQUNGLHFCQUNJLDhEQUFDQztRQUFJQyxXQUFVO2tCQUNYLDRFQUFDRDtZQUFJQyxXQUFVO3NCQUNYLDRFQUFDRDtnQkFBSUMsV0FBVTswQkFDWCw0RUFBQ0Q7b0JBQUlDLFdBQVU7O3NDQUNYLDhEQUFDRDs0QkFBSUMsV0FBVTs7OENBQ1gsOERBQUMzQiw4REFBVUE7Ozs7OzhDQUNYLDhEQUFDMEI7O3NEQUNHLDhEQUFDRTs0Q0FBSUQsV0FBVTtzREFDWCw0RUFBQ0U7O2tFQUNHLDhEQUFDQztrRUFDRyw0RUFBQ0M7NERBQU9KLFdBQVd6QixlQUFlLFdBQVc7NERBQUk4QixTQUFTbkI7c0VBQWlCOzs7Ozs7Ozs7OztrRUFFL0UsOERBQUNpQjtrRUFDRyw0RUFBQ0M7NERBQU9KLFdBQVcsQ0FBQ3pCLGVBQWUsV0FBVzs0REFBSThCLFNBQVNuQjtzRUFBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBSXZGWCw2QkFBZSw4REFBQ1Isc0RBQVFBOzRDQUFDdUMsY0FBY2hCOzRDQUFtQlQsZUFBZUE7NENBQWVGLGFBQWFBOzs7OztzRUFBaUIsOERBQUNiLDZEQUFrQkE7NENBQUN3QyxjQUFjaEI7NENBQWtCVCxlQUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUdsTSw4REFBQ2tCOzRCQUFJQyxXQUFVO3NDQUNWdkIsK0JBQ0csOERBQUNzQjtnQ0FBS0MsV0FBVTs7a0RBQ2IsOERBQUNEO3dDQUFJQyxXQUFVOzswREFBZ0IsOERBQUM5Qix5REFBT0E7Z0RBQUNxQyxJQUFJOUI7Z0RBQWdCK0IsZ0JBQWdCWjs7Ozs7OzBEQUM1RSw4REFBQ1E7Z0RBQU9KLFdBQVU7Z0RBQWVLLFNBQVMsSUFBTTNCLGtCQUFrQjswREFDN0QsNEVBQUMrQjtvREFBS0MsZUFBWTs4REFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBRzlCLDhEQUFDWDs7NENBQUk7MERBQUMsOERBQUM1Qix3REFBSUE7Z0RBQUNvQyxJQUFJOUI7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQUdoQiw4REFBQ0wsbURBQUtBO2dDQUFDb0MsZ0JBQWdCZDtnQ0FBeUJpQixlQUFlZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPbEc7R0EzRU12QjtLQUFBQTtBQTZFTiwrREFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3RpbmRlci9wYWdlLmpzPzAxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcblwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IE1lc3NlbmdlckNvbXBvbmVudCBmcm9tIFwiLi4vcmVjZW50LW1lc3NhZ2VzL3BhZ2VcIjtcclxuaW1wb3J0IE1hdGNoaW5nIGZyb20gXCIuLi9tYXRjaGluZy9wYWdlXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlLHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgXCIuLi8uLi9zdHlsZXMvdGluZGVyLmNzc1wiOyAvLyBJbXBvcnQgdOG7h3AgQ1NTXHJcbmltcG9ydCBNZXNzYWdlIGZyb20gXCIuLi9tZXNzYWdlcy9baWRdL3BhZ2VcIjtcclxuaW1wb3J0IFVzZXIgZnJvbSBcIi4uL3Byb2ZpbGUvW2lkXS9wYWdlXCI7XHJcbmltcG9ydCBMaWtlcyBmcm9tIFwiLi4vdXNlcnMvcGFnZVwiXHJcbi8vIGltcG9ydCAnLi4vLi4vc3R5bGVzL2Rhc2hib2FyZC5jc3MnXHJcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uLy4uL2FwcC90aW5kZXIvTmF2aWdhdGlvbidcclxuY29uc3QgVGluZGVyID0gKCkgPT4ge1xyXG4gICAgY29uc3QgW3Nob3dNYXRjaGluZywgc2V0U2hvd01hdGNoaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gICAgY29uc3QgW3NlbGVjdGVkVXNlcklkLCBzZXRTZWxlY3RlZFVzZXJJZF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtsaWtlc1N0YXR1cywgc2V0TGlrZXNTdGF0dXNdID0gdXNlU3RhdGUobnVsbCk7IC8vIFN0YXRlIMSR4buDIGzGsHUgdHLhu68gc3RhdHVzIGPhu6dhIGxpa2VzXHJcbiAgICBjb25zdCBbbWVzc2FnZVN0YXR1cywgc2V0TWVzc2FnZVN0YXR1c10gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIC8vIExvYWQgcHJldmlvdXMgc3RhdGUgZnJvbSBzZXNzaW9uU3RvcmFnZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgY29uc3Qgc2hvd01hdGNoaW5nU3RhdGUgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwic2hvd01hdGNoaW5nXCIpO1xyXG4gICAgICBpZiAoc2hvd01hdGNoaW5nU3RhdGUgIT09IG51bGwpIHtcclxuICAgICAgICAgIHNldFNob3dNYXRjaGluZyhzaG93TWF0Y2hpbmdTdGF0ZSA9PT0gXCJ0cnVlXCIpO1xyXG4gICAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCB0b2dnbGVDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5ld1Nob3dNYXRjaGluZyA9ICFzaG93TWF0Y2hpbmc7XHJcbiAgICAgIHNldFNob3dNYXRjaGluZyhuZXdTaG93TWF0Y2hpbmcpO1xyXG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwic2hvd01hdGNoaW5nXCIsIG5ld1Nob3dNYXRjaGluZy50b1N0cmluZygpKTtcclxuICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVVzZXJTZWxlY3QgPSAodXNlcklkKSA9PiB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWRVc2VySWQodXNlcklkKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNlbGVjdGVkIFVzZXIgSUQ6XCIsIHVzZXJJZCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlTGlrZXNTdGF0dXNDaGFuZ2UgPSAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgc2V0TGlrZXNTdGF0dXMoc3RhdHVzKTsgLy8gQ+G6rXAgbmjhuq10IHN0YXR1cyBj4bunYSBsaWtlcyB04burIGNvbXBvbmVudCBjb25cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkxpa2VzIFN0YXR1czpcIiwgc3RhdHVzKTsgLy8gQ29uc29sZSBsb2cgcmEgc3RhdHVzIGPhu6dhIGxpa2VzXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlTWVzc2FnZVN0YXR1c0NoYW5nZSA9IChzdGF0dXMpID0+IHtcclxuICAgICAgICBzZXRNZXNzYWdlU3RhdHVzKHN0YXR1cyk7IC8vIEPhuq1wIG5o4bqtdCBzdGF0dXMgY+G7p2EgTWVzc2FnZSB04burIGNvbXBvbmVudCBjb25cclxuICAgICAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2UgU3RhdHVzOlwiLCBzdGF0dXMpO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBoYW5kbGVNYXRjaGVkVXNlciA9IChtYXRjaGVkVXNlcikgPT4ge1xyXG4gICAgICAgIC8vIFjhu60gbMO9IHRow7RuZyB0aW4gduG7gSBuZ8aw4budaSBkw7luZyB24burYSDEkcaw4bujYyBtYXRjaFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTWF0Y2hlZCBVc2VyOlwiLCBtYXRjaGVkVXNlcik7XHJcbiAgICAgICAgLy8gTMawdSB0aMO0bmcgdGluIG5nxrDhu51pIGTDuW5nIHbhu6thIMSRxrDhu6NjIG1hdGNoIHbDoG8gc3RhdGUgaG/hurdjIHRo4buxYyBoaeG7h24gY8OhYyBow6BuaCDEkeG7mW5nIGtow6FjIHTDuXkgw71cclxuICAgICAgfTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSAgYm9yZGVyLWdyYXktMjAwIGNvbnRhaW5lcnNcIj4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyLXRpbmRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdmlnYXRpb24vPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e3Nob3dNYXRjaGluZyA/IFwiYWN0aXZlXCIgOiBcIlwifSBvbkNsaWNrPXt0b2dnbGVDb21wb25lbnR9PlNob3cgTWF0Y2hpbmc8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9eyFzaG93TWF0Y2hpbmcgPyBcImFjdGl2ZVwiIDogXCJcIn0gb25DbGljaz17dG9nZ2xlQ29tcG9uZW50fT5TaG93IE1lc3NlbmdlcjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25hdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2hvd01hdGNoaW5nID8gPE1hdGNoaW5nIG9uVXNlclNlbGVjdD17aGFuZGxlVXNlclNlbGVjdH0gIG1lc3NhZ2VTdGF0dXM9e21lc3NhZ2VTdGF0dXN9IGxpa2VzU3RhdHVzPXtsaWtlc1N0YXR1c30vPiA6IDxNZXNzZW5nZXJDb21wb25lbnQgb25Vc2VyU2VsZWN0PXtoYW5kbGVVc2VyU2VsZWN0fSBtZXNzYWdlU3RhdHVzPXttZXNzYWdlU3RhdHVzfSAvPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaWtlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRVc2VySWQgPyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ICBjbGFzc05hbWU9XCJtZXNzYWdlLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZS1jbG9zZVwiPjxNZXNzYWdlIGlkPXtzZWxlY3RlZFVzZXJJZH0gb25TdGF0dXNDaGFuZ2U9e2hhbmRsZU1lc3NhZ2VTdGF0dXNDaGFuZ2V9IC8+IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiY2xvc2UtYnV0dG9uXCIgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRVc2VySWQobnVsbCl9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiA8VXNlciBpZD17c2VsZWN0ZWRVc2VySWR9IC8+PC9kaXY+ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgPExpa2VzIG9uU3RhdHVzQ2hhbmdlPXtoYW5kbGVMaWtlc1N0YXR1c0NoYW5nZX0gb25NYXRjaGVkVXNlcj17aGFuZGxlTWF0Y2hlZFVzZXJ9IC8+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaW5kZXI7Il0sIm5hbWVzIjpbIk1lc3NlbmdlckNvbXBvbmVudCIsIk1hdGNoaW5nIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJNZXNzYWdlIiwiVXNlciIsIkxpa2VzIiwiTmF2aWdhdGlvbiIsIlRpbmRlciIsInNob3dNYXRjaGluZyIsInNldFNob3dNYXRjaGluZyIsInNlbGVjdGVkVXNlcklkIiwic2V0U2VsZWN0ZWRVc2VySWQiLCJsaWtlc1N0YXR1cyIsInNldExpa2VzU3RhdHVzIiwibWVzc2FnZVN0YXR1cyIsInNldE1lc3NhZ2VTdGF0dXMiLCJzaG93TWF0Y2hpbmdTdGF0ZSIsInNlc3Npb25TdG9yYWdlIiwiZ2V0SXRlbSIsInRvZ2dsZUNvbXBvbmVudCIsIm5ld1Nob3dNYXRjaGluZyIsInNldEl0ZW0iLCJ0b1N0cmluZyIsImhhbmRsZVVzZXJTZWxlY3QiLCJ1c2VySWQiLCJjb25zb2xlIiwibG9nIiwiaGFuZGxlTGlrZXNTdGF0dXNDaGFuZ2UiLCJzdGF0dXMiLCJoYW5kbGVNZXNzYWdlU3RhdHVzQ2hhbmdlIiwiaGFuZGxlTWF0Y2hlZFVzZXIiLCJtYXRjaGVkVXNlciIsImRpdiIsImNsYXNzTmFtZSIsIm5hdiIsInVsIiwibGkiLCJidXR0b24iLCJvbkNsaWNrIiwib25Vc2VyU2VsZWN0IiwiaWQiLCJvblN0YXR1c0NoYW5nZSIsInNwYW4iLCJhcmlhLWhpZGRlbiIsIm9uTWF0Y2hlZFVzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/tinder/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/users/page.js":
/*!*******************************!*\
  !*** ./src/app/users/page.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _src_hooks_likes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/hooks/likes */ \"(app-pages-browser)/./src/hooks/likes.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/Button */ \"(app-pages-browser)/./src/components/Button.js\");\n/* harmony import */ var _components_Input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/Input */ \"(app-pages-browser)/./src/components/Input.js\");\n/* harmony import */ var _app_auth_AuthSessionStatus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../app/(auth)/AuthSessionStatus */ \"(app-pages-browser)/./src/app/(auth)/AuthSessionStatus.js\");\n/* harmony import */ var _components_InputError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/InputError */ \"(app-pages-browser)/./src/components/InputError.js\");\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./global.css */ \"(app-pages-browser)/./src/app/users/global.css\");\n/* harmony import */ var slick_carousel_slick_slick_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! slick-carousel/slick/slick.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\");\n/* harmony import */ var slick_carousel_slick_slick_theme_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! slick-carousel/slick/slick-theme.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\");\n/* harmony import */ var react_slick__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-slick */ \"(app-pages-browser)/./node_modules/react-slick/lib/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Không cần import './TinkerCard'; vì không sử dụng trong component này\n\n\n\nconst Likes = (param)=>{\n    let { onStatusChange, onMatchedUser } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const { users, error, createLike } = (0,_src_hooks_likes__WEBPACK_IMPORTED_MODULE_1__.userLikes)({\n        middleware: \"auth\",\n        redirectIfAuthenticated: \"/dashboard\"\n    });\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [currentLikedUser, setCurrentLikedUser] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (status === \"Match-created-successfully\") {\n            onStatusChange(\"\".concat(status, \" by \").concat(currentLikedUser ? currentLikedUser.id : \"\"));\n            if (currentLikedUser) {\n                onMatchedUser(currentLikedUser); // Gửi thông tin người dùng vừa được match lên component cha\n            }\n        }\n    }, [\n        status,\n        currentLikedUser,\n        onStatusChange,\n        onMatchedUser\n    ]);\n    const [likedUsers, setLikedUsers] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    // const [status, setStatus] = useState(null);\n    const [currentCardIndex, setCurrentCardIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(0); // Thêm state để theo dõi chỉ số của card hiện tại\n    const [showProfile, setShowProfile] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [showDetailButton, setShowDetailButton] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false); // State để kiểm soát việc hiển thị nút tắt thông tin chi tiết\n    // const [currentLikedUser, setCurrentLikedUser] = useState(null); // State để lưu trữ thông tin người dùng hiện tại đã thích\n    const [showDislikeText, setShowDislikeText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [showLikeText, setShowLikeText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (error) {\n            // Xử lý lỗi nếu có\n            console.error(\"Error:\", error.message);\n        }\n    }, [\n        error\n    ]);\n    const handleLike = async (liked_user)=>{\n        // setLikedUsers([...likedUsers, liked_user.id]);\n        setShowLikeText(true);\n        try {\n            // Thực hiện hành động like và xử lý lỗi nếu có\n            await createLike({\n                liked_user_id: liked_user.id,\n                setErrors,\n                setStatus\n            });\n            // Lưu toàn bộ thông tin của người dùng đã thích vào state\n            setCurrentLikedUser({\n                id: liked_user.id,\n                name: liked_user.name\n            });\n            // Sau khi like thành công, chuyển sang card tiếp theo (nếu có)\n            // console.log('Liked User:', liked_user);\n            setTimeout(()=>{\n                // Sau khi đã chờ 3 giây, chuyển trạng thái đang đợi về false và chuyển sang card tiếp theo\n                setShowLikeText(false);\n                setCurrentCardIndex(currentCardIndex + 1);\n            }, 1000);\n        } catch (error) {\n            console.error(\"Error:\", error.message);\n        }\n    };\n    const handleDislike = (liked_user_id)=>{\n        setShowDislikeText(true); // Hiển thị chữ \"Dislike\" khi dislike\n        // Xử lý hành động dislike\n        // Chuyển sang card tiếp theo (nếu có)\n        setTimeout(()=>{\n            // Sau khi đã chờ 3 giây, chuyển trạng thái đang đợi về false và chuyển sang card tiếp theo\n            setShowDislikeText(false); // Ẩn chữ \"Dislike\" sau khi đã chuyển sang card tiếp theo\n            setCurrentCardIndex(currentCardIndex + 1);\n        }, 1000);\n    };\n    const handleUserDetail = ()=>{\n        setShowProfile(true);\n        setShowDetailButton(true); // Hiển thị nút tắt thông tin chi tiết khi click vào \"View Details\"\n    };\n    const handleCloseDetail = ()=>{\n        setShowProfile(false);\n        setShowDetailButton(false); // Ẩn nút tắt thông tin chi tiết khi click vào nút đó\n    };\n    const settings = {\n        dots: true,\n        infinite: true,\n        speed: 500,\n        slidesToShow: 1,\n        slidesToScroll: 1\n    };\n    //  console.log(\"Đã like người dùng: \" + JSON.stringify(currentLikedUser));\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"frame\",\n        children: users ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                users.map((user, index)=>index === currentCardIndex && !likedUsers.includes(user.id) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"card\",\n                        children: [\n                            showDislikeText && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"dislike-text\",\n                                children: \"Dislike\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                lineNumber: 107,\n                                columnNumber: 37\n                            }, undefined),\n                            \" \",\n                            showLikeText && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"dislike-text\",\n                                children: \"Liked\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                lineNumber: 108,\n                                columnNumber: 34\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    user.profile && user.profile.image_path && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"Images:\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 112,\n                                                columnNumber: 23\n                                            }, undefined),\n                                            user.profile.image_path.includes(\",\") ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_slick__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                ...settings,\n                                                children: user.profile.image_path.split(\",\").map((image, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                        src: \"http://127.0.0.1:8000/\".concat(image),\n                                                        alt: \"Image \".concat(index),\n                                                        style: {\n                                                            maxWidth: \"300px\"\n                                                        }\n                                                    }, index, false, {\n                                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                        lineNumber: 116,\n                                                        columnNumber: 29\n                                                    }, undefined))\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 114,\n                                                columnNumber: 25\n                                            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: \"http://127.0.0.1:8000/\".concat(user.profile.image_path),\n                                                alt: \"Image\",\n                                                style: {\n                                                    maxWidth: \"300px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 125,\n                                                columnNumber: 25\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 111,\n                                        columnNumber: 21\n                                    }, undefined),\n                                    (!user.profile || !user.profile.image_path) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"Images:\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 136,\n                                                columnNumber: 23\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: \"/images/misc/user.png\" // Đường dẫn đến hình ảnh placeholder\n                                                ,\n                                                alt: \"Default Image\",\n                                                style: {\n                                                    maxWidth: \"300px\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 137,\n                                                columnNumber: 23\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 135,\n                                        columnNumber: 21\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"big-bold-text\",\n                                                children: user.name\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 145,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    \" \",\n                                                    user.email\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 146,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            showProfile && user.profile && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    \"Profile:\",\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                                children: [\n                                                                    \"Age: \",\n                                                                    user.profile.age\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                                lineNumber: 151,\n                                                                columnNumber: 27\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                                children: [\n                                                                    \"Gender: \",\n                                                                    user.profile.gender === 1 ? \"Male\" : \"Female\"\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                                lineNumber: 152,\n                                                                columnNumber: 27\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                        lineNumber: 150,\n                                                        columnNumber: 25\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 148,\n                                                columnNumber: 23\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 144,\n                                        columnNumber: 19\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"icons\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: \"/images/misc/like.png\",\n                                                alt: \"Like\",\n                                                onClick: ()=>handleLike(user)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 159,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: \"/images/misc/dislike.png\",\n                                                alt: \"Dislike\",\n                                                onClick: ()=>handleDislike(user.id)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                                lineNumber: 160,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 158,\n                                        columnNumber: 19\n                                    }, undefined),\n                                    showDetailButton ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                        onClick: handleCloseDetail,\n                                        children: \"Close Detail\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 163,\n                                        columnNumber: 21\n                                    }, undefined) // Nút tắt thông tin chi tiết\n                                     : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                        onClick: handleUserDetail,\n                                        children: \"View Details\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                        lineNumber: 165,\n                                        columnNumber: 21\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                                lineNumber: 109,\n                                columnNumber: 17\n                            }, undefined)\n                        ]\n                    }, user.id, true, {\n                        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                        lineNumber: 106,\n                        columnNumber: 15\n                    }, undefined) : null),\n                status && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        status,\n                        \" \",\n                        status && currentLikedUser && \"by \".concat(currentLikedUser.name)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n                    lineNumber: 172,\n                    columnNumber: 13\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n            lineNumber: 103,\n            columnNumber: 9\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n            lineNumber: 178,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\app\\\\users\\\\page.js\",\n        lineNumber: 101,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Likes, \"KNrBqPBNS/URemwDMf7LXUYzNK0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = Likes;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Likes);\nvar _c;\n$RefreshReg$(_c, \"Likes\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXNlcnMvcGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ3FEO0FBQ1Q7QUFDQTtBQUNDO0FBQ0Y7QUFDd0I7QUFDZDtBQUMvQjtBQUN0Qix3RUFBd0U7QUFDaEM7QUFDTTtBQUNiO0FBRWpDLE1BQU1TLFFBQVE7UUFBQyxFQUFFQyxjQUFjLEVBQUVDLGFBQWEsRUFBRzs7SUFDL0MsTUFBTUMsU0FBU1gsMERBQVNBO0lBRXhCLE1BQU0sRUFBRVksS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRSxHQUFHZiwyREFBU0EsQ0FBQztRQUM3Q2dCLFlBQVk7UUFDWkMseUJBQXlCO0lBQzNCO0lBQ0EsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNpQixrQkFBa0JDLG9CQUFvQixHQUFHbEIsK0NBQVFBLENBQUM7SUFFekRELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSWdCLFdBQVcsOEJBQThCO1lBQzNDUixlQUFlLEdBQWdCVSxPQUFiRixRQUFPLFFBQWtELE9BQTVDRSxtQkFBbUJBLGlCQUFpQkUsRUFBRSxHQUFHO1lBQ3hFLElBQUlGLGtCQUFrQjtnQkFDcEJULGNBQWNTLG1CQUFtQiw0REFBNEQ7WUFDL0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ0Y7UUFBUUU7UUFBa0JWO1FBQWdCQztLQUFjO0lBQzVELE1BQU0sQ0FBQ1ksWUFBWUMsY0FBYyxHQUFHckIsK0NBQVFBLENBQUMsRUFBRTtJQUMvQyxNQUFNLENBQUNzQixRQUFRQyxVQUFVLEdBQUd2QiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQ3ZDLDhDQUE4QztJQUM5QyxNQUFNLENBQUN3QixrQkFBa0JDLG9CQUFvQixHQUFHekIsK0NBQVFBLENBQUMsSUFBSSxrREFBa0Q7SUFDL0csTUFBTSxDQUFDMEIsYUFBYUMsZUFBZSxHQUFHM0IsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDNEIsa0JB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b0JBQW9CLE1BQTRCLE9BQXRCQSxpQkFBaUJzQixJQUFJOzs7Ozs7Ozs7Ozs7c0NBS3pFLDhEQUFDVztzQkFBSTs7Ozs7Ozs7Ozs7QUFJYjtHQXZLTTVDOztRQUNXUixzREFBU0E7OztLQURwQlE7QUF5S04sK0RBQWVBLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC91c2Vycy9wYWdlLmpzP2E0OTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5pbXBvcnQgeyB1c2VyTGlrZXMgfSBmcm9tICcuLi8uLi8uLi9zcmMvaG9va3MvbGlrZXMnO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQnV0dG9uJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvSW5wdXQnO1xyXG5pbXBvcnQgQXV0aFNlc3Npb25TdGF0dXMgZnJvbSAnLi4vLi4vYXBwLyhhdXRoKS9BdXRoU2Vzc2lvblN0YXR1cyc7XHJcbmltcG9ydCBJbnB1dEVycm9yIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvSW5wdXRFcnJvcic7XHJcbmltcG9ydCAnLi9nbG9iYWwuY3NzJztcclxuLy8gS2jDtG5nIGPhuqduIGltcG9ydCAnLi9UaW5rZXJDYXJkJzsgdsOsIGtow7RuZyBz4butIGThu6VuZyB0cm9uZyBjb21wb25lbnQgbsOgeVxyXG5pbXBvcnQgJ3NsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLmNzcyc7XHJcbmltcG9ydCAnc2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2stdGhlbWUuY3NzJztcclxuaW1wb3J0IFNsaWRlciBmcm9tICdyZWFjdC1zbGljayc7XHJcblxyXG5jb25zdCBMaWtlcyA9ICh7IG9uU3RhdHVzQ2hhbmdlLCBvbk1hdGNoZWRVc2VyICB9KSA9PiB7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcblxyXG4gIGNvbnN0IHsgdXNlcnMsIGVycm9yLCBjcmVhdGVMaWtlIH0gPSB1c2VyTGlrZXMoe1xyXG4gICAgbWlkZGxld2FyZTogJ2F1dGgnLFxyXG4gICAgcmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQ6ICcvZGFzaGJvYXJkJyxcclxuICB9KTtcclxuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgW2N1cnJlbnRMaWtlZFVzZXIsIHNldEN1cnJlbnRMaWtlZFVzZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiBcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHN0YXR1cyA9PT0gJ01hdGNoLWNyZWF0ZWQtc3VjY2Vzc2Z1bGx5Jykge1xyXG4gICAgICBvblN0YXR1c0NoYW5nZShgJHtzdGF0dXN9IGJ5ICR7Y3VycmVudExpa2VkVXNlciA/IGN1cnJlbnRMaWtlZFVzZXIuaWQgOiAnJ31gKTtcclxuICAgICAgaWYgKGN1cnJlbnRMaWtlZFVzZXIpIHtcclxuICAgICAgICBvbk1hdGNoZWRVc2VyKGN1cnJlbnRMaWtlZFVzZXIpOyAvLyBH4butaSB0aMO0bmcgdGluIG5nxrDhu51pIGTDuW5nIHbhu6thIMSRxrDhu6NjIG1hdGNoIGzDqm4gY29tcG9uZW50IGNoYVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW3N0YXR1cywgY3VycmVudExpa2VkVXNlciwgb25TdGF0dXNDaGFuZ2UsIG9uTWF0Y2hlZFVzZXJdKTtcclxuICBjb25zdCBbbGlrZWRVc2Vycywgc2V0TGlrZWRVc2Vyc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgY29uc3QgW2Vycm9ycywgc2V0RXJyb3JzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAvLyBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgW2N1cnJlbnRDYXJkSW5kZXgsIHNldEN1cnJlbnRDYXJkSW5kZXhdID0gdXNlU3RhdGUoMCk7IC8vIFRow6ptIHN0YXRlIMSR4buDIHRoZW8gZMO1aSBjaOG7iSBz4buRIGPhu6dhIGNhcmQgaGnhu4duIHThuqFpXHJcbiAgY29uc3QgW3Nob3dQcm9maWxlLCBzZXRTaG93UHJvZmlsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3Nob3dEZXRhaWxCdXR0b24sIHNldFNob3dEZXRhaWxCdXR0b25dID0gdXNlU3RhdGUoZmFsc2UpOyAvLyBTdGF0ZSDEkeG7gyBraeG7g20gc2/DoXQgdmnhu4djIGhp4buDbiB0aOG7iyBuw7p0IHThuq90IHRow7RuZyB0aW4gY2hpIHRp4bq/dFxyXG4gIC8vIGNvbnN0IFtjdXJyZW50TGlrZWRVc2VyLCBzZXRDdXJyZW50TGlrZWRVc2VyXSA9IHVzZVN0YXRlKG51bGwpOyAvLyBTdGF0ZSDEkeG7gyBsxrB1IHRy4buvIHRow7RuZyB0aW4gbmfGsOG7nWkgZMO5bmcgaGnhu4duIHThuqFpIMSRw6MgdGjDrWNoXHJcbiAgY29uc3QgW3Nob3dEaXNsaWtlVGV4dCwgc2V0U2hvd0Rpc2xpa2VUZXh0XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbc2hvd0xpa2VUZXh0LCBzZXRTaG93TGlrZVRleHRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgLy8gWOG7rSBsw70gbOG7l2kgbuG6v3UgY8OzXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjpcIiwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfSwgW2Vycm9yXSk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUxpa2UgPSBhc3luYyAobGlrZWRfdXNlcikgPT4ge1xyXG4gICAgLy8gc2V0TGlrZWRVc2VycyhbLi4ubGlrZWRVc2VycywgbGlrZWRfdXNlci5pZF0pO1xyXG4gICAgc2V0U2hvd0xpa2VUZXh0KHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGjhu7FjIGhp4buHbiBow6BuaCDEkeG7mW5nIGxpa2UgdsOgIHjhu60gbMO9IGzhu5dpIG7hur91IGPDs1xyXG4gICAgICBhd2FpdCBjcmVhdGVMaWtlKHsgbGlrZWRfdXNlcl9pZDogbGlrZWRfdXNlci5pZCwgc2V0RXJyb3JzLCBzZXRTdGF0dXMgfSk7XHJcbiAgICAgIC8vIEzGsHUgdG/DoG4gYuG7mSB0aMO0bmcgdGluIGPhu6dhIG5nxrDhu51pIGTDuW5nIMSRw6MgdGjDrWNoIHbDoG8gc3RhdGVcclxuICAgICAgc2V0Q3VycmVudExpa2VkVXNlcih7IGlkOiBsaWtlZF91c2VyLmlkLCBuYW1lOiBsaWtlZF91c2VyLm5hbWUgfSk7XHJcbiAgICAgIC8vIFNhdSBraGkgbGlrZSB0aMOgbmggY8O0bmcsIGNodXnhu4NuIHNhbmcgY2FyZCB0aeG6v3AgdGhlbyAobuG6v3UgY8OzKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZygnTGlrZWQgVXNlcjonLCBsaWtlZF91c2VyKTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgLy8gU2F1IGtoaSDEkcOjIGNo4budIDMgZ2nDonksIGNodXnhu4NuIHRy4bqhbmcgdGjDoWkgxJFhbmcgxJHhu6NpIHbhu4EgZmFsc2UgdsOgIGNodXnhu4NuIHNhbmcgY2FyZCB0aeG6v3AgdGhlb1xyXG4gICAgICAgIHNldFNob3dMaWtlVGV4dChmYWxzZSk7XHJcbiAgICAgICAgc2V0Q3VycmVudENhcmRJbmRleChjdXJyZW50Q2FyZEluZGV4ICsgMSk7XHJcbiAgICAgIH0sIDEwMDApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOlwiLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgY29uc3QgaGFuZGxlRGlzbGlrZSA9IChsaWtlZF91c2VyX2lkKSA9PiB7XHJcbiAgICBzZXRTaG93RGlzbGlrZVRleHQodHJ1ZSk7IC8vIEhp4buDbiB0aOG7iyBjaOG7ryBcIkRpc2xpa2VcIiBraGkgZGlzbGlrZVxyXG4gICAgLy8gWOG7rSBsw70gaMOgbmggxJHhu5luZyBkaXNsaWtlXHJcbiAgICAvLyBDaHV54buDbiBzYW5nIGNhcmQgdGnhur9wIHRoZW8gKG7hur91IGPDsylcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAvLyBTYXUga2hpIMSRw6MgY2jhu50gMyBnacOieSwgY2h1eeG7g24gdHLhuqFuZyB0aMOhaSDEkWFuZyDEkeG7o2kgduG7gSBmYWxzZSB2w6AgY2h1eeG7g24gc2FuZyBjYXJkIHRp4bq/cCB0aGVvXHJcbiAgICAgIHNldFNob3dEaXNsaWtlVGV4dChmYWxzZSk7IC8vIOG6qG4gY2jhu68gXCJEaXNsaWtlXCIgc2F1IGtoaSDEkcOjIGNodXnhu4NuIHNhbmcgY2FyZCB0aeG6v3AgdGhlb1xyXG4gICAgICBzZXRDdXJyZW50Q2FyZEluZGV4KGN1cnJlbnRDYXJkSW5kZXggKyAxKTtcclxuICAgIH0sIDEwMDApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVzZXJEZXRhaWwgPSAoKSA9PiB7XHJcbiAgICBzZXRTaG93UHJvZmlsZSh0cnVlKTtcclxuICAgIHNldFNob3dEZXRhaWxCdXR0b24odHJ1ZSk7IC8vIEhp4buDbiB0aOG7iyBuw7p0IHThuq90IHRow7RuZyB0aW4gY2hpIHRp4bq/dCBraGkgY2xpY2sgdsOgbyBcIlZpZXcgRGV0YWlsc1wiXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlQ2xvc2VEZXRhaWwgPSAoKSA9PiB7XHJcbiAgICBzZXRTaG93UHJvZmlsZShmYWxzZSk7XHJcbiAgICBzZXRTaG93RGV0YWlsQnV0dG9uKGZhbHNlKTsgLy8g4bqobiBuw7p0IHThuq90IHRow7RuZyB0aW4gY2hpIHRp4bq/dCBraGkgY2xpY2sgdsOgbyBuw7p0IMSRw7NcclxuICB9O1xyXG5cclxuICBjb25zdCBzZXR0aW5ncyA9IHtcclxuICAgIGRvdHM6IHRydWUsXHJcbiAgICBpbmZpbml0ZTogdHJ1ZSxcclxuICAgIHNwZWVkOiA1MDAsXHJcbiAgICBzbGlkZXNUb1Nob3c6IDEsXHJcbiAgICBzbGlkZXNUb1Njcm9sbDogMVxyXG4gIH07XHJcbiAgLy8gIGNvbnNvbGUubG9nKFwixJDDoyBsaWtlIG5nxrDhu51pIGTDuW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaWtlZFVzZXIpKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZnJhbWVcIj5cclxuICAgICAge3VzZXJzID8gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICB7dXNlcnMubWFwKCh1c2VyLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICBpbmRleCA9PT0gY3VycmVudENhcmRJbmRleCAmJiAhbGlrZWRVc2Vycy5pbmNsdWRlcyh1c2VyLmlkKSA/ICggLy8gQ2jhu4kgaGnhu4NuIHRo4buLIGNhcmQgaGnhu4duIHThuqFpXHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCIga2V5PXt1c2VyLmlkfT5cclxuICAgICAgICAgICAgICAgIHtzaG93RGlzbGlrZVRleHQgJiYgPGRpdiBjbGFzc05hbWU9XCJkaXNsaWtlLXRleHRcIj5EaXNsaWtlPC9kaXY+fSB7LyogSGnhu4NuIHRo4buLIGNo4buvIFwiRGlzbGlrZVwiICovfVxyXG4gICAgICAgICAgICAgICAge3Nob3dMaWtlVGV4dCAmJiA8ZGl2IGNsYXNzTmFtZT1cImRpc2xpa2UtdGV4dFwiPkxpa2VkPC9kaXY+fVxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge3VzZXIucHJvZmlsZSAmJiB1c2VyLnByb2ZpbGUuaW1hZ2VfcGF0aCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxwPkltYWdlczo8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7dXNlci5wcm9maWxlLmltYWdlX3BhdGguaW5jbHVkZXMoJywnKSA/IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPFNsaWRlciB7Li4uc2V0dGluZ3N9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt1c2VyLnByb2ZpbGUuaW1hZ2VfcGF0aC5zcGxpdCgnLCcpLm1hcCgoaW1hZ2UsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17YGh0dHA6Ly8xMjcuMC4wLjE6ODAwMC8ke2ltYWdlfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17YEltYWdlICR7aW5kZXh9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWF4V2lkdGg6ICczMDBweCcgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU2xpZGVyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17YGh0dHA6Ly8xMjcuMC4wLjE6ODAwMC8ke3VzZXIucHJvZmlsZS5pbWFnZV9wYXRofWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiSW1hZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IG1heFdpZHRoOiAnMzAwcHgnIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApfVxyXG5cclxuICAgICAgICAgICAgICAgICAgeyghdXNlci5wcm9maWxlIHx8ICF1c2VyLnByb2ZpbGUuaW1hZ2VfcGF0aCkgJiYgKCAvLyBUaMOqbSDEkWnhu4F1IGtp4buHbiBraeG7g20gdHJhIG7hur91IGtow7RuZyBjw7Mg4bqjbmhcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgPHA+SW1hZ2VzOjwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjPVwiL2ltYWdlcy9taXNjL3VzZXIucG5nXCIgLy8gxJDGsOG7nW5nIGThuqtuIMSR4bq/biBow6xuaCDhuqNuaCBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHQ9XCJEZWZhdWx0IEltYWdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWF4V2lkdGg6ICczMDBweCcgfX1cclxuICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmlnLWJvbGQtdGV4dFwiPnt1c2VyLm5hbWV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdj4ge3VzZXIuZW1haWx9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge3Nob3dQcm9maWxlICYmIHVzZXIucHJvZmlsZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9maWxlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkFnZToge3VzZXIucHJvZmlsZS5hZ2V9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+R2VuZGVyOiB7dXNlci5wcm9maWxlLmdlbmRlciA9PT0gMSA/IFwiTWFsZVwiIDogXCJGZW1hbGVcIn08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBBZGQgYWRkaXRpb25hbCBmaWVsZHMgYXMgbmVlZGVkICovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaWNvbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIi9pbWFnZXMvbWlzYy9saWtlLnBuZ1wiIGFsdD1cIkxpa2VcIiBvbkNsaWNrPXsoKSA9PiBoYW5kbGVMaWtlKHVzZXIpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL2ltYWdlcy9taXNjL2Rpc2xpa2UucG5nXCIgYWx0PVwiRGlzbGlrZVwiIG9uQ2xpY2s9eygpID0+IGhhbmRsZURpc2xpa2UodXNlci5pZCl9IC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7c2hvd0RldGFpbEJ1dHRvbiA/IChcclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2hhbmRsZUNsb3NlRGV0YWlsfT5DbG9zZSBEZXRhaWw8L0J1dHRvbj4gLy8gTsO6dCB04bqvdCB0aMO0bmcgdGluIGNoaSB0aeG6v3RcclxuICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVVzZXJEZXRhaWx9PlZpZXcgRGV0YWlsczwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICkgOiBudWxsXHJcbiAgICAgICAgICApKX1cclxuICAgICAgICAgIHtzdGF0dXMgJiYgKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgIHtzdGF0dXN9IHtzdGF0dXMgJiYgY3VycmVudExpa2VkVXNlciAmJiBgYnkgJHtjdXJyZW50TGlrZWRVc2VyLm5hbWV9YH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApIDogKFxyXG4gICAgICAgIDxkaXY+TG9hZGluZy4uLjwvZGl2PlxyXG4gICAgICApfVxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpa2VzOyJdLCJuYW1lcyI6WyJ1c2VyTGlrZXMiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkJ1dHRvbiIsIklucHV0IiwiQXV0aFNlc3Npb25TdGF0dXMiLCJJbnB1dEVycm9yIiwiU2xpZGVyIiwiTGlrZXMiLCJvblN0YXR1c0NoYW5nZSIsIm9uTWF0Y2hlZFVzZXIiLCJyb3V0ZXIiLCJ1c2VycyIsImVycm9yIiwiY3JlYXRlTGlrZSIsIm1pZGRsZXdhcmUiLCJyZWRpcmVjdElmQXV0aGVudGljYXRlZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImN1cnJlbnRMaWtlZFVzZXIiLCJzZXRDdXJyZW50TGlrZWRVc2VyIiwiaWQiLCJsaWtlZFVzZXJzIiwic2V0TGlrZWRVc2VycyIsImVycm9ycyIsInNldEVycm9ycyIsImN1cnJlbnRDYXJkSW5kZXgiLCJzZXRDdXJyZW50Q2FyZEluZGV4Iiwic2hvd1Byb2ZpbGUiLCJzZXRTaG93UHJvZmlsZSIsInNob3dEZXRhaWxCdXR0b24iLCJzZXRTaG93RGV0YWlsQnV0dG9uIiwic2hvd0Rpc2xpa2VUZXh0Iiwic2V0U2hvd0Rpc2xpa2VUZXh0Iiwic2hvd0xpa2VUZXh0Iiwic2V0U2hvd0xpa2VUZXh0IiwiY29uc29sZSIsIm1lc3NhZ2UiLCJoYW5kbGVMaWtlIiwibGlrZWRfdXNlciIsImxpa2VkX3VzZXJfaWQiLCJuYW1lIiwic2V0VGltZW91dCIsImhhbmRsZURpc2xpa2UiLCJoYW5kbGVVc2VyRGV0YWlsIiwiaGFuZGxlQ2xvc2VEZXRhaWwiLCJzZXR0aW5ncyIsImRvdHMiLCJpbmZpbml0ZSIsInNwZWVkIiwic2xpZGVzVG9TaG93Iiwic2xpZGVzVG9TY3JvbGwiLCJkaXYiLCJjbGFzc05hbWUiLCJtYXAiLCJ1c2VyIiwiaW5kZXgiLCJpbmNsdWRlcyIsInByb2ZpbGUiLCJpbWFnZV9wYXRoIiwicCIsInNwbGl0IiwiaW1hZ2UiLCJpbWciLCJzcmMiLCJhbHQiLCJzdHlsZSIsIm1heFdpZHRoIiwiZW1haWwiLCJ1bCIsImxpIiwiYWdlIiwiZ2VuZGVyIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/users/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Button.js":
/*!**********************************!*\
  !*** ./src/components/Button.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Button = (param)=>{\n    let { type = \"submit\", className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        type: type,\n        className: \"\".concat(className, \" inline-flex items-center px-4 py-2 bg-gray-800 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-gray-700 active:bg-gray-900 focus:outline-none focus:border-gray-900 focus:ring ring-gray-300 disabled:opacity-25 transition ease-in-out duration-150\"),\n        ...props\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\components\\\\Button.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Button;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Button);\nvar _c;\n$RefreshReg$(_c, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0J1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxNQUFNQSxTQUFTO1FBQUMsRUFBRUMsT0FBTyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO3lCQUNwRCw4REFBQ0M7UUFDR0gsTUFBTUE7UUFDTkMsV0FBVyxHQUFhLE9BQVZBLFdBQVU7UUFDdkIsR0FBR0MsS0FBSzs7Ozs7OztLQUpYSDtBQVFOLCtEQUFlQSxNQUFNQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0J1dHRvbi5qcz81MGE0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJ1dHRvbiA9ICh7IHR5cGUgPSAnc3VibWl0JywgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSA9PiAoXG4gICAgPGJ1dHRvblxuICAgICAgICB0eXBlPXt0eXBlfVxuICAgICAgICBjbGFzc05hbWU9e2Ake2NsYXNzTmFtZX0gaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHB4LTQgcHktMiBiZy1ncmF5LTgwMCBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHJvdW5kZWQtbWQgZm9udC1zZW1pYm9sZCB0ZXh0LXhzIHRleHQtd2hpdGUgdXBwZXJjYXNlIHRyYWNraW5nLXdpZGVzdCBob3ZlcjpiZy1ncmF5LTcwMCBhY3RpdmU6YmctZ3JheS05MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJvcmRlci1ncmF5LTkwMCBmb2N1czpyaW5nIHJpbmctZ3JheS0zMDAgZGlzYWJsZWQ6b3BhY2l0eS0yNSB0cmFuc2l0aW9uIGVhc2UtaW4tb3V0IGR1cmF0aW9uLTE1MGB9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAvPlxuKVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25cbiJdLCJuYW1lcyI6WyJCdXR0b24iLCJ0eXBlIiwiY2xhc3NOYW1lIiwicHJvcHMiLCJidXR0b24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Button.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Input.js":
/*!*********************************!*\
  !*** ./src/components/Input.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst Input = (param)=>{\n    let { disabled = false, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n        disabled: disabled,\n        className: \"\".concat(className, \" rounded-md shadow-sm border-gray-300 focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50\"),\n        ...props\n    }, void 0, false, {\n        fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\components\\\\Input.js\",\n        lineNumber: 2,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Input;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Input);\nvar _c;\n$RefreshReg$(_c, \"Input\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0lucHV0LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLE1BQU1BLFFBQVE7UUFBQyxFQUFFQyxXQUFXLEtBQUssRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87eUJBQ3BELDhEQUFDQztRQUNHSCxVQUFVQTtRQUNWQyxXQUFXLEdBQWEsT0FBVkEsV0FBVTtRQUN2QixHQUFHQyxLQUFLOzs7Ozs7O0tBSlhIO0FBUU4sK0RBQWVBLEtBQUtBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSW5wdXQuanM/NzUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJbnB1dCA9ICh7IGRpc2FibGVkID0gZmFsc2UsIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkgPT4gKFxuICAgIDxpbnB1dFxuICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgIGNsYXNzTmFtZT17YCR7Y2xhc3NOYW1lfSByb3VuZGVkLW1kIHNoYWRvdy1zbSBib3JkZXItZ3JheS0zMDAgZm9jdXM6Ym9yZGVyLWluZGlnby0zMDAgZm9jdXM6cmluZyBmb2N1czpyaW5nLWluZGlnby0yMDAgZm9jdXM6cmluZy1vcGFjaXR5LTUwYH1cbiAgICAgICAgey4uLnByb3BzfVxuICAgIC8+XG4pXG5cbmV4cG9ydCBkZWZhdWx0IElucHV0XG4iXSwibmFtZXMiOlsiSW5wdXQiLCJkaXNhYmxlZCIsImNsYXNzTmFtZSIsInByb3BzIiwiaW5wdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Input.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/InputError.js":
/*!**************************************!*\
  !*** ./src/components/InputError.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst InputError = (param)=>{\n    let { messages = [], className = \"\" } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: messages.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: messages.map((message, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"\".concat(className, \" text-sm text-red-600\"),\n                    children: message\n                }, index, false, {\n                    fileName: \"D:\\\\InternShip\\\\breeze-next-master\\\\breeze-next-master\\\\src\\\\components\\\\InputError.js\",\n                    lineNumber: 6,\n                    columnNumber: 21\n                }, undefined))\n        }, void 0, false)\n    }, void 0, false);\n};\n_c = InputError;\n/* harmony default export */ __webpack_exports__[\"default\"] = (InputError);\nvar _c;\n$RefreshReg$(_c, \"InputError\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0lucHV0RXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsTUFBTUEsYUFBYTtRQUFDLEVBQUVDLFdBQVcsRUFBRSxFQUFFQyxZQUFZLEVBQUUsRUFBRTt5QkFDakQ7a0JBQ0tELFNBQVNFLE1BQU0sR0FBRyxtQkFDZjtzQkFDS0YsU0FBU0csR0FBRyxDQUFDLENBQUNDLFNBQVNDLHNCQUNwQiw4REFBQ0M7b0JBQ0dMLFdBQVcsR0FBYSxPQUFWQSxXQUFVOzhCQUV2Qkc7bUJBRElDOzs7Ozs7OztLQVB2Qk47QUFnQk4sK0RBQWVBLFVBQVVBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSW5wdXRFcnJvci5qcz8wMjc2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElucHV0RXJyb3IgPSAoeyBtZXNzYWdlcyA9IFtdLCBjbGFzc05hbWUgPSAnJyB9KSA9PiAoXG4gICAgPD5cbiAgICAgICAge21lc3NhZ2VzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7bWVzc2FnZXMubWFwKChtZXNzYWdlLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8cFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtjbGFzc05hbWV9IHRleHQtc20gdGV4dC1yZWQtNjAwYH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9PlxuICAgICAgICAgICAgICAgICAgICAgICAge21lc3NhZ2V9XG4gICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgIDwvPlxuKVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEVycm9yXG4iXSwibmFtZXMiOlsiSW5wdXRFcnJvciIsIm1lc3NhZ2VzIiwiY2xhc3NOYW1lIiwibGVuZ3RoIiwibWFwIiwibWVzc2FnZSIsImluZGV4IiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/InputError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/Info.js":
/*!***************************!*\
  !*** ./src/hooks/Info.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userInfo: function() { return /* binding */ userInfo; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n// export const userInfo = ({ middleware, redirectIfAuthenticated, id} = {}) => {\nconst userInfo = function() {\n    let { middleware, redirectIfAuthenticated, id: propId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const { id: paramsId } = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams)(); // Lấy userId từ URL\n    const id = propId || paramsId;\n    const { data: user, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/users/\".concat(id), ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/users/\".concat(id)).then((res)=>res.data.user).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    return {\n        user,\n        error,\n        mutate\n    };\n};\n_s(userInfo, \"4wY/a8mIU5VrXviG3lny9gExN0g=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9JbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDUTtBQUNDO0FBQ1U7QUFFM0MsaUZBQWlGO0FBQ3hFLE1BQU1JLFdBQVc7UUFBQyxFQUFFQyxVQUFVLEVBQUVDLHVCQUF1QixFQUFFQyxJQUFJQyxNQUFNLEVBQUUsb0VBQUcsQ0FBQzs7SUFDOUUsTUFBTSxFQUFFRCxJQUFJRSxRQUFRLEVBQUUsR0FBR04sMERBQVNBLElBQUksb0JBQW9CO0lBRTFELE1BQU1JLEtBQUtDLFVBQVVDO0lBQ3JCLE1BQU0sRUFBRUMsTUFBTUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHYiwrQ0FBTUEsQ0FBQyxVQUFhLE9BQUhPLEtBQU0sSUFDekROLGtEQUFLQSxDQUNBYSxHQUFHLENBQUMsVUFBYSxPQUFIUCxLQUNkUSxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlOLElBQUksQ0FBQ0MsSUFBSSxFQUN6Qk0sS0FBSyxDQUFDTCxDQUFBQTtZQUNILElBQUlBLE1BQU1NLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUssTUFBTVA7UUFDN0M7SUFJUixNQUFNUSxPQUFPLElBQU1uQixrREFBS0EsQ0FBQ2EsR0FBRyxDQUFDO0lBSTdCLE9BQU87UUFDSEg7UUFDQUM7UUFDQUM7SUFFSjtBQUNKLEVBQUU7R0F4QmFUOztRQUNjRCxzREFBU0E7UUFHSUgsMkNBQU1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy9JbmZvLmpzP2MyOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InXHJcbmltcG9ydCBheGlvcyBmcm9tICcuLi9saWIvYXhpb3MnXHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyB1c2VQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXHJcblxyXG4vLyBleHBvcnQgY29uc3QgdXNlckluZm8gPSAoeyBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCwgaWR9ID0ge30pID0+IHtcclxuICBleHBvcnQgY29uc3QgdXNlckluZm8gPSAoeyBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCwgaWQ6IHByb3BJZCB9ID0ge30pID0+IHtcclxuICAgIGNvbnN0IHsgaWQ6IHBhcmFtc0lkIH0gPSB1c2VQYXJhbXMoKTsgLy8gTOG6pXkgdXNlcklkIHThu6sgVVJMXHJcblxyXG4gICAgY29uc3QgaWQgPSBwcm9wSWQgfHwgcGFyYW1zSWQ7XHJcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yLCBtdXRhdGUgfSA9IHVzZVNXUihgL3VzZXJzLyR7aWR9YCwgKCkgPT5cclxuICAgICAgICBheGlvc1xyXG4gICAgICAgICAgICAuZ2V0KGAvdXNlcnMvJHtpZH1gKVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLmRhdGEudXNlcilcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwOSkgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgKTsgIFxyXG4gIFxyXG5cclxuICAgIGNvbnN0IGNzcmYgPSAoKSA9PiBheGlvcy5nZXQoJy9zYW5jdHVtL2NzcmYtY29va2llJyk7XHJcblxyXG4gICAgXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VyLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIG11dGF0ZSxcclxuIFxyXG4gICAgfTtcclxufTsiXSwibmFtZXMiOlsidXNlU1dSIiwiYXhpb3MiLCJ1c2VFZmZlY3QiLCJ1c2VQYXJhbXMiLCJ1c2VySW5mbyIsIm1pZGRsZXdhcmUiLCJyZWRpcmVjdElmQXV0aGVudGljYXRlZCIsImlkIiwicHJvcElkIiwicGFyYW1zSWQiLCJkYXRhIiwidXNlciIsImVycm9yIiwibXV0YXRlIiwiZ2V0IiwidGhlbiIsInJlcyIsImNhdGNoIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjc3JmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/Info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/avatar.js":
/*!*****************************!*\
  !*** ./src/hooks/avatar.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userAvatar: function() { return /* binding */ userAvatar; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst userAvatar = function() {\n    let { middleware, redirectIfAuthenticated, id: propId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const { id: paramsId } = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams)(); // Lấy userId từ URL\n    const id = propId || paramsId; // Sử dụng id từ tham số hoặc từ URL params\n    const { data: first_image_path, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"user/\".concat(id, \"/first-image\"), ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"user/\".concat(id, \"/first-image\")).then((res)=>res.data).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const deleteMatch = async (param)=>{\n        let { id, setErrors, setStatus } = param;\n        await csrf();\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].delete(\"/matches/\".concat(id));\n            if (response.data.status === \"success\") {\n                mutate(); // Refresh profile data\n                setStatus(response.data.status);\n            }\n        } catch (error) {\n            if (error.response && error.response.status !== 422) {\n                throw error;\n            }\n            setErrors(error.response.data.errors);\n        }\n    };\n    //   useEffect(() => {\n    // }, [first_image_path, error])\n    return {\n        first_image_path,\n        error,\n        mutate,\n        deleteMatch\n    };\n};\n_s(userAvatar, \"BHOeDan5EdOpV2L+jUQWkVSI2JI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9hdmF0YXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3QjtBQUNRO0FBQ0M7QUFDVTtBQUNwQyxNQUFNSSxhQUFhO1FBQUMsRUFBRUMsVUFBVSxFQUFFQyx1QkFBdUIsRUFBRUMsSUFBSUMsTUFBTSxFQUFFLG9FQUFHLENBQUM7O0lBQzlFLE1BQU0sRUFBRUQsSUFBSUUsUUFBUSxFQUFFLEdBQUdOLDBEQUFTQSxJQUFJLG9CQUFvQjtJQUUxRCxNQUFNSSxLQUFLQyxVQUFVQyxVQUFVLDJDQUEyQztJQUMxRSxNQUFNLEVBQUVDLE1BQU1DLGdCQUFnQixFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHYiwrQ0FBTUEsQ0FBQyxRQUFXLE9BQUhPLElBQUcsaUJBQWUsSUFDL0VOLGtEQUFLQSxDQUNBYSxHQUFHLENBQUMsUUFBVyxPQUFIUCxJQUFHLGlCQUNmUSxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlOLElBQUksRUFDcEJPLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1FBQzdDO0lBSVIsTUFBTVEsT0FBTyxJQUFNbkIsa0RBQUtBLENBQUNhLEdBQUcsQ0FBQztJQUU3QixNQUFNTyxjQUFjO1lBQU8sRUFBQ2QsRUFBRSxFQUFFZSxTQUFTLEVBQUVDLFNBQVMsRUFBRTtRQUNsRCxNQUFNSDtRQUVOLElBQUk7WUFDRixNQUFNRixXQUFXLE1BQU1qQixrREFBS0EsQ0FBQ3VCLE1BQU0sQ0FBQyxZQUFlLE9BQUhqQjtZQUNoRCxJQUFJVyxTQUFTUixJQUFJLENBQUNTLE1BQU0sS0FBSyxXQUFXO2dCQUN0Q04sVUFBVSx1QkFBdUI7Z0JBQ2pDVSxVQUFVTCxTQUFTUixJQUFJLENBQUNTLE1BQU07WUFDaEM7UUFDRixFQUFFLE9BQU9QLE9BQU87WUFDZCxJQUFJQSxNQUFNTSxRQUFRLElBQUlOLE1BQU1NLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUs7Z0JBQ25ELE1BQU1QO1lBQ1I7WUFDQVUsVUFBVVYsTUFBTU0sUUFBUSxDQUFDUixJQUFJLENBQUNlLE1BQU07UUFDdEM7SUFDRjtJQUNGLHNCQUFzQjtJQUV0QixnQ0FBZ0M7SUFDaEMsT0FBTztRQUNIZDtRQUNBQztRQUNBQztRQUNBUTtJQUVKO0FBQ0osRUFBRTtHQTFDV2pCOztRQUNnQkQsc0RBQVNBO1FBR2dCSCwyQ0FBTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL2F2YXRhci5qcz9iMjc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xyXG5leHBvcnQgY29uc3QgdXNlckF2YXRhciA9ICh7IG1pZGRsZXdhcmUsIHJlZGlyZWN0SWZBdXRoZW50aWNhdGVkLCBpZDogcHJvcElkIH0gPSB7fSkgPT4ge1xyXG4gICAgY29uc3QgeyBpZDogcGFyYW1zSWQgfSA9IHVzZVBhcmFtcygpOyAvLyBM4bqleSB1c2VySWQgdOG7qyBVUkxcclxuXHJcbiAgICBjb25zdCBpZCA9IHByb3BJZCB8fCBwYXJhbXNJZDsgLy8gU+G7rSBk4bulbmcgaWQgdOG7qyB0aGFtIHPhu5EgaG/hurdjIHThu6sgVVJMIHBhcmFtc1xyXG4gICAgY29uc3QgeyBkYXRhOiBmaXJzdF9pbWFnZV9wYXRoLCBlcnJvciwgbXV0YXRlIH0gPSB1c2VTV1IoYHVzZXIvJHtpZH0vZmlyc3QtaW1hZ2VgLCAoKSA9PlxyXG4gICAgICAgIGF4aW9zXHJcbiAgICAgICAgICAgIC5nZXQoYHVzZXIvJHtpZH0vZmlyc3QtaW1hZ2VgKVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLmRhdGEpXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MDkpIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICk7ICBcclxuXHJcblxyXG4gICAgY29uc3QgY3NyZiA9ICgpID0+IGF4aW9zLmdldCgnL3NhbmN0dW0vY3NyZi1jb29raWUnKTtcclxuXHJcbiAgICBjb25zdCBkZWxldGVNYXRjaCA9IGFzeW5jICh7aWQsIHNldEVycm9ycywgc2V0U3RhdHVzIH0pID0+IHtcclxuICAgICAgICBhd2FpdCBjc3JmKCk7XHJcbiAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmRlbGV0ZShgL21hdGNoZXMvJHtpZH1gKTtcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgICAgIG11dGF0ZSgpOyAvLyBSZWZyZXNoIHByb2ZpbGUgZGF0YVxyXG4gICAgICAgICAgICBzZXRTdGF0dXMocmVzcG9uc2UuZGF0YS5zdGF0dXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MjIpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXRFcnJvcnMoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIC8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgXHJcbiAgICAvLyB9LCBbZmlyc3RfaW1hZ2VfcGF0aCwgZXJyb3JdKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXJzdF9pbWFnZV9wYXRoLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIG11dGF0ZSxcclxuICAgICAgICBkZWxldGVNYXRjaFxyXG5cclxuICAgIH07XHJcbn07Il0sIm5hbWVzIjpbInVzZVNXUiIsImF4aW9zIiwidXNlRWZmZWN0IiwidXNlUGFyYW1zIiwidXNlckF2YXRhciIsIm1pZGRsZXdhcmUiLCJyZWRpcmVjdElmQXV0aGVudGljYXRlZCIsImlkIiwicHJvcElkIiwicGFyYW1zSWQiLCJkYXRhIiwiZmlyc3RfaW1hZ2VfcGF0aCIsImVycm9yIiwibXV0YXRlIiwiZ2V0IiwidGhlbiIsInJlcyIsImNhdGNoIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjc3JmIiwiZGVsZXRlTWF0Y2giLCJzZXRFcnJvcnMiLCJzZXRTdGF0dXMiLCJkZWxldGUiLCJlcnJvcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/avatar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/likes.js":
/*!****************************!*\
  !*** ./src/hooks/likes.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userLikes: function() { return /* binding */ userLikes; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst userLikes = function() {\n    let { middleware, redirectIfAuthenticated } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const params = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams)();\n    const { data: users, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/users\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/users\").then((res)=>res.data.users).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const createLike = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/likes\", props).then((response)=>{\n            const likedUser = response.data.liked_user; // Lấy thông tin về người được \"like\" từ phản hồi\n            setStatus(response.data.status);\n        // console.log(\"Like User vua code xong: \",likedUser); // In ra thông tin về người được \"like\"\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    const showLikes = async (props)=>{\n        await csrf();\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/likes\", {\n            params: props\n        }).then((response)=>{}).catch((error)=>{\n            console.error(error);\n        });\n    };\n    const userDetail = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/users/${props.id}`\", props).then((response)=>{\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    return {\n        users,\n        error,\n        mutate,\n        createLike,\n        showLikes,\n        userDetail\n    };\n};\n_s(userLikes, \"Z5OYlgsktRBonie4Qf6MMByaGto=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9saWtlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdCO0FBQ1E7QUFDQztBQUNxQjtBQUUvQyxNQUFNSyxZQUFZO1FBQUMsRUFBRUMsVUFBVSxFQUFFQyx1QkFBdUIsRUFBRSxvRUFBRyxDQUFDOztJQUNqRSxNQUFNQyxTQUFTSiwwREFBU0E7SUFDeEIsTUFBTUssU0FBU04sMERBQVNBO0lBQ3hCLE1BQU0sRUFBRU8sTUFBTUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHYiwrQ0FBTUEsQ0FBQyxVQUFVLElBQ3hEQyxrREFBS0EsQ0FDQWEsR0FBRyxDQUFDLFVBQ0pDLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSU4sSUFBSSxDQUFDQyxLQUFLLEVBQzFCTSxLQUFLLENBQUNMLENBQUFBO1lBQ0gsSUFBSUEsTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSyxNQUFNUDtRQUM3QztJQUdSLE1BQU1RLE9BQU8sSUFBTW5CLGtEQUFLQSxDQUFDYSxHQUFHLENBQUM7SUFDN0IsTUFBTU8sYUFBYTtZQUFPLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87UUFDeEQsTUFBTUo7UUFFTkUsVUFBVSxFQUFFO1FBQ1pDLFVBQVU7UUFFVnRCLGtEQUFLQSxDQUNBd0IsSUFBSSxDQUFDLFVBQVVELE9BQ2ZULElBQUksQ0FBQ0csQ0FBQUE7WUFDRixNQUFNUSxZQUFZUixTQUFTUixJQUFJLENBQUNpQixVQUFVLEVBQUUsaURBQWlEO1lBQzdGSixVQUFVTCxTQUFTUixJQUFJLENBQUNTLE1BQU07UUFDOUIsOEZBQThGO1FBQ2xHLEdBQ0NGLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1lBRXpDVSxVQUFVVixNQUFNTSxRQUFRLENBQUNSLElBQUksQ0FBQ2tCLE1BQU07UUFDeEM7SUFDUjtJQUlBLE1BQU1DLFlBQVksT0FBT0w7UUFDckIsTUFBTUo7UUFFTm5CLGtEQUFLQSxDQUNBYSxHQUFHLENBQUMsVUFBVTtZQUFFTCxRQUFRZTtRQUFNLEdBQzlCVCxJQUFJLENBQUNHLENBQUFBLFlBQ04sR0FDQ0QsS0FBSyxDQUFDTCxDQUFBQTtZQUNIa0IsUUFBUWxCLEtBQUssQ0FBQ0E7UUFDbEI7SUFDUjtJQUNBLE1BQU1tQixhQUFhO1lBQU8sRUFBRVQsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztRQUN4RCxNQUFNSjtRQUVORSxVQUFVLEVBQUU7UUFDWkMsVUFBVTtRQUVWdEIsa0RBQUtBLENBQ0FhLEdBQUcsQ0FBQyx1QkFBdUJVLE9BQzNCVCxJQUFJLENBQUNHLENBQUFBO1lBQ0ZLLFVBQVVMLFNBQVNSLElBQUksQ0FBQ1MsTUFBTTtRQUFDLEdBQ2xDRixLQUFLLENBQUNMLENBQUFBO1lBQ0gsSUFBSUEsTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSyxNQUFNUDtZQUV6Q1UsVUFBVVYsTUFBTU0sUUFBUSxDQUFDUixJQUFJLENBQUNrQixNQUFNO1FBQ3hDO0lBQ1I7SUFDSSxPQUFPO1FBQ0hqQjtRQUFNQztRQUFNQztRQUFPUTtRQUFXUTtRQUFVRTtJQUM1QztBQUNKLEVBQUM7R0FqRVkxQjs7UUFDTUQsc0RBQVNBO1FBQ1RELHNEQUFTQTtRQUNlSCwyQ0FBTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL2xpa2VzLmpzPzBkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InXHJcbmltcG9ydCBheGlvcyBmcm9tICcuLi9saWIvYXhpb3MnXHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyB1c2VQYXJhbXMsIHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VyTGlrZXMgPSAoeyBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCB9ID0ge30pID0+IHtcclxuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXHJcbiAgICBjb25zdCBwYXJhbXMgPSB1c2VQYXJhbXMoKVxyXG4gICAgY29uc3QgeyBkYXRhOiB1c2VycywgZXJyb3IsIG11dGF0ZSB9ID0gdXNlU1dSKCcvdXNlcnMnLCAoKSA9PlxyXG4gICAgYXhpb3NcclxuICAgICAgICAuZ2V0KCcvdXNlcnMnKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiByZXMuZGF0YS51c2VycylcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MDkpIHRocm93IGVycm9yXHJcbiAgICAgICAgfSksXHJcbilcclxuXHJcbmNvbnN0IGNzcmYgPSAoKSA9PiBheGlvcy5nZXQoJy9zYW5jdHVtL2NzcmYtY29va2llJylcclxuY29uc3QgY3JlYXRlTGlrZSA9IGFzeW5jICh7IHNldEVycm9ycywgc2V0U3RhdHVzLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgICBhd2FpdCBjc3JmKClcclxuXHJcbiAgICBzZXRFcnJvcnMoW10pXHJcbiAgICBzZXRTdGF0dXMobnVsbClcclxuXHJcbiAgICBheGlvc1xyXG4gICAgICAgIC5wb3N0KCcvbGlrZXMnLCBwcm9wcylcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpa2VkVXNlciA9IHJlc3BvbnNlLmRhdGEubGlrZWRfdXNlcjsgLy8gTOG6pXkgdGjDtG5nIHRpbiB24buBIG5nxrDhu51pIMSRxrDhu6NjIFwibGlrZVwiIHThu6sgcGjhuqNuIGjhu5NpXHJcbiAgICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTGlrZSBVc2VyIHZ1YSBjb2RlIHhvbmc6IFwiLGxpa2VkVXNlcik7IC8vIEluIHJhIHRow7RuZyB0aW4gduG7gSBuZ8aw4budaSDEkcaw4bujYyBcImxpa2VcIlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcblxyXG5cclxuY29uc3Qgc2hvd0xpa2VzID0gYXN5bmMgKHByb3BzKSA9PiB7XHJcbiAgICBhd2FpdCBjc3JmKCk7XHJcblxyXG4gICAgYXhpb3NcclxuICAgICAgICAuZ2V0KCcvbGlrZXMnLCB7IHBhcmFtczogcHJvcHMgfSlcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9KTtcclxufTtcclxuY29uc3QgdXNlckRldGFpbCA9IGFzeW5jICh7IHNldEVycm9ycywgc2V0U3RhdHVzLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgICBhd2FpdCBjc3JmKClcclxuXHJcbiAgICBzZXRFcnJvcnMoW10pXHJcbiAgICBzZXRTdGF0dXMobnVsbClcclxuXHJcbiAgICBheGlvc1xyXG4gICAgICAgIC5nZXQoJy91c2Vycy8ke3Byb3BzLmlkfWAnLCBwcm9wcylcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyl9KVxyXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQyMikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgICAgICAgIHNldEVycm9ycyhlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycylcclxuICAgICAgICB9KVxyXG59XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZXJzLGVycm9yLG11dGF0ZSxjcmVhdGVMaWtlLHNob3dMaWtlcyx1c2VyRGV0YWlsXHJcbiAgICB9XHJcbn0iXSwibmFtZXMiOlsidXNlU1dSIiwiYXhpb3MiLCJ1c2VFZmZlY3QiLCJ1c2VQYXJhbXMiLCJ1c2VSb3V0ZXIiLCJ1c2VyTGlrZXMiLCJtaWRkbGV3YXJlIiwicmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQiLCJyb3V0ZXIiLCJwYXJhbXMiLCJkYXRhIiwidXNlcnMiLCJlcnJvciIsIm11dGF0ZSIsImdldCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsInJlc3BvbnNlIiwic3RhdHVzIiwiY3NyZiIsImNyZWF0ZUxpa2UiLCJzZXRFcnJvcnMiLCJzZXRTdGF0dXMiLCJwcm9wcyIsInBvc3QiLCJsaWtlZFVzZXIiLCJsaWtlZF91c2VyIiwiZXJyb3JzIiwic2hvd0xpa2VzIiwiY29uc29sZSIsInVzZXJEZXRhaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/likes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/match.js":
/*!****************************!*\
  !*** ./src/hooks/match.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userMatch: function() { return /* binding */ userMatch; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst userMatch = function() {\n    let { middleware, redirectIfAuthenticated } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const { data: matchedUsers, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/messages/matches\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/messages/matches\").then((res)=>res.data.matchedUsers).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const csrf = async ()=>{\n            await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n        };\n        csrf();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{}, [\n        matchedUsers,\n        error\n    ]);\n    return {\n        matchedUsers,\n        error,\n        mutate\n    };\n};\n_s(userMatch, \"xxbtcnPI+22IxDQ+25DGVIdy7UM=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9tYXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdCO0FBQ1E7QUFDQztBQUNxQjtBQUUvQyxNQUFNSyxZQUFZO1FBQUMsRUFBRUMsVUFBVSxFQUFFQyx1QkFBdUIsRUFBRSxvRUFBRyxDQUFDOztJQUNqRSxNQUFNQyxTQUFTSiwwREFBU0E7SUFDeEIsTUFBTSxFQUFFSyxNQUFNQyxZQUFZLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdaLCtDQUFNQSxDQUFDLHFCQUFxQixJQUN0RUMsa0RBQUtBLENBQ0FZLEdBQUcsQ0FBQyxxQkFDSkMsSUFBSSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJTixJQUFJLENBQUNDLFlBQVksRUFDakNNLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1FBQzdDO0lBR1JULGdEQUFTQSxDQUFDO1FBQ04sTUFBTWlCLE9BQU87WUFDVCxNQUFNbEIsa0RBQUtBLENBQUNZLEdBQUcsQ0FBQztRQUNwQjtRQUNBTTtJQUNKLEdBQUcsRUFBRTtJQUNMakIsZ0RBQVNBLENBQUMsS0FFVixHQUFHO1FBQUNRO1FBQWNDO0tBQU07SUFDeEIsT0FBTztRQUNIRDtRQUNBQztRQUNBQztJQUNKO0FBQ0osRUFBQztHQXpCWVA7O1FBQ01ELHNEQUFTQTtRQUNzQkosMkNBQU1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy9tYXRjaC5qcz9mODRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUGFyYW1zLCB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXHJcblxyXG5leHBvcnQgY29uc3QgdXNlck1hdGNoID0gKHsgbWlkZGxld2FyZSwgcmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQgfSA9IHt9KSA9PiB7XHJcbiAgICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxyXG4gICAgY29uc3QgeyBkYXRhOiBtYXRjaGVkVXNlcnMsIGVycm9yLCBtdXRhdGUgfSA9IHVzZVNXUignL21lc3NhZ2VzL21hdGNoZXMnLCAoKSA9PlxyXG4gICAgICAgIGF4aW9zXHJcbiAgICAgICAgICAgIC5nZXQoJy9tZXNzYWdlcy9tYXRjaGVzJylcclxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5kYXRhLm1hdGNoZWRVc2VycylcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwOSkgdGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgfSksXHJcbiAgICApXHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBjc3JmID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBhd2FpdCBheGlvcy5nZXQoJy9zYW5jdHVtL2NzcmYtY29va2llJylcclxuICAgICAgICB9XHJcbiAgICAgICAgY3NyZigpXHJcbiAgICB9LCBbXSlcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIFxyXG4gICAgfSwgW21hdGNoZWRVc2VycywgZXJyb3JdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWF0Y2hlZFVzZXJzLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIG11dGF0ZVxyXG4gICAgfVxyXG59Il0sIm5hbWVzIjpbInVzZVNXUiIsImF4aW9zIiwidXNlRWZmZWN0IiwidXNlUGFyYW1zIiwidXNlUm91dGVyIiwidXNlck1hdGNoIiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwicm91dGVyIiwiZGF0YSIsIm1hdGNoZWRVc2VycyIsImVycm9yIiwibXV0YXRlIiwiZ2V0IiwidGhlbiIsInJlcyIsImNhdGNoIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjc3JmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/match.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/messege.js":
/*!******************************!*\
  !*** ./src/hooks/messege.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userMessenger: function() { return /* binding */ userMessenger; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n// export const userMessenger = ({ middleware, redirectIfAuthenticated,id } = {}) => {\n//     hoặc const { id } = useParams(); // Lấy userId từ URL\nconst userMessenger = function() {\n    let { middleware, redirectIfAuthenticated, id: propId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const { id: paramsId } = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams)(); // Lấy userId từ URL\n    const id = propId || paramsId; // Sử dụng id từ tham số hoặc từ URL params\n    const { data: responseData, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/messages/\".concat(id), ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/messages/\".concat(id)).then((res)=>res.data).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    // Trích xuất dữ liệu từ responseData\n    const conversation = responseData === null || responseData === void 0 ? void 0 : responseData.conversation;\n    const loggedInUser = responseData === null || responseData === void 0 ? void 0 : responseData.loggedInUser;\n    const matchedUser = responseData === null || responseData === void 0 ? void 0 : responseData.matchedUser;\n    const match = responseData === null || responseData === void 0 ? void 0 : responseData.match;\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const sendMessage = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/messages/send\", props).then((response)=>{\n            console.log(response);\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    const deleteMatch = async (param)=>{\n        let { id, setErrors, setStatus } = param;\n        await csrf();\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].delete(\"/matches/\".concat(id));\n            if (response.data.status === \"success\") {\n                mutate(); // Refresh profile data\n                setStatus(response.data.status);\n            }\n        } catch (error) {\n            if (error.response && error.response.status !== 422) {\n                throw error;\n            }\n            setErrors(error.response.data.errors);\n        }\n    };\n    return {\n        conversation,\n        matchedUser,\n        loggedInUser,\n        match,\n        error,\n        mutate,\n        sendMessage,\n        deleteMatch\n    };\n};\n_s(userMessenger, \"okvMd/1ftSKFQR/ai3pcDDTGF2M=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9tZXNzZWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDUTtBQUNDO0FBQ1U7QUFDM0Msc0ZBQXNGO0FBQ3RGLDREQUE0RDtBQUNyRCxNQUFNSSxnQkFBZ0I7UUFBQyxFQUFFQyxVQUFVLEVBQUVDLHVCQUF1QixFQUFFQyxJQUFJQyxNQUFNLEVBQUUsb0VBQUcsQ0FBQzs7SUFDakYsTUFBTSxFQUFFRCxJQUFJRSxRQUFRLEVBQUUsR0FBR04sMERBQVNBLElBQUksb0JBQW9CO0lBRTFELE1BQU1JLEtBQUtDLFVBQVVDLFVBQVUsMkNBQTJDO0lBRTFFLE1BQU0sRUFBRUMsTUFBTUMsWUFBWSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHYiwrQ0FBTUEsQ0FBQyxhQUFnQixPQUFITyxLQUFNLElBQ3BFTixrREFBS0EsQ0FDQWEsR0FBRyxDQUFDLGFBQWdCLE9BQUhQLEtBQ2pCUSxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlOLElBQUksRUFDcEJPLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1FBQzdDO0lBRVIscUNBQXFDO0lBQ3JDLE1BQU1RLGVBQWVULHlCQUFBQSxtQ0FBQUEsYUFBY1MsWUFBWTtJQUMvQyxNQUFNQyxlQUFlVix5QkFBQUEsbUNBQUFBLGFBQWNVLFlBQVk7SUFDL0MsTUFBTUMsY0FBY1gseUJBQUFBLG1DQUFBQSxhQUFjVyxXQUFXO0lBQzdDLE1BQU1DLFFBQVFaLHlCQUFBQSxtQ0FBQUEsYUFBY1ksS0FBSztJQUNqQyxNQUFNQyxPQUFPLElBQU12QixrREFBS0EsQ0FBQ2EsR0FBRyxDQUFDO0lBRTdCLE1BQU1XLGNBQWM7WUFBTyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO1FBQ3pELE1BQU1KO1FBQ05FLFVBQVUsRUFBRTtRQUNaQyxVQUFVO1FBRVYxQixrREFBS0EsQ0FBQzRCLElBQUksQ0FBQyxrQkFBa0JELE9BQ3hCYixJQUFJLENBQUNHLENBQUFBO1lBQ0ZZLFFBQVFDLEdBQUcsQ0FBQ2I7WUFDWlMsVUFBVVQsU0FBU1IsSUFBSSxDQUFDUyxNQUFNO1FBQ2xDLEdBQ0NGLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1lBRXpDYyxVQUFVZCxNQUFNTSxRQUFRLENBQUNSLElBQUksQ0FBQ3NCLE1BQU07UUFDeEM7SUFDUjtJQUNBLE1BQU1DLGNBQWM7WUFBTyxFQUFDMUIsRUFBRSxFQUFFbUIsU0FBUyxFQUFFQyxTQUFTLEVBQUU7UUFDbEQsTUFBTUg7UUFFTixJQUFJO1lBQ0YsTUFBTU4sV0FBVyxNQUFNakIsa0RBQUtBLENBQUNpQyxNQUFNLENBQUMsWUFBZSxPQUFIM0I7WUFDaEQsSUFBSVcsU0FBU1IsSUFBSSxDQUFDUyxNQUFNLEtBQUssV0FBVztnQkFDdENOLFVBQVUsdUJBQXVCO2dCQUNqQ2MsVUFBVVQsU0FBU1IsSUFBSSxDQUFDUyxNQUFNO1lBQ2hDO1FBQ0YsRUFBRSxPQUFPUCxPQUFPO1lBQ2QsSUFBSUEsTUFBTU0sUUFBUSxJQUFJTixNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLO2dCQUNuRCxNQUFNUDtZQUNSO1lBQ0FjLFVBQVVkLE1BQU1NLFFBQVEsQ0FBQ1IsSUFBSSxDQUFDc0IsTUFBTTtRQUN0QztJQUNGO0lBQ0YsT0FBTztRQUNIWjtRQUNBRTtRQUNBRDtRQUNBRTtRQUNBWDtRQUNBQztRQUNBWTtRQUNBUTtJQUNKO0FBQ0osRUFBRTtHQTlEVzdCOztRQUNnQkQsc0RBQVNBO1FBSVlILDJDQUFNQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvbWVzc2VnZS5qcz9hMDUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xyXG4vLyBleHBvcnQgY29uc3QgdXNlck1lc3NlbmdlciA9ICh7IG1pZGRsZXdhcmUsIHJlZGlyZWN0SWZBdXRoZW50aWNhdGVkLGlkIH0gPSB7fSkgPT4ge1xyXG4vLyAgICAgaG/hurdjIGNvbnN0IHsgaWQgfSA9IHVzZVBhcmFtcygpOyAvLyBM4bqleSB1c2VySWQgdOG7qyBVUkxcclxuZXhwb3J0IGNvbnN0IHVzZXJNZXNzZW5nZXIgPSAoeyBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCwgaWQ6IHByb3BJZCB9ID0ge30pID0+IHtcclxuICAgIGNvbnN0IHsgaWQ6IHBhcmFtc0lkIH0gPSB1c2VQYXJhbXMoKTsgLy8gTOG6pXkgdXNlcklkIHThu6sgVVJMXHJcblxyXG4gICAgY29uc3QgaWQgPSBwcm9wSWQgfHwgcGFyYW1zSWQ7IC8vIFPhu60gZOG7pW5nIGlkIHThu6sgdGhhbSBz4buRIGhv4bq3YyB04burIFVSTCBwYXJhbXNcclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHJlc3BvbnNlRGF0YSwgZXJyb3IsIG11dGF0ZSB9ID0gdXNlU1dSKGAvbWVzc2FnZXMvJHtpZH1gLCAoKSA9PlxyXG4gICAgICAgIGF4aW9zXHJcbiAgICAgICAgICAgIC5nZXQoYC9tZXNzYWdlcy8ke2lkfWApXHJcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMuZGF0YSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwOSkgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgKTsgIFxyXG4gICAgLy8gVHLDrWNoIHh14bqldCBk4buvIGxp4buHdSB04burIHJlc3BvbnNlRGF0YVxyXG4gICAgY29uc3QgY29udmVyc2F0aW9uID0gcmVzcG9uc2VEYXRhPy5jb252ZXJzYXRpb247XHJcbiAgICBjb25zdCBsb2dnZWRJblVzZXIgPSByZXNwb25zZURhdGE/LmxvZ2dlZEluVXNlcjtcclxuICAgIGNvbnN0IG1hdGNoZWRVc2VyID0gcmVzcG9uc2VEYXRhPy5tYXRjaGVkVXNlcjtcclxuICAgIGNvbnN0IG1hdGNoID0gcmVzcG9uc2VEYXRhPy5tYXRjaDtcclxuICAgIGNvbnN0IGNzcmYgPSAoKSA9PiBheGlvcy5nZXQoJy9zYW5jdHVtL2NzcmYtY29va2llJyk7XHJcblxyXG4gICAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoeyBzZXRFcnJvcnMsIHNldFN0YXR1cywgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGNzcmYoKTtcclxuICAgICAgICBzZXRFcnJvcnMoW10pO1xyXG4gICAgICAgIHNldFN0YXR1cyhudWxsKTtcclxuXHJcbiAgICAgICAgYXhpb3MucG9zdCgnL21lc3NhZ2VzL3NlbmQnLCBwcm9wcylcclxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQyMikgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZGVsZXRlTWF0Y2ggPSBhc3luYyAoe2lkLCBzZXRFcnJvcnMsIHNldFN0YXR1cyB9KSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY3NyZigpO1xyXG4gICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYC9tYXRjaGVzLyR7aWR9YCk7XHJcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICBtdXRhdGUoKTsgLy8gUmVmcmVzaCBwcm9maWxlIGRhdGFcclxuICAgICAgICAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnZlcnNhdGlvbixcclxuICAgICAgICBtYXRjaGVkVXNlcixcclxuICAgICAgICBsb2dnZWRJblVzZXIsXHJcbiAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgbXV0YXRlLFxyXG4gICAgICAgIHNlbmRNZXNzYWdlLFxyXG4gICAgICAgIGRlbGV0ZU1hdGNoLFxyXG4gICAgfTtcclxufTsiXSwibmFtZXMiOlsidXNlU1dSIiwiYXhpb3MiLCJ1c2VFZmZlY3QiLCJ1c2VQYXJhbXMiLCJ1c2VyTWVzc2VuZ2VyIiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwiaWQiLCJwcm9wSWQiLCJwYXJhbXNJZCIsImRhdGEiLCJyZXNwb25zZURhdGEiLCJlcnJvciIsIm11dGF0ZSIsImdldCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsInJlc3BvbnNlIiwic3RhdHVzIiwiY29udmVyc2F0aW9uIiwibG9nZ2VkSW5Vc2VyIiwibWF0Y2hlZFVzZXIiLCJtYXRjaCIsImNzcmYiLCJzZW5kTWVzc2FnZSIsInNldEVycm9ycyIsInNldFN0YXR1cyIsInByb3BzIiwicG9zdCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvcnMiLCJkZWxldGVNYXRjaCIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/messege.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/payment.js":
/*!******************************!*\
  !*** ./src/hooks/payment.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userPayment: function() { return /* binding */ userPayment; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n\n\n\n\n// export const userInfo = ({ middleware, redirectIfAuthenticated, id} = {}) => {\nconst userPayment = function() {\n    let { middleware, redirectIfAuthenticated } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const vnpay_payment = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/vnpay_payment\", props, {\n            responseType: \"json\"\n        }).then((response)=>{\n            window.location.href = response.data.code === \"00\" && response.data.status === \"success\" ? response.data.data : null;\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    const confirm_payment = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        // Lấy URL từ window.location hoặc tham số khác nếu bạn có URL từ nguồn khác\n        const urlParams = new URLSearchParams(window.location.search);\n        // Lấy giá trị các tham số từ URL\n        const vnp_Amount = urlParams.get(\"vnp_Amount\");\n        const vnp_BankCode = urlParams.get(\"vnp_BankCode\");\n        const vnp_BankTranNo = urlParams.get(\"vnp_BankTranNo\");\n        const vnp_CardType = urlParams.get(\"vnp_CardType\");\n        const vnp_OrderInfo = urlParams.get(\"vnp_OrderInfo\");\n        const vnp_PayDate = urlParams.get(\"vnp_PayDate\");\n        const vnp_ResponseCode = urlParams.get(\"vnp_ResponseCode\");\n        const vnp_TmnCode = urlParams.get(\"vnp_TmnCode\");\n        const vnp_TransactionNo = urlParams.get(\"vnp_TransactionNo\");\n        const vnp_TransactionStatus = urlParams.get(\"vnp_TransactionStatus\");\n        const vnp_TxnRef = urlParams.get(\"vnp_TxnRef\");\n        const vnp_SecureHash = urlParams.get(\"vnp_SecureHash\");\n        // Gửi các tham số này đến backend\n        const data = {\n            vnp_Amount,\n            vnp_BankCode,\n            vnp_BankTranNo,\n            vnp_CardType,\n            vnp_OrderInfo,\n            vnp_PayDate,\n            vnp_ResponseCode,\n            vnp_TmnCode,\n            vnp_TransactionNo,\n            vnp_TransactionStatus,\n            vnp_TxnRef,\n            vnp_SecureHash\n        };\n        await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/thanks\", data).then((response)=>{\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    return {\n        vnpay_payment,\n        confirm_payment\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9wYXltZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QjtBQUNRO0FBQ0M7QUFDVTtBQUUzQyxpRkFBaUY7QUFDeEUsTUFBTUksY0FBYztRQUFDLEVBQUVDLFVBQVUsRUFBRUMsdUJBQXVCLEVBQUUsb0VBQUcsQ0FBQztJQUlyRSxNQUFNQyxPQUFPLElBQU1OLGtEQUFLQSxDQUFDTyxHQUFHLENBQUM7SUFFN0IsTUFBTUMsZ0JBQWdCO1lBQU8sRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztRQUMzRCxNQUFNTDtRQUVORyxVQUFVLEVBQUU7UUFDWkMsVUFBVTtRQUVWVixrREFBS0EsQ0FDQVksSUFBSSxDQUFDLGtCQUFrQkQsT0FBTztZQUFFRSxjQUFjO1FBQU8sR0FDckRDLElBQUksQ0FBQ0MsQ0FBQUE7WUFDRkMsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdILFNBQVNJLElBQUksQ0FBQ0MsSUFBSSxLQUFLLFFBQVFMLFNBQVNJLElBQUksQ0FBQ0UsTUFBTSxLQUFLLFlBQVlOLFNBQVNJLElBQUksQ0FBQ0EsSUFBSSxHQUFHO1lBQ2hIVCxVQUFVSyxTQUFTSSxJQUFJLENBQUNFLE1BQU07UUFDbEMsR0FDQ0MsS0FBSyxDQUFDQyxDQUFBQTtZQUNILElBQUlBLE1BQU1SLFFBQVEsQ0FBQ00sTUFBTSxLQUFLLEtBQUssTUFBTUU7WUFDekNkLFVBQVVjLE1BQU1SLFFBQVEsQ0FBQ0ksSUFBSSxDQUFDSyxNQUFNO1FBQ3hDO0lBQ1I7SUFDSixNQUFNQyxrQkFBa0I7WUFBTyxFQUFFaEIsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztRQUM3RCxNQUFNTDtRQUNORyxVQUFVLEVBQUU7UUFDWkMsVUFBVTtRQUVWLDRFQUE0RTtRQUM1RSxNQUFNZ0IsWUFBWSxJQUFJQyxnQkFBZ0JYLE9BQU9DLFFBQVEsQ0FBQ1csTUFBTTtRQUU1RCxpQ0FBaUM7UUFDakMsTUFBTUMsYUFBYUgsVUFBVW5CLEdBQUcsQ0FBQztRQUNqQyxNQUFNdUIsZUFBZUosVUFBVW5CLEdBQUcsQ0FBQztRQUNuQyxNQUFNd0IsaUJBQWlCTCxVQUFVbkIsR0FBRyxDQUFDO1FBQ3JDLE1BQU15QixlQUFlTixVQUFVbkIsR0FBRyxDQUFDO1FBQ25DLE1BQU0wQixnQkFBZ0JQLFVBQVVuQixHQUFHLENBQUM7UUFDcEMsTUFBTTJCLGNBQWNSLFVBQVVuQixHQUFHLENBQUM7UUFDbEMsTUFBTTRCLG1CQUFtQlQsVUFBVW5CLEdBQUcsQ0FBQztRQUN2QyxNQUFNNkIsY0FBY1YsVUFBVW5CLEdBQUcsQ0FBQztRQUNsQyxNQUFNOEIsb0JBQW9CWCxVQUFVbkIsR0FBRyxDQUFDO1FBQ3hDLE1BQU0rQix3QkFBd0JaLFVBQVVuQixHQUFHLENBQUM7UUFDNUMsTUFBTWdDLGFBQWFiLFVBQVVuQixHQUFHLENBQUM7UUFDakMsTUFBTWlDLGlCQUFpQmQsVUFBVW5CLEdBQUcsQ0FBQztRQUVyQyxrQ0FBa0M7UUFDbEMsTUFBTVksT0FBTztZQUNUVTtZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztRQUNKO1FBRUEsTUFBTXhDLGtEQUFLQSxDQUFDWSxJQUFJLENBQUMsV0FBV08sTUFDdkJMLElBQUksQ0FBQ0MsQ0FBQUE7WUFDRkwsVUFBVUssU0FBU0ksSUFBSSxDQUFDRSxNQUFNO1FBQ2xDLEdBQ0NDLEtBQUssQ0FBQ0MsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNUixRQUFRLENBQUNNLE1BQU0sS0FBSyxLQUFLLE1BQU1FO1lBQ3pDZCxVQUFVYyxNQUFNUixRQUFRLENBQUNJLElBQUksQ0FBQ0ssTUFBTTtRQUN4QztJQUNSO0lBSUksT0FBTztRQUNIaEI7UUFBY2lCO0lBR2xCO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvcGF5bWVudC5qcz85MTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xyXG5cclxuLy8gZXhwb3J0IGNvbnN0IHVzZXJJbmZvID0gKHsgbWlkZGxld2FyZSwgcmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQsIGlkfSA9IHt9KSA9PiB7XHJcbiAgZXhwb3J0IGNvbnN0IHVzZXJQYXltZW50ID0gKHsgbWlkZGxld2FyZSwgcmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQgfSA9IHt9KSA9PiB7XHJcbiAgXHJcbiAgXHJcblxyXG4gICAgY29uc3QgY3NyZiA9ICgpID0+IGF4aW9zLmdldCgnL3NhbmN0dW0vY3NyZi1jb29raWUnKTtcclxuICAgIFxyXG4gICAgY29uc3Qgdm5wYXlfcGF5bWVudCA9IGFzeW5jICh7IHNldEVycm9ycywgc2V0U3RhdHVzLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY3NyZigpXHJcbiAgICBcclxuICAgICAgICBzZXRFcnJvcnMoW10pXHJcbiAgICAgICAgc2V0U3RhdHVzKG51bGwpXHJcbiAgICBcclxuICAgICAgICBheGlvc1xyXG4gICAgICAgICAgICAucG9zdCgnL3ZucGF5X3BheW1lbnQnLCBwcm9wcywgeyByZXNwb25zZVR5cGU6ICdqc29uJyB9KVxyXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJlc3BvbnNlLmRhdGEuY29kZSA9PT0gJzAwJyAmJiByZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnID8gcmVzcG9uc2UuZGF0YS5kYXRhIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MjIpIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbmNvbnN0IGNvbmZpcm1fcGF5bWVudCA9IGFzeW5jICh7IHNldEVycm9ycywgc2V0U3RhdHVzLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgICBhd2FpdCBjc3JmKCk7XHJcbiAgICBzZXRFcnJvcnMoW10pXHJcbiAgICBzZXRTdGF0dXMobnVsbClcclxuXHJcbiAgICAvLyBM4bqleSBVUkwgdOG7qyB3aW5kb3cubG9jYXRpb24gaG/hurdjIHRoYW0gc+G7kSBraMOhYyBu4bq/dSBi4bqhbiBjw7MgVVJMIHThu6sgbmd14buTbiBraMOhY1xyXG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcclxuXHJcbiAgICAvLyBM4bqleSBnacOhIHRy4buLIGPDoWMgdGhhbSBz4buRIHThu6sgVVJMXHJcbiAgICBjb25zdCB2bnBfQW1vdW50ID0gdXJsUGFyYW1zLmdldCgndm5wX0Ftb3VudCcpO1xyXG4gICAgY29uc3Qgdm5wX0JhbmtDb2RlID0gdXJsUGFyYW1zLmdldCgndm5wX0JhbmtDb2RlJyk7XHJcbiAgICBjb25zdCB2bnBfQmFua1RyYW5ObyA9IHVybFBhcmFtcy5nZXQoJ3ZucF9CYW5rVHJhbk5vJyk7XHJcbiAgICBjb25zdCB2bnBfQ2FyZFR5cGUgPSB1cmxQYXJhbXMuZ2V0KCd2bnBfQ2FyZFR5cGUnKTtcclxuICAgIGNvbnN0IHZucF9PcmRlckluZm8gPSB1cmxQYXJhbXMuZ2V0KCd2bnBfT3JkZXJJbmZvJyk7XHJcbiAgICBjb25zdCB2bnBfUGF5RGF0ZSA9IHVybFBhcmFtcy5nZXQoJ3ZucF9QYXlEYXRlJyk7XHJcbiAgICBjb25zdCB2bnBfUmVzcG9uc2VDb2RlID0gdXJsUGFyYW1zLmdldCgndm5wX1Jlc3BvbnNlQ29kZScpO1xyXG4gICAgY29uc3Qgdm5wX1RtbkNvZGUgPSB1cmxQYXJhbXMuZ2V0KCd2bnBfVG1uQ29kZScpO1xyXG4gICAgY29uc3Qgdm5wX1RyYW5zYWN0aW9uTm8gPSB1cmxQYXJhbXMuZ2V0KCd2bnBfVHJhbnNhY3Rpb25ObycpO1xyXG4gICAgY29uc3Qgdm5wX1RyYW5zYWN0aW9uU3RhdHVzID0gdXJsUGFyYW1zLmdldCgndm5wX1RyYW5zYWN0aW9uU3RhdHVzJyk7XHJcbiAgICBjb25zdCB2bnBfVHhuUmVmID0gdXJsUGFyYW1zLmdldCgndm5wX1R4blJlZicpO1xyXG4gICAgY29uc3Qgdm5wX1NlY3VyZUhhc2ggPSB1cmxQYXJhbXMuZ2V0KCd2bnBfU2VjdXJlSGFzaCcpO1xyXG5cclxuICAgIC8vIEfhu61pIGPDoWMgdGhhbSBz4buRIG7DoHkgxJHhur9uIGJhY2tlbmRcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgdm5wX0Ftb3VudCxcclxuICAgICAgICB2bnBfQmFua0NvZGUsXHJcbiAgICAgICAgdm5wX0JhbmtUcmFuTm8sXHJcbiAgICAgICAgdm5wX0NhcmRUeXBlLFxyXG4gICAgICAgIHZucF9PcmRlckluZm8sXHJcbiAgICAgICAgdm5wX1BheURhdGUsXHJcbiAgICAgICAgdm5wX1Jlc3BvbnNlQ29kZSxcclxuICAgICAgICB2bnBfVG1uQ29kZSxcclxuICAgICAgICB2bnBfVHJhbnNhY3Rpb25ObyxcclxuICAgICAgICB2bnBfVHJhbnNhY3Rpb25TdGF0dXMsXHJcbiAgICAgICAgdm5wX1R4blJlZixcclxuICAgICAgICB2bnBfU2VjdXJlSGFzaFxyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCBheGlvcy5wb3N0KCcvdGhhbmtzJywgZGF0YSlcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MjIpIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICBzZXRFcnJvcnMoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4gICAgXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2bnBheV9wYXltZW50LGNvbmZpcm1fcGF5bWVudCxcclxuXHJcbiBcclxuICAgIH07XHJcbn07Il0sIm5hbWVzIjpbInVzZVNXUiIsImF4aW9zIiwidXNlRWZmZWN0IiwidXNlUGFyYW1zIiwidXNlclBheW1lbnQiLCJtaWRkbGV3YXJlIiwicmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQiLCJjc3JmIiwiZ2V0Iiwidm5wYXlfcGF5bWVudCIsInNldEVycm9ycyIsInNldFN0YXR1cyIsInByb3BzIiwicG9zdCIsInJlc3BvbnNlVHlwZSIsInRoZW4iLCJyZXNwb25zZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImRhdGEiLCJjb2RlIiwic3RhdHVzIiwiY2F0Y2giLCJlcnJvciIsImVycm9ycyIsImNvbmZpcm1fcGF5bWVudCIsInVybFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsInZucF9BbW91bnQiLCJ2bnBfQmFua0NvZGUiLCJ2bnBfQmFua1RyYW5ObyIsInZucF9DYXJkVHlwZSIsInZucF9PcmRlckluZm8iLCJ2bnBfUGF5RGF0ZSIsInZucF9SZXNwb25zZUNvZGUiLCJ2bnBfVG1uQ29kZSIsInZucF9UcmFuc2FjdGlvbk5vIiwidm5wX1RyYW5zYWN0aW9uU3RhdHVzIiwidm5wX1R4blJlZiIsInZucF9TZWN1cmVIYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/payment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/plan.js":
/*!***************************!*\
  !*** ./src/hooks/plan.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userPlan: function() { return /* binding */ userPlan; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst userPlan = function() {\n    let { middleware, redirectIfAuthenticated } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const params = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams)();\n    const { data: subscriptionPlans, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/subscription_plans\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/subscription_plans\").then((res)=>res.data.subscriptionPlans).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const updatePlan = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].put(\"/subscription_plans/{id}\", props).then((response)=>{\n            // console.log(response)\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    const createPlan = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/subscription_plans/create\", props).then((response)=>{\n            // console.log(response)\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n            console.log(error);\n        });\n    };\n    const destroyPlan = async (param)=>{\n        let { password, setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].delete(\"/subscription_plans/{id}\", {\n            data: {\n                password,\n                ...props\n            }\n        }).then((response)=>{\n            setStatus(response.data.status);\n        //   window.location.pathname = '/login';\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    return {\n        subscriptionPlans,\n        error,\n        mutate,\n        updatePlan,\n        createPlan,\n        destroyPlan\n    };\n};\n_s(userPlan, \"wrebZraxLskhoztI8XEqJEVQlgI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useParams,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUGFyYW1zLCB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXHJcblxyXG5leHBvcnQgY29uc3QgdXNlclBsYW4gPSAoeyBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCB9ID0ge30pID0+IHtcclxuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXHJcbiAgICBjb25zdCBwYXJhbXMgPSB1c2VQYXJhbXMoKVxyXG4gICAgY29uc3QgeyBkYXRhOiBzdWJzY3JpcHRpb25QbGFucywgZXJyb3IsIG11dGF0ZSB9ID0gdXNlU1dSKCcvc3Vic2NyaXB0aW9uX3BsYW5zJywgKCkgPT5cclxuICAgIGF4aW9zXHJcbiAgICAgICAgLmdldCgnL3N1YnNjcmlwdGlvbl9wbGFucycpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5kYXRhLnN1YnNjcmlwdGlvblBsYW5zKVxyXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwOSkgdGhyb3cgZXJyb3JcclxuICAgICAgICB9KSxcclxuKVxyXG5jb25zdCBjc3JmID0gKCkgPT4gYXhpb3MuZ2V0KCcvc2FuY3R1bS9jc3JmLWNvb2tpZScpXHJcbmNvbnN0IHVwZGF0ZVBsYW4gPSBhc3luYyAoeyBzZXRFcnJvcnMsIHNldFN0YXR1cywgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgYXdhaXQgY3NyZigpXHJcblxyXG4gICAgc2V0RXJyb3JzKFtdKVxyXG4gICAgc2V0U3RhdHVzKG51bGwpXHJcblxyXG4gICAgYXhpb3NcclxuICAgICAgICAucHV0KCcvc3Vic2NyaXB0aW9uX3BsYW5zL3tpZH0nLCBwcm9wcylcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxyXG4gICAgICAgICAgICBzZXRTdGF0dXMocmVzcG9uc2UuZGF0YS5zdGF0dXMpfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MjIpIHRocm93IGVycm9yXHJcblxyXG4gICAgICAgICAgICBzZXRFcnJvcnMoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpXHJcbiAgICAgICAgfSlcclxufVxyXG5jb25zdCBjcmVhdGVQbGFuID0gYXN5bmMgKHsgc2V0RXJyb3JzLCBzZXRTdGF0dXMsIC4uLnByb3BzIH0pID0+IHtcclxuICAgIGF3YWl0IGNzcmYoKVxyXG5cclxuICAgIHNldEVycm9ycyhbXSlcclxuICAgIHNldFN0YXR1cyhudWxsKVxyXG5cclxuICAgIGF4aW9zXHJcbiAgICAgICAgLnBvc3QoJy9zdWJzY3JpcHRpb25fcGxhbnMvY3JlYXRlJywgcHJvcHMpXHJcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXNwb25zZSlcclxuICAgICAgICAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKX0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSlcclxufVxyXG5jb25zdCBkZXN0cm95UGxhbiA9IGFzeW5jICh7IHBhc3N3b3JkLCBzZXRFcnJvcnMsIHNldFN0YXR1cywgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgYXdhaXQgY3NyZigpO1xyXG5cclxuICAgIHNldEVycm9ycyhbXSk7XHJcbiAgICBzZXRTdGF0dXMobnVsbCk7XHJcblxyXG4gICAgYXhpb3NcclxuICAgICAgICAuZGVsZXRlKCcvc3Vic2NyaXB0aW9uX3BsYW5zL3tpZH0nLCB7IGRhdGE6IHsgcGFzc3dvcmQsIC4uLnByb3BzIH0gfSlcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAvLyAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9ICcvbG9naW4nO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKTtcclxuICAgICAgICB9KTtcclxufTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdWJzY3JpcHRpb25QbGFucyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBtdXRhdGUsXHJcbiAgICAgICAgdXBkYXRlUGxhbixcclxuICAgICAgICBjcmVhdGVQbGFuLFxyXG4gICAgICAgIGRlc3Ryb3lQbGFuLFxyXG4gICAgfVxyXG59Il0sIm5hbWVzIjpbInVzZVNXUiIsImF4aW9zIiwidXNlRWZmZWN0IiwidXNlUGFyYW1zIiwidXNlUm91dGVyIiwidXNlclBsYW4iLCJtaWRkbGV3YXJlIiwicmVkaXJlY3RJZkF1dGhlbnRpY2F0ZWQiLCJyb3V0ZXIiLCJwYXJhbXMiLCJkYXRhIiwic3Vic2NyaXB0aW9uUGxhbnMiLCJlcnJvciIsIm11dGF0ZSIsImdldCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsInJlc3BvbnNlIiwic3RhdHVzIiwiY3NyZiIsInVwZGF0ZVBsYW4iLCJzZXRFcnJvcnMiLCJzZXRTdGF0dXMiLCJwcm9wcyIsInB1dCIsImVycm9ycyIsImNyZWF0ZVBsYW4iLCJwb3N0IiwiY29uc29sZSIsImxvZyIsImRlc3Ryb3lQbGFuIiwicGFzc3dvcmQiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/plan.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/profiles.js":
/*!*******************************!*\
  !*** ./src/hooks/profiles.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userProfiles: function() { return /* binding */ userProfiles; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\nvar _s = $RefreshSig$();\n\n\n\n\nconst userProfiles = (middleware, redirectIfAuthenticated)=>{\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    // const fetchUserProfile = async () => {\n    //   try {\n    //     const response = await axios.get('/profiles');\n    //     return response.data.profile;\n    //   } catch (error) {\n    //     console.error('Lỗi khi lấy thông tin hồ sơ người dùng:', error);\n    //     throw error;\n    //   }\n    // };\n    const { data: profile, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/profiles\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/profiles\").then((res)=>res.data.profile).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const csrf = ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/sanctum/csrf-cookie\");\n    const createProfiles = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/profiles\", props);\n            console.log(response);\n            setStatus(response.data.status);\n            // Gọi fetchUserProfile để cập nhật dữ liệu người dùng sau khi cập nhật hồ sơ\n            await fetchUserProfile();\n        } catch (error) {\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        }\n    };\n    const updateProfiles = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].put(\"/profiles\", props);\n            console.log(response);\n            setStatus(response.data.status);\n            // Gọi fetchUserProfile để cập nhật dữ liệu người dùng sau khi cập nhật hồ sơ\n            await fetchUserProfile();\n        } catch (error) {\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        }\n    };\n    // const storeOrUpdateProfiles = async ({ setErrors, setStatus, ...props }) => {\n    //   await csrf();\n    //   setErrors([]);\n    //   setStatus(null);\n    //   try {\n    //     const response = await axios.post('/store-or-update-profile', props);\n    //     console.log(response);\n    //     setStatus(response.data.status);\n    //     // Gọi fetchUserProfile để cập nhật dữ liệu người dùng sau khi cập nhật hồ sơ\n    //     await fetchUserProfile();\n    //   } catch (error) {\n    //     if (error.response.status !== 422) throw error;\n    //     setErrors(error.response.data.errors);\n    //   }\n    // };\n    const storeOrUpdateProfile = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/store-or-update-profile\", props).then((response)=>{\n            console.log(response);\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    const addImageProfile = async (param)=>{\n        let { setErrors, setStatus, ...props } = param;\n        await csrf();\n        setErrors([]);\n        setStatus(null);\n        _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/addImageProfile\", props).then((response)=>{\n            console.log(response);\n            setStatus(response.data.status);\n        }).catch((error)=>{\n            if (error.response.status !== 422) throw error;\n            setErrors(error.response.data.errors);\n        });\n    };\n    // const { data: getFirstNameAndFirstImage }  = async () => {\n    //   try {\n    //     const response = await axios.get('/first-name-and-image');\n    //     console.log(response.data);\n    //     return response.data;\n    //   } catch (error) {\n    //     if (error.response.status !== 409) throw error\n    //   }\n    // };\n    const { data: getFirstNameAndFirstImage, errors } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/first-name-and-image\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/first-name-and-image\").then((res)=>res.data).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    const updateImageProfile = async (param)=>{\n        let { id, index, new_image, setErrors, setStatus } = param;\n        await csrf();\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].put(\"/profiles/\".concat(id, \"/images/\").concat(index), {\n                new_image\n            });\n            if (response.data.status === \"image-profile-updated\") {\n                mutate(); // Refresh profile data\n                setStatus(response.data.status);\n            }\n        } catch (error) {\n            if (error.response && error.response.status !== 422) {\n                throw error;\n            }\n            setErrors(error.response.data.errors);\n        }\n    };\n    const deleteImageProfile = async (param)=>{\n        let { id, index, setErrors, setStatus } = param;\n        await csrf();\n        try {\n            const response = await _lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].delete(\"/profiles/\".concat(id, \"/images/\").concat(index));\n            if (response.data.status === \"image-profile-deleted\") {\n                mutate(); // Refresh profile data\n                setStatus(response.data.status);\n            }\n        } catch (error) {\n            if (error.response && error.response.status !== 422) {\n                throw error;\n            }\n            setErrors(error.response.data.errors);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!profile && error) {\n            router.push(\"/setting-profile\");\n        }\n    }, [\n        profile,\n        error\n    ]);\n    return {\n        profile,\n        error,\n        mutate,\n        createProfiles,\n        updateProfiles,\n        // fetchUserProfile,\n        storeOrUpdateProfile,\n        addImageProfile,\n        getFirstNameAndFirstImage,\n        errors,\n        deleteImageProfile,\n        updateImageProfile\n    };\n};\n_s(userProfiles, \"Or9IsJcvs5oQl/4T68OInKNrEKo=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9wcm9maWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlCO0FBQ1E7QUFDVztBQUNYO0FBRTFCLE1BQU1JLGVBQWUsQ0FBRUMsWUFBWUM7O0lBQ3hDLE1BQU1DLFNBQVNMLDBEQUFTQTtJQUV4Qix5Q0FBeUM7SUFDekMsVUFBVTtJQUNWLHFEQUFxRDtJQUNyRCxvQ0FBb0M7SUFDcEMsc0JBQXNCO0lBQ3RCLHVFQUF1RTtJQUN2RSxtQkFBbUI7SUFDbkIsTUFBTTtJQUNOLEtBQUs7SUFFTCxNQUFNLEVBQUVNLE1BQU1DLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR1gsK0NBQU1BLENBQUMsYUFBYSxJQUM3REMsa0RBQUtBLENBQ0FXLEdBQUcsQ0FBQyxhQUNKQyxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlOLElBQUksQ0FBQ0MsT0FBTyxFQUM1Qk0sS0FBSyxDQUFDTCxDQUFBQTtZQUNILElBQUlBLE1BQU1NLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUssTUFBTVA7UUFFN0M7SUFJSixNQUFNUSxPQUFPLElBQU1qQixrREFBS0EsQ0FBQ1csR0FBRyxDQUFDO0lBRzdCLE1BQU1PLGlCQUFpQjtZQUFPLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87UUFDOUQsTUFBTUo7UUFFTkUsVUFBVSxFQUFFO1FBQ1pDLFVBQVU7UUFFVixJQUFJO1lBQ0YsTUFBTUwsV0FBVyxNQUFNZixrREFBS0EsQ0FBQ3NCLElBQUksQ0FBQyxhQUFhRDtZQUMvQ0UsUUFBUUMsR0FBRyxDQUFDVDtZQUNaSyxVQUFVTCxTQUFTUixJQUFJLENBQUNTLE1BQU07WUFDOUIsNkVBQTZFO1lBQzdFLE1BQU1TO1FBQ1IsRUFBRSxPQUFPaEIsT0FBTztZQUNkLElBQUlBLE1BQU1NLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUssTUFBTVA7WUFFekNVLFVBQVVWLE1BQU1NLFFBQVEsQ0FBQ1IsSUFBSSxDQUFDbUIsTUFBTTtRQUN0QztJQUNGO0lBRUEsTUFBTUMsaUJBQWlCO1lBQU8sRUFBRVIsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztRQUM5RCxNQUFNSjtRQUVORSxVQUFVLEVBQUU7UUFDWkMsVUFBVTtRQUVWLElBQUk7WUFDRixNQUFNTCxXQUFXLE1BQU1mLGtEQUFLQSxDQUFDNEIsR0FBRyxDQUFDLGFBQWFQO1lBQzlDRSxRQUFRQyxHQUFHLENBQUNUO1lBQ1pLLFVBQVVMLFNBQVNSLElBQUksQ0FBQ1MsTUFBTTtZQUM5Qiw2RUFBNkU7WUFDN0UsTUFBTVM7UUFDUixFQUFFLE9BQU9oQixPQUFPO1lBQ2QsSUFBSUEsTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSyxNQUFNUDtZQUV6Q1UsVUFBVVYsTUFBTU0sUUFBUSxDQUFDUixJQUFJLENBQUNtQixNQUFNO1FBQ3RDO0lBQ0Y7SUFDQSxnRkFBZ0Y7SUFDaEYsa0JBQWtCO0lBRWxCLG1CQUFtQjtJQUNuQixxQkFBcUI7SUFFckIsVUFBVTtJQUNWLDRFQUE0RTtJQUM1RSw2QkFBNkI7SUFDN0IsdUNBQXVDO0lBQ3ZDLG9GQUFvRjtJQUNwRixnQ0FBZ0M7SUFDaEMsc0JBQXNCO0lBQ3RCLHNEQUFzRDtJQUV0RCw2Q0FBNkM7SUFDN0MsTUFBTTtJQUNOLEtBQUs7SUFFTCxNQUFNRyx1QkFBdUI7WUFBTyxFQUFFVixTQUFTLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO1FBQ3BFLE1BQU1KO1FBRU5FLFVBQVUsRUFBRTtRQUNaQyxVQUFVO1FBRVZwQixrREFBS0EsQ0FDQXNCLElBQUksQ0FBQyw0QkFBNEJELE9BQ2pDVCxJQUFJLENBQUNHLENBQUFBO1lBQ0ZRLFFBQVFDLEdBQUcsQ0FBQ1Q7WUFDWkssVUFBVUwsU0FBU1IsSUFBSSxDQUFDUyxNQUFNO1FBQUMsR0FDbENGLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1lBRXpDVSxVQUFVVixNQUFNTSxRQUFRLENBQUNSLElBQUksQ0FBQ21CLE1BQU07UUFDeEM7SUFDUjtJQUVBLE1BQU1JLGtCQUFrQjtZQUFPLEVBQUVYLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87UUFDL0QsTUFBTUo7UUFFTkUsVUFBVSxFQUFFO1FBQ1pDLFVBQVU7UUFFVnBCLGtEQUFLQSxDQUNBc0IsSUFBSSxDQUFDLG9CQUFvQkQsT0FDekJULElBQUksQ0FBQ0csQ0FBQUE7WUFDRlEsUUFBUUMsR0FBRyxDQUFDVDtZQUNaSyxVQUFVTCxTQUFTUixJQUFJLENBQUNTLE1BQU07UUFBQyxHQUNsQ0YsS0FBSyxDQUFDTCxDQUFBQTtZQUNILElBQUlBLE1BQU1NLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUssTUFBTVA7WUFFekNVLFVBQVVWLE1BQU1NLFFBQVEsQ0FBQ1IsSUFBSSxDQUFDbUIsTUFBTTtRQUN4QztJQUNOO0lBRUEsNkRBQTZEO0lBQzdELFVBQVU7SUFDVixpRUFBaUU7SUFDakUsa0NBQWtDO0lBQ2xDLDRCQUE0QjtJQUM1QixzQkFBc0I7SUFDdEIscURBQXFEO0lBQ3JELE1BQU07SUFDTixLQUFLO0lBQ0wsTUFBTSxFQUFFbkIsTUFBTXdCLHlCQUF5QixFQUFFTCxNQUFNLEVBQUMsR0FBRzNCLCtDQUFNQSxDQUFDLHlCQUF5QixJQUMzRUMsa0RBQUtBLENBQ0FXLEdBQUcsQ0FBQyx5QkFDSkMsSUFBSSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJTixJQUFJLEVBQ3BCTyxLQUFLLENBQUNMLENBQUFBO1lBQ0gsSUFBSUEsTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSyxNQUFNUDtRQUM3QztJQUVSLE1BQU11QixxQkFBcUI7WUFBTyxFQUFFQyxFQUFFLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFaEIsU0FBUyxFQUFFQyxTQUFTLEVBQUU7UUFDOUUsTUFBTUg7UUFFTixJQUFJO1lBQ0YsTUFBTUYsV0FBVyxNQUFNZixrREFBS0EsQ0FBQzRCLEdBQUcsQ0FBQyxhQUEwQk0sT0FBYkQsSUFBRyxZQUFnQixPQUFOQyxRQUFTO2dCQUFFQztZQUFVO1lBQ2hGLElBQUlwQixTQUFTUixJQUFJLENBQUNTLE1BQU0sS0FBSyx5QkFBeUI7Z0JBQ3BETixVQUFVLHVCQUF1QjtnQkFDakNVLFVBQVVMLFNBQVNSLElBQUksQ0FBQ1MsTUFBTTtZQUNoQztRQUNGLEVBQUUsT0FBT1AsT0FBTztZQUNkLElBQUlBLE1BQU1NLFFBQVEsSUFBSU4sTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSztnQkFDbkQsTUFBTVA7WUFDUjtZQUNBVSxVQUFVVixNQUFNTSxRQUFRLENBQUNSLElBQUksQ0FBQ21CLE1BQU07UUFDdEM7SUFDRjtJQUVBLE1BQU1VLHFCQUFxQjtZQUFPLEVBQUVILEVBQUUsRUFBRUMsS0FBSyxFQUFFZixTQUFTLEVBQUVDLFNBQVMsRUFBRTtRQUNuRSxNQUFNSDtRQUVOLElBQUk7WUFDRixNQUFNRixXQUFXLE1BQU1mLGtEQUFLQSxDQUFDcUMsTUFBTSxDQUFDLGFBQTBCSCxPQUFiRCxJQUFHLFlBQWdCLE9BQU5DO1lBQzlELElBQUluQixTQUFTUixJQUFJLENBQUNTLE1BQU0sS0FBSyx5QkFBeUI7Z0JBQ3BETixVQUFVLHVCQUF1QjtnQkFDakNVLFVBQVVMLFNBQVNSLElBQUksQ0FBQ1MsTUFBTTtZQUNoQztRQUNGLEVBQUUsT0FBT1AsT0FBTztZQUNkLElBQUlBLE1BQU1NLFFBQVEsSUFBSU4sTUFBTU0sUUFBUSxDQUFDQyxNQUFNLEtBQUssS0FBSztnQkFDbkQsTUFBTVA7WUFDUjtZQUNBVSxVQUFVVixNQUFNTSxRQUFRLENBQUNSLElBQUksQ0FBQ21CLE1BQU07UUFDdEM7SUFDRjtJQUNKeEIsZ0RBQVNBLENBQUM7UUFDRixJQUFJLENBQUNNLFdBQVdDLE9BQU87WUFDbkJILE9BQU9nQyxJQUFJLENBQUM7UUFDaEI7SUFDSixHQUFHO1FBQUM5QjtRQUFTQztLQUFNO0lBR3JCLE9BQU87UUFDTEQ7UUFDQUM7UUFDQUM7UUFDQVE7UUFDQVM7UUFDQSxvQkFBb0I7UUFDcEJFO1FBQ0FDO1FBQ0FDO1FBQ0FMO1FBQ0FVO1FBQ0FKO0lBQ0Y7QUFDRixFQUFFO0dBOUxXN0I7O1FBQ0lGLHNEQUFTQTtRQVlpQkYsMkNBQU1BO1FBbUhFQSwyQ0FBTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3Byb2ZpbGVzLmpzPzI3MWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnLi4vbGliL2F4aW9zJztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXHJcblxyXG5leHBvcnQgY29uc3QgdXNlclByb2ZpbGVzID0gKCBtaWRkbGV3YXJlLCByZWRpcmVjdElmQXV0aGVudGljYXRlZCApID0+IHtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgLy8gY29uc3QgZmV0Y2hVc2VyUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcclxuICAvLyAgIHRyeSB7XHJcbiAgLy8gICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KCcvcHJvZmlsZXMnKTtcclxuICAvLyAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucHJvZmlsZTtcclxuICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ0zhu5dpIGtoaSBs4bqleSB0aMO0bmcgdGluIGjhu5Mgc8ahIG5nxrDhu51pIGTDuW5nOicsIGVycm9yKTtcclxuICAvLyAgICAgdGhyb3cgZXJyb3I7XHJcbiAgLy8gICB9XHJcbiAgLy8gfTtcclxuXHJcbiAgY29uc3QgeyBkYXRhOiBwcm9maWxlLCBlcnJvciwgbXV0YXRlIH0gPSB1c2VTV1IoJy9wcm9maWxlcycsICgpID0+XHJcbiAgYXhpb3NcclxuICAgICAgLmdldCgnL3Byb2ZpbGVzJylcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5kYXRhLnByb2ZpbGUpXHJcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MDkpIHRocm93IGVycm9yXHJcblxyXG4gICAgICB9KSxcclxuKVxyXG5cclxuXHJcbiAgY29uc3QgY3NyZiA9ICgpID0+IGF4aW9zLmdldCgnL3NhbmN0dW0vY3NyZi1jb29raWUnKTtcclxuXHJcblxyXG4gIGNvbnN0IGNyZWF0ZVByb2ZpbGVzID0gYXN5bmMgKHsgc2V0RXJyb3JzLCBzZXRTdGF0dXMsIC4uLnByb3BzIH0pID0+IHtcclxuICAgIGF3YWl0IGNzcmYoKTtcclxuXHJcbiAgICBzZXRFcnJvcnMoW10pO1xyXG4gICAgc2V0U3RhdHVzKG51bGwpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdCgnL3Byb2ZpbGVzJywgcHJvcHMpO1xyXG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgIC8vIEfhu41pIGZldGNoVXNlclByb2ZpbGUgxJHhu4MgY+G6rXAgbmjhuq10IGThu68gbGnhu4d1IG5nxrDhu51pIGTDuW5nIHNhdSBraGkgY+G6rXAgbmjhuq10IGjhu5Mgc8ahXHJcbiAgICAgIGF3YWl0IGZldGNoVXNlclByb2ZpbGUoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQyMikgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgICBzZXRFcnJvcnMoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVByb2ZpbGVzID0gYXN5bmMgKHsgc2V0RXJyb3JzLCBzZXRTdGF0dXMsIC4uLnByb3BzIH0pID0+IHtcclxuICAgIGF3YWl0IGNzcmYoKTtcclxuXHJcbiAgICBzZXRFcnJvcnMoW10pO1xyXG4gICAgc2V0U3RhdHVzKG51bGwpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucHV0KCcvcHJvZmlsZXMnLCBwcm9wcyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKTtcclxuICAgICAgLy8gR+G7jWkgZmV0Y2hVc2VyUHJvZmlsZSDEkeG7gyBj4bqtcCBuaOG6rXQgZOG7ryBsaeG7h3UgbmfGsOG7nWkgZMO5bmcgc2F1IGtoaSBj4bqtcCBuaOG6rXQgaOG7kyBzxqFcclxuICAgICAgYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgICAgIHNldEVycm9ycyhlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycyk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBjb25zdCBzdG9yZU9yVXBkYXRlUHJvZmlsZXMgPSBhc3luYyAoeyBzZXRFcnJvcnMsIHNldFN0YXR1cywgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIC8vICAgYXdhaXQgY3NyZigpO1xyXG5cclxuICAvLyAgIHNldEVycm9ycyhbXSk7XHJcbiAgLy8gICBzZXRTdGF0dXMobnVsbCk7XHJcblxyXG4gIC8vICAgdHJ5IHtcclxuICAvLyAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KCcvc3RvcmUtb3ItdXBkYXRlLXByb2ZpbGUnLCBwcm9wcyk7XHJcbiAgLy8gICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcclxuICAvLyAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKTtcclxuICAvLyAgICAgLy8gR+G7jWkgZmV0Y2hVc2VyUHJvZmlsZSDEkeG7gyBj4bqtcCBuaOG6rXQgZOG7ryBsaeG7h3UgbmfGsOG7nWkgZMO5bmcgc2F1IGtoaSBj4bqtcCBuaOG6rXQgaOG7kyBzxqFcclxuICAvLyAgICAgYXdhaXQgZmV0Y2hVc2VyUHJvZmlsZSgpO1xyXG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAvLyAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgLy8gICAgIHNldEVycm9ycyhlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycyk7XHJcbiAgLy8gICB9XHJcbiAgLy8gfTtcclxuXHJcbiAgY29uc3Qgc3RvcmVPclVwZGF0ZVByb2ZpbGUgPSBhc3luYyAoeyBzZXRFcnJvcnMsIHNldFN0YXR1cywgLi4ucHJvcHMgfSkgPT4ge1xyXG4gICAgYXdhaXQgY3NyZigpXHJcbiAgICBcclxuICAgIHNldEVycm9ycyhbXSlcclxuICAgIHNldFN0YXR1cyhudWxsKVxyXG4gIFxyXG4gICAgYXhpb3NcclxuICAgICAgICAucG9zdCgnL3N0b3JlLW9yLXVwZGF0ZS1wcm9maWxlJywgcHJvcHMpXHJcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSlcclxuICAgICAgICAgICAgc2V0U3RhdHVzKHJlc3BvbnNlLmRhdGEuc3RhdHVzKX0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgICAgICAgc2V0RXJyb3JzKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbmNvbnN0IGFkZEltYWdlUHJvZmlsZSA9IGFzeW5jICh7IHNldEVycm9ycywgc2V0U3RhdHVzLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgYXdhaXQgY3NyZigpXHJcbiAgXHJcbiAgc2V0RXJyb3JzKFtdKVxyXG4gIHNldFN0YXR1cyhudWxsKVxyXG5cclxuICBheGlvc1xyXG4gICAgICAucG9zdCgnL2FkZEltYWdlUHJvZmlsZScsIHByb3BzKVxyXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSlcclxuICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyl9KVxyXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDIyKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgICAgIHNldEVycm9ycyhlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycylcclxuICAgICAgfSlcclxufVxyXG5cclxuLy8gY29uc3QgeyBkYXRhOiBnZXRGaXJzdE5hbWVBbmRGaXJzdEltYWdlIH0gID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgIHRyeSB7XHJcbi8vICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCgnL2ZpcnN0LW5hbWUtYW5kLWltYWdlJyk7XHJcbi8vICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5kYXRhKTtcclxuLy8gICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4vLyAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MDkpIHRocm93IGVycm9yXHJcbi8vICAgfVxyXG4vLyB9O1xyXG5jb25zdCB7IGRhdGE6IGdldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2UsIGVycm9yc30gPSB1c2VTV1IoJy9maXJzdC1uYW1lLWFuZC1pbWFnZScsICgpID0+XHJcbiAgICAgICAgYXhpb3NcclxuICAgICAgICAgICAgLmdldCgnL2ZpcnN0LW5hbWUtYW5kLWltYWdlJylcclxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5kYXRhKVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyAhPT0gNDA5KSB0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICB9KSxcclxuICAgIClcclxuICAgIGNvbnN0IHVwZGF0ZUltYWdlUHJvZmlsZSA9IGFzeW5jICh7IGlkLCBpbmRleCwgbmV3X2ltYWdlLCBzZXRFcnJvcnMsIHNldFN0YXR1cyB9KSA9PiB7XHJcbiAgICAgIGF3YWl0IGNzcmYoKTtcclxuICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucHV0KGAvcHJvZmlsZXMvJHtpZH0vaW1hZ2VzLyR7aW5kZXh9YCwgeyBuZXdfaW1hZ2UgfSk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnaW1hZ2UtcHJvZmlsZS11cGRhdGVkJykge1xyXG4gICAgICAgICAgbXV0YXRlKCk7IC8vIFJlZnJlc2ggcHJvZmlsZSBkYXRhXHJcbiAgICAgICAgICBzZXRTdGF0dXMocmVzcG9uc2UuZGF0YS5zdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzICE9PSA0MjIpIHtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRFcnJvcnMoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBkZWxldGVJbWFnZVByb2ZpbGUgPSBhc3luYyAoeyBpZCwgaW5kZXgsIHNldEVycm9ycywgc2V0U3RhdHVzIH0pID0+IHtcclxuICAgICAgYXdhaXQgY3NyZigpO1xyXG4gICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYC9wcm9maWxlcy8ke2lkfS9pbWFnZXMvJHtpbmRleH1gKTtcclxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdpbWFnZS1wcm9maWxlLWRlbGV0ZWQnKSB7XHJcbiAgICAgICAgICBtdXRhdGUoKTsgLy8gUmVmcmVzaCBwcm9maWxlIGRhdGFcclxuICAgICAgICAgIHNldFN0YXR1cyhyZXNwb25zZS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQyMikge1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEVycm9ycyhlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFwcm9maWxlICYmIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci5wdXNoKCcvc2V0dGluZy1wcm9maWxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3Byb2ZpbGUsIGVycm9yXSk7XHJcblxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcHJvZmlsZSxcclxuICAgIGVycm9yLFxyXG4gICAgbXV0YXRlLFxyXG4gICAgY3JlYXRlUHJvZmlsZXMsXHJcbiAgICB1cGRhdGVQcm9maWxlcyxcclxuICAgIC8vIGZldGNoVXNlclByb2ZpbGUsXHJcbiAgICBzdG9yZU9yVXBkYXRlUHJvZmlsZSxcclxuICAgIGFkZEltYWdlUHJvZmlsZSxcclxuICAgIGdldEZpcnN0TmFtZUFuZEZpcnN0SW1hZ2UsXHJcbiAgICBlcnJvcnMsXHJcbiAgICBkZWxldGVJbWFnZVByb2ZpbGUsXHJcbiAgICB1cGRhdGVJbWFnZVByb2ZpbGUsXHJcbiAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbInVzZVNXUiIsImF4aW9zIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlclByb2ZpbGVzIiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwicm91dGVyIiwiZGF0YSIsInByb2ZpbGUiLCJlcnJvciIsIm11dGF0ZSIsImdldCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsInJlc3BvbnNlIiwic3RhdHVzIiwiY3NyZiIsImNyZWF0ZVByb2ZpbGVzIiwic2V0RXJyb3JzIiwic2V0U3RhdHVzIiwicHJvcHMiLCJwb3N0IiwiY29uc29sZSIsImxvZyIsImZldGNoVXNlclByb2ZpbGUiLCJlcnJvcnMiLCJ1cGRhdGVQcm9maWxlcyIsInB1dCIsInN0b3JlT3JVcGRhdGVQcm9maWxlIiwiYWRkSW1hZ2VQcm9maWxlIiwiZ2V0Rmlyc3ROYW1lQW5kRmlyc3RJbWFnZSIsInVwZGF0ZUltYWdlUHJvZmlsZSIsImlkIiwiaW5kZXgiLCJuZXdfaW1hZ2UiLCJkZWxldGVJbWFnZVByb2ZpbGUiLCJkZWxldGUiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/profiles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/recent.js":
/*!*****************************!*\
  !*** ./src/hooks/recent.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   userRecent: function() { return /* binding */ userRecent; }\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var _lib_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/axios */ \"(app-pages-browser)/./src/lib/axios.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst userRecent = function() {\n    let { middleware, redirectIfAuthenticated } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const { data: responseData, error, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"/recent-messages\", ()=>_lib_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/recent-messages\").then((res)=>res.data).catch((error)=>{\n            if (error.response.status !== 409) throw error;\n        }));\n    // Trích xuất dữ liệu từ responseData\n    const recentMessages = responseData === null || responseData === void 0 ? void 0 : responseData.recentMessages;\n    return {\n        recentMessages,\n        error,\n        mutate\n    };\n};\n_s(userRecent, \"OZNWQnPBmNV43uscnPzN1yL2n5U=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy9yZWNlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QjtBQUNRO0FBQ0M7QUFDVTtBQUVyQyxNQUFNSSxhQUFhO1FBQUMsRUFBRUMsVUFBVSxFQUFFQyx1QkFBdUIsRUFBRSxvRUFBRyxDQUFDOztJQUNsRSxNQUFNLEVBQUVDLE1BQU1DLFlBQVksRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR1YsK0NBQU1BLENBQUUsb0JBQW1CLElBQ3JFQyxrREFBS0EsQ0FDQVUsR0FBRyxDQUFFLG9CQUNMQyxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlOLElBQUksRUFDcEJPLEtBQUssQ0FBQ0wsQ0FBQUE7WUFDSCxJQUFJQSxNQUFNTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLE1BQU1QO1FBQzdDO0lBR1IscUNBQXFDO0lBQ3JDLE1BQU1RLGlCQUFpQlQseUJBQUFBLG1DQUFBQSxhQUFjUyxjQUFjO0lBRW5ELE9BQU87UUFDSEE7UUFDQVI7UUFDQUM7SUFDSjtBQUNKLEVBQUU7R0FsQldOOztRQUNxQ0osMkNBQU1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy9yZWNlbnQuanM/OTdkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXNlU1dSIGZyb20gJ3N3cic7XHJcbmltcG9ydCBheGlvcyBmcm9tICcuLi9saWIvYXhpb3MnO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlclJlY2VudCA9ICh7IG1pZGRsZXdhcmUsIHJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIH0gPSB7fSkgPT4ge1xyXG4gICAgY29uc3QgeyBkYXRhOiByZXNwb25zZURhdGEsIGVycm9yLCBtdXRhdGUgfSA9IHVzZVNXUihgL3JlY2VudC1tZXNzYWdlc2AsICgpID0+XHJcbiAgICAgICAgYXhpb3NcclxuICAgICAgICAgICAgLmdldChgL3JlY2VudC1tZXNzYWdlc2ApXHJcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMuZGF0YSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwOSkgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUcsOtY2ggeHXhuqV0IGThu68gbGnhu4d1IHThu6sgcmVzcG9uc2VEYXRhXHJcbiAgICBjb25zdCByZWNlbnRNZXNzYWdlcyA9IHJlc3BvbnNlRGF0YT8ucmVjZW50TWVzc2FnZXM7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWNlbnRNZXNzYWdlcyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBtdXRhdGUsXHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsidXNlU1dSIiwiYXhpb3MiLCJ1c2VFZmZlY3QiLCJ1c2VQYXJhbXMiLCJ1c2VyUmVjZW50IiwibWlkZGxld2FyZSIsInJlZGlyZWN0SWZBdXRoZW50aWNhdGVkIiwiZGF0YSIsInJlc3BvbnNlRGF0YSIsImVycm9yIiwibXV0YXRlIiwiZ2V0IiwidGhlbiIsInJlcyIsImNhdGNoIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJyZWNlbnRNZXNzYWdlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/recent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/axios.js":
/*!**************************!*\
  !*** ./src/lib/axios.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\nconst axios = axios__WEBPACK_IMPORTED_MODULE_0___default().create({\n    baseURL: \"http://localhost:8000\",\n    headers: {\n        \"X-Requested-With\": \"XMLHttpRequest\"\n    },\n    withCredentials: true,\n    withXSRFToken: true\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (axios);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXhpb3MuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXlCO0FBRXpCLE1BQU1DLFFBQVFELG1EQUFZLENBQUM7SUFDdkJHLFNBQVNDLHVCQUFtQztJQUM1Q0csU0FBUztRQUNMLG9CQUFvQjtJQUN4QjtJQUNBQyxpQkFBaUI7SUFDakJDLGVBQWU7QUFDbkI7QUFFQSwrREFBZVIsS0FBS0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2F4aW9zLmpzP2Y3OTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEF4aW9zIGZyb20gJ2F4aW9zJ1xuXG5jb25zdCBheGlvcyA9IEF4aW9zLmNyZWF0ZSh7XG4gICAgYmFzZVVSTDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwsXG4gICAgaGVhZGVyczoge1xuICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgfSxcbiAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgd2l0aFhTUkZUb2tlbjogdHJ1ZVxufSlcblxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiJdLCJuYW1lcyI6WyJBeGlvcyIsImF4aW9zIiwiY3JlYXRlIiwiYmFzZVVSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCIsImhlYWRlcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ3aXRoWFNSRlRva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/axios.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/ /* global define */ (function() {\n    \"use strict\";\n    var hasOwn = {}.hasOwnProperty;\n    function classNames() {\n        var classes = \"\";\n        for(var i = 0; i < arguments.length; i++){\n            var arg = arguments[i];\n            if (arg) {\n                classes = appendClass(classes, parseValue(arg));\n            }\n        }\n        return classes;\n    }\n    function parseValue(arg) {\n        if (typeof arg === \"string\" || typeof arg === \"number\") {\n            return arg;\n        }\n        if (typeof arg !== \"object\") {\n            return \"\";\n        }\n        if (Array.isArray(arg)) {\n            return classNames.apply(null, arg);\n        }\n        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n            return arg.toString();\n        }\n        var classes = \"\";\n        for(var key in arg){\n            if (hasOwn.call(arg, key) && arg[key]) {\n                classes = appendClass(classes, key);\n            }\n        }\n        return classes;\n    }\n    function appendClass(value, newClass) {\n        if (!newClass) {\n            return value;\n        }\n        if (value) {\n            return value + \" \" + newClass;\n        }\n        return value + newClass;\n    }\n    if ( true && module.exports) {\n        classNames.default = classNames;\n        module.exports = classNames;\n    } else if (true) {\n        // register as 'classnames', consistent with npm package name\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return classNames;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztBQUlBLEdBQ0EsaUJBQWlCLEdBRWhCO0lBQ0E7SUFFQSxJQUFJQSxTQUFTLENBQUMsRUFBRUMsY0FBYztJQUU5QixTQUFTQztRQUNSLElBQUlDLFVBQVU7UUFFZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQzFDLElBQUlHLE1BQU1GLFNBQVMsQ0FBQ0QsRUFBRTtZQUN0QixJQUFJRyxLQUFLO2dCQUNSSixVQUFVSyxZQUFZTCxTQUFTTSxXQUFXRjtZQUMzQztRQUNEO1FBRUEsT0FBT0o7SUFDUjtJQUVBLFNBQVNNLFdBQVlGLEdBQUc7UUFDdkIsSUFBSSxPQUFPQSxRQUFRLFlBQVksT0FBT0EsUUFBUSxVQUFVO1lBQ3ZELE9BQU9BO1FBQ1I7UUFFQSxJQUFJLE9BQU9BLFFBQVEsVUFBVTtZQUM1QixPQUFPO1FBQ1I7UUFFQSxJQUFJRyxNQUFNQyxPQUFPLENBQUNKLE1BQU07WUFDdkIsT0FBT0wsV0FBV1UsS0FBSyxDQUFDLE1BQU1MO1FBQy9CO1FBRUEsSUFBSUEsSUFBSU0sUUFBUSxLQUFLQyxPQUFPQyxTQUFTLENBQUNGLFFBQVEsSUFBSSxDQUFDTixJQUFJTSxRQUFRLENBQUNBLFFBQVEsR0FBR0csUUFBUSxDQUFDLGtCQUFrQjtZQUNyRyxPQUFPVCxJQUFJTSxRQUFRO1FBQ3BCO1FBRUEsSUFBSVYsVUFBVTtRQUVkLElBQUssSUFBSWMsT0FBT1YsSUFBSztZQUNwQixJQUFJUCxPQUFPa0IsSUFBSSxDQUFDWCxLQUFLVSxRQUFRVixHQUFHLENBQUNVLElBQUksRUFBRTtnQkFDdENkLFVBQVVLLFlBQVlMLFNBQVNjO1lBQ2hDO1FBQ0Q7UUFFQSxPQUFPZDtJQUNSO0lBRUEsU0FBU0ssWUFBYVcsS0FBSyxFQUFFQyxRQUFRO1FBQ3BDLElBQUksQ0FBQ0EsVUFBVTtZQUNkLE9BQU9EO1FBQ1I7UUFFQSxJQUFJQSxPQUFPO1lBQ1YsT0FBT0EsUUFBUSxNQUFNQztRQUN0QjtRQUVBLE9BQU9ELFFBQVFDO0lBQ2hCO0lBRUEsSUFBSSxLQUFrQixJQUFlQyxPQUFPQyxPQUFPLEVBQUU7UUFDcERwQixXQUFXcUIsT0FBTyxHQUFHckI7UUFDckJtQixPQUFPQyxPQUFPLEdBQUdwQjtJQUNsQixPQUFPLElBQUksSUFBNEUsRUFBRTtRQUN4Riw2REFBNkQ7UUFDN0RzQixpQ0FBcUIsRUFBRSxtQ0FBRTtZQUN4QixPQUFPdEI7UUFDUixDQUFDO0FBQUEsa0dBQUM7SUFDSCxPQUFPLEVBRU47QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcz83ZDUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuXHRDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cblx0TGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcblx0aHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9ICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoYXJnKSB7XG5cdFx0XHRcdGNsYXNzZXMgPSBhcHBlbmRDbGFzcyhjbGFzc2VzLCBwYXJzZVZhbHVlKGFyZykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VWYWx1ZSAoYXJnKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXR1cm4gYXJnO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZy50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJiAhYXJnLnRvU3RyaW5nLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSkge1xuXHRcdFx0cmV0dXJuIGFyZy50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHZhciBjbGFzc2VzID0gJyc7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdGNsYXNzZXMgPSBhcHBlbmRDbGFzcyhjbGFzc2VzLCBrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwZW5kQ2xhc3MgKHZhbHVlLCBuZXdDbGFzcykge1xuXHRcdGlmICghbmV3Q2xhc3MpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlICsgJyAnICsgbmV3Q2xhc3M7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdmFsdWUgKyBuZXdDbGFzcztcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJuYW1lcyI6WyJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZyIsImFwcGVuZENsYXNzIiwicGFyc2VWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImFwcGx5IiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJpbmNsdWRlcyIsImtleSIsImNhbGwiLCJ2YWx1ZSIsIm5ld0NsYXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/classnames/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   mutate: function() { return /* binding */ mutate; },\n/* harmony export */   unstable_serialize: function() { return /* binding */ unstable_serialize; },\n/* harmony export */   useSWRConfig: function() { return /* binding */ useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar noop = function() {};\n// Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nvar UNDEFINED = /*#__NOINLINE__*/ noop();\nvar OBJECT = Object;\nvar isUndefined = function(v) {\n    return v === UNDEFINED;\n};\nvar isFunction = function(v) {\n    return typeof v == \"function\";\n};\nvar mergeObjects = function(a, b) {\n    return OBJECT.assign({}, a, b);\n};\nvar STR_UNDEFINED = \"undefined\";\n// NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nvar hasWindow = function() {\n    return \"object\" != STR_UNDEFINED;\n};\nvar hasDocument = function() {\n    return typeof document != STR_UNDEFINED;\n};\nvar hasRequestAnimationFrame = function() {\n    return hasWindow() && typeof window[\"requestAnimationFrame\"] != STR_UNDEFINED;\n};\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\nvar stableHash = function(arg) {\n    var type = typeof arg;\n    var constructor = arg && arg.constructor;\n    var isDate = constructor == Date;\n    var result;\n    var index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + \"~\";\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = \"@\";\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + \",\";\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = \"#\";\n            var keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + \":\" + stableHash(arg[index]) + \",\";\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == \"symbol\" ? arg.toString() : type == \"string\" ? JSON.stringify(arg) : \"\" + arg;\n    }\n    return result;\n};\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */ var online = true;\nvar isOnline = function() {\n    return online;\n};\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument();\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\nvar isVisible = function() {\n    var visibilityState = hasDoc && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== \"hidden\";\n};\nvar initFocus = function(callback) {\n    // focus revalidate\n    onDocumentEvent(\"visibilitychange\", callback);\n    onWindowEvent(\"focus\", callback);\n    return function() {\n        offDocumentEvent(\"visibilitychange\", callback);\n        offWindowEvent(\"focus\", callback);\n    };\n};\nvar initReconnect = function(callback) {\n    // revalidate on reconnected\n    var onOnline = function() {\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    var onOffline = function() {\n        online = false;\n    };\n    onWindowEvent(\"online\", onOnline);\n    onWindowEvent(\"offline\", onOffline);\n    return function() {\n        offWindowEvent(\"online\", onOnline);\n        offWindowEvent(\"offline\", onOffline);\n    };\n};\nvar preset = {\n    isOnline: isOnline,\n    isVisible: isVisible\n};\nvar defaultConfigOptions = {\n    initFocus: initFocus,\n    initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || \"Deno\" in window;\n// Polyfill requestAnimationFrame\nvar rAF = function(f) {\n    return hasRequestAnimationFrame() ? window[\"requestAnimationFrame\"](f) : setTimeout(f, 1);\n};\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nvar navigatorConnection = typeof navigator !== \"undefined\" && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nvar slowConnection = !IS_SERVER && navigatorConnection && ([\n    \"slow-2g\",\n    \"2g\"\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nvar serialize = function(key) {\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = \"\";\n        }\n    }\n    var args = [].concat(key);\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == \"string\" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : \"\";\n    var infoKey = key ? \"$swr$\" + key : \"\";\n    return [\n        key,\n        args,\n        infoKey\n    ];\n};\n// Global state used to deduplicate requests and store listeners\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\nvar broadcastState = function(cache, key, data, error, isValidating, revalidate, broadcast) {\n    if (broadcast === void 0) {\n        broadcast = true;\n    }\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], FETCH = _a[3];\n    var revalidators = EVENT_REVALIDATORS[key];\n    var updaters = STATE_UPDATERS[key];\n    // Cache was populated, update states of all hooks.\n    if (broadcast && updaters) {\n        for(var i = 0; i < updaters.length; ++i){\n            updaters[i](data, error, isValidating);\n        }\n    }\n    // If we also need to revalidate, only do it for the first hook.\n    if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n            return revalidators[0](MUTATE_EVENT).then(function() {\n                return cache.get(key);\n            });\n        }\n    }\n    return cache.get(key);\n};\n// Global timestamp.\nvar __timestamp = 0;\nvar getTimestamp = function() {\n    return ++__timestamp;\n};\nvar internalMutate = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(void 0, void 0, void 0, function() {\n        var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n                    options = typeof _opts === \"boolean\" ? {\n                        revalidate: _opts\n                    } : _opts || {};\n                    populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n                    revalidate = options.revalidate !== false;\n                    rollbackOnError = options.rollbackOnError !== false;\n                    customOptimisticData = options.optimisticData;\n                    _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n                    if (!key) return [\n                        2 /*return*/ \n                    ];\n                    _b = SWRGlobalState.get(cache), MUTATION = _b[2];\n                    // If there is no new data provided, revalidate the key with current state.\n                    if (args.length < 3) {\n                        // Revalidate and broadcast state.\n                        return [\n                            2 /*return*/ ,\n                            broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)\n                        ];\n                    }\n                    data = _data;\n                    beforeMutationTs = getTimestamp();\n                    MUTATION[key] = [\n                        beforeMutationTs,\n                        0\n                    ];\n                    hasCustomOptimisticData = !isUndefined(customOptimisticData);\n                    rollbackData = cache.get(key);\n                    // Do optimistic data update.\n                    if (hasCustomOptimisticData) {\n                        optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n                        cache.set(key, optimisticData);\n                        broadcastState(cache, key, optimisticData);\n                    }\n                    if (isFunction(data)) {\n                        // `data` is a function, call it passing current cache value.\n                        try {\n                            data = data(cache.get(key));\n                        } catch (err) {\n                            // If it throws an error synchronously, we shouldn't update the cache.\n                            error = err;\n                        }\n                    }\n                    if (!(data && isFunction(data.then))) return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        data.catch(function(err) {\n                            error = err;\n                        })\n                    ];\n                case 1:\n                    // This means that the mutation is async, we need to check timestamps to\n                    // avoid race conditions.\n                    data = _c.sent();\n                    // Check if other mutations have occurred since we've started this mutation.\n                    // If there's a race we don't update cache or broadcast the change,\n                    // just return the data.\n                    if (beforeMutationTs !== MUTATION[key][0]) {\n                        if (error) throw error;\n                        return [\n                            2 /*return*/ ,\n                            data\n                        ];\n                    } else if (error && hasCustomOptimisticData && rollbackOnError) {\n                        // Rollback. Always populate the cache in this case but without\n                        // transforming the data.\n                        populateCache = true;\n                        data = rollbackData;\n                        cache.set(key, rollbackData);\n                    }\n                    _c.label = 2;\n                case 2:\n                    // If we should write back the cache after request.\n                    if (populateCache) {\n                        if (!error) {\n                            // Transform the result into data.\n                            if (isFunction(populateCache)) {\n                                data = populateCache(data, rollbackData);\n                            }\n                            // Only update cached data if there's no error. Data can be `undefined` here.\n                            cache.set(key, data);\n                        }\n                        // Always update or reset the error.\n                        cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n                            error: error\n                        }));\n                    }\n                    // Reset the timestamp to mark the mutation has ended.\n                    MUTATION[key][1] = getTimestamp();\n                    return [\n                        4 /*yield*/ ,\n                        broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache)\n                    ];\n                case 3:\n                    res = _c.sent();\n                    // Throw error or return data\n                    if (error) throw error;\n                    return [\n                        2 /*return*/ ,\n                        populateCache ? res : data\n                    ];\n            }\n        });\n    });\n};\nvar revalidateAllKeys = function(revalidators, type) {\n    for(var key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nvar initCache = function(provider, options) {\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that bound to\n    // the cache.\n    // Provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        var opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        var EVENT_REVALIDATORS = {};\n        var mutate = internalMutate.bind(UNDEFINED, provider);\n        var unmount = noop;\n        // Update the state if it's new, or the provider has been extended.\n        SWRGlobalState.set(provider, [\n            EVENT_REVALIDATORS,\n            {},\n            {},\n            {},\n            mutate\n        ]);\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        if (!IS_SERVER) {\n            // When listening to the native events for auto revalidations,\n            // we intentionally put a delay (setTimeout) here to make sure they are\n            // fired after immediate JavaScript executions, which can possibly be\n            // React's state updates.\n            // This avoids some unnecessary revalidations such as\n            // https://github.com/vercel/swr/issues/1680.\n            var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n            var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n            unmount = function() {\n                releaseFocus_1 && releaseFocus_1();\n                releaseReconnect_1 && releaseReconnect_1();\n                // When un-mounting, we need to remove the cache provider from the state\n                // storage too because it's a side-effect. Otherwise when re-mounting we\n                // will not re-register those event listeners.\n                SWRGlobalState.delete(provider);\n            };\n        }\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n// error retry\nvar onErrorRetry = function(_, __, config, revalidate, opts) {\n    var maxRetryCount = config.errorRetryCount;\n    var currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\n// Default cache provider\nvar _a = initCache(new Map()), cache = _a[0], mutate = _a[1];\n// Default config\nvar defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry: onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare: function(currentData, newData) {\n        return stableHash(currentData) == stableHash(newData);\n    },\n    isPaused: function() {\n        return false;\n    },\n    cache: cache,\n    mutate: mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\nvar mergeConfigs = function(a, b) {\n    // Need to create a new object to avoid mutating the original here.\n    var v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        var u1 = a.use, f1 = a.fallback;\n        var u2 = b.use, f2 = b.fallback;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\nvar SWRConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar SWRConfig$1 = function(props) {\n    _s();\n    var value = props.value;\n    // Extend parent context values and middleware.\n    var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value);\n    // Should not use the inherited provider.\n    var provider = value && value.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n    })[0];\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(function() {\n        return cacheContext ? cacheContext[2] : UNDEFINED;\n    }, []);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n_s(SWRConfig$1, \"dAKFtM8YbrTe1it5QrQ/MOR4UJ0=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\n_c = SWRConfig$1;\n/**\n * An implementation of state with dependency-tracking.\n */ var useStateWithDeps = function(state, unmountedRef) {\n    _s1();\n    var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n     * @param payload To change stateRef, pass the values explicitly to setState:\n     * @example\n     * ```js\n     * setState({\n     *   isValidating: false\n     *   data: newData // set data to newData\n     *   error: undefined // set error to undefined\n     * })\n     *\n     * setState({\n     *   isValidating: false\n     *   data: undefined // set data to undefined\n     *   error: err // set error to err\n     * })\n     * ```\n     */ var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(payload) {\n        var shouldRerender = false;\n        var currentState = stateRef.current;\n        for(var _ in payload){\n            var k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update the state reference.\n    useIsomorphicLayoutEffect(function() {\n        stateRef.current = state;\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n_s1(useStateWithDeps, \"HmFEpY5ftBP9MbHXHy6R0m/8pgc=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nvar normalize = function(args) {\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\nvar useSWRConfig = function() {\n    _s2();\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n_s2(useSWRConfig, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nvar withArgs = function(hook) {\n    var _s = $RefreshSig$();\n    return _s(function useSWRArgs() {\n        _s();\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        // Get the default and inherited configuration.\n        var fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        var _a = normalize(args), key = _a[0], fn = _a[1], _config = _a[2];\n        // Merge configurations.\n        var config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        var next = hook;\n        var use = config.use;\n        if (use) {\n            for(var i = use.length; i-- > 0;){\n                next = use[i](next);\n            }\n        }\n        return next(key, fn || config.fetcher, config);\n    }, \"jx7Wrj3OuZGSBtq4uhrHFUJGkMw=\", false, function() {\n        return [\n            useSWRConfig\n        ];\n    });\n};\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nvar subscribeCallback = function(key, callbacks, callback) {\n    var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return function() {\n        var index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\nvar WITH_DEDUPE = {\n    dedupe: true\n};\nvar useSWRHandler = function(_key, fetcher, config) {\n    _s3();\n    var cache = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], MUTATION = _a[2], FETCH = _a[3];\n    // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n    // states such as `error` and `isValidating` inside,\n    // all of them are derived from `_key`.\n    // `fnArgs` is an array of arguments parsed from the key, which will be passed\n    // to the fetcher.\n    var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];\n    // If it's the initial render of this hook.\n    var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    var getConfig = function() {\n        return configRef.current;\n    };\n    var isActive = function() {\n        return getConfig().isVisible() && getConfig().isOnline();\n    };\n    var patchFetchInfo = function(info) {\n        return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n    };\n    // Get the current state that SWR should return.\n    var cached = cache.get(key);\n    var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n    var data = isUndefined(cached) ? fallback : cached;\n    var info = cache.get(keyInfo) || {};\n    var error = info.error;\n    var isInitialMount = !initialMountedRef.current;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    var shouldRevalidate = function() {\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately on mount again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return isUndefined(data) ? false : config.revalidateIfStale;\n        // If there is no stale data, we need to revalidate on mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return isUndefined(data) || config.revalidateIfStale;\n    };\n    // Resolve the current validating state.\n    var resolveValidating = function() {\n        if (!key || !fetcher) return false;\n        if (info.isValidating) return true;\n        // If it's not mounted yet and it should revalidate on mount, revalidate.\n        return isInitialMount && shouldRevalidate();\n    };\n    var isValidating = resolveValidating();\n    var _c = useStateWithDeps({\n        data: data,\n        error: error,\n        isValidating: isValidating\n    }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(revalidateOpts) {\n        return __awaiter(void 0, void 0, void 0, function() {\n            var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n            var _a;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        currentFetcher = fetcherRef.current;\n                        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        loading = true;\n                        opts = revalidateOpts || {};\n                        shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n                        isCurrentKeyMounted = function() {\n                            return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n                        };\n                        cleanupState = function() {\n                            // Check if it's still the same request before deleting.\n                            var requestInfo = FETCH[key];\n                            if (requestInfo && requestInfo[1] === startAt) {\n                                delete FETCH[key];\n                            }\n                        };\n                        newState = {\n                            isValidating: false\n                        };\n                        finishRequestAndUpdateState = function() {\n                            patchFetchInfo({\n                                isValidating: false\n                            });\n                            // We can only set state if it's safe (still mounted with the same key).\n                            if (isCurrentKeyMounted()) {\n                                setState(newState);\n                            }\n                        };\n                        // Start fetching. Change the `isValidating` state, update the cache.\n                        patchFetchInfo({\n                            isValidating: true\n                        });\n                        setState({\n                            isValidating: true\n                        });\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        if (shouldStartNewRequest) {\n                            // Tell all other hooks to change the `isValidating` state.\n                            broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true);\n                            // If no cache being rendered currently (it shows a blank page),\n                            // we trigger the loading slow event.\n                            if (config.loadingTimeout && !cache.get(key)) {\n                                setTimeout(function() {\n                                    if (loading && isCurrentKeyMounted()) {\n                                        getConfig().onLoadingSlow(key, config);\n                                    }\n                                }, config.loadingTimeout);\n                            }\n                            // Start the request and save the timestamp.\n                            FETCH[key] = [\n                                currentFetcher.apply(void 0, fnArgs),\n                                getTimestamp()\n                            ];\n                        }\n                        _a = FETCH[key], newData = _a[0], startAt = _a[1];\n                        return [\n                            4 /*yield*/ ,\n                            newData\n                        ];\n                    case 2:\n                        newData = _b.sent();\n                        if (shouldStartNewRequest) {\n                            // If the request isn't interrupted, clean it up after the\n                            // deduplication interval.\n                            setTimeout(cleanupState, config.dedupingInterval);\n                        }\n                        // If there're other ongoing request(s), started after the current one,\n                        // we need to ignore the current one to avoid possible race conditions:\n                        //   req1------------------>res1        (current one)\n                        //        req2---------------->res2\n                        // the request that fired later will always be kept.\n                        // The timestamp maybe be `undefined` or a number\n                        if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Clear error.\n                        patchFetchInfo({\n                            error: UNDEFINED\n                        });\n                        newState.error = UNDEFINED;\n                        mutationInfo = MUTATION[key];\n                        if (!isUndefined(mutationInfo) && // case 1\n                        (startAt <= mutationInfo[0] || // case 2\n                        startAt <= mutationInfo[1] || // case 3\n                        mutationInfo[1] === 0)) {\n                            finishRequestAndUpdateState();\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Deep compare with latest state to avoid extra re-renders.\n                        // For local state, compare and assign.\n                        if (!compare(stateRef.current.data, newData)) {\n                            newState.data = newData;\n                        } else {\n                            // data and newData are deeply equal\n                            // it should be safe to broadcast the stale data\n                            newState.data = stateRef.current.data;\n                        // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n                        // which takes care of avoiding the re-render\n                        }\n                        // For global state, it's possible that the key has changed.\n                        // https://github.com/vercel/swr/pull/1058\n                        if (!compare(cache.get(key), newData)) {\n                            cache.set(key, newData);\n                        }\n                        // Trigger the successful callback if it's the original request.\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onSuccess(newData, key, config);\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 3:\n                        err_1 = _b.sent();\n                        cleanupState();\n                        // Not paused, we continue handling the error. Otherwise discard it.\n                        if (!getConfig().isPaused()) {\n                            // Get a new error, don't use deep comparison for errors.\n                            patchFetchInfo({\n                                error: err_1\n                            });\n                            newState.error = err_1;\n                            // Error event and retry logic. Only for the actual request, not\n                            // deduped ones.\n                            if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                                getConfig().onError(err_1, key, config);\n                                if (typeof config.shouldRetryOnError === \"boolean\" && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                                    // When retrying, dedupe is always enabled\n                                    if (isActive()) {\n                                        // If it's active, stop. It will auto revalidate when refocusing\n                                        // or reconnecting.\n                                        getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                                            retryCount: (opts.retryCount || 0) + 1,\n                                            dedupe: true\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 4:\n                        // Mark loading as stopped.\n                        loading = false;\n                        // Update the current hook's state.\n                        finishRequestAndUpdateState();\n                        // Here is the source of the request, need to tell all other hooks to\n                        // update their states.\n                        if (isCurrentKeyMounted() && shouldStartNewRequest) {\n                            broadcastState(cache, key, newState.data, newState.error, false);\n                        }\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                }\n            });\n        });\n    }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n    // and `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key\n    ]);\n    // Similar to the global mutate, but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// By using `bind` we don't need to modify the size of the rest arguments.\n    // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n    // cast it to any for now.\n    internalMutate.bind(UNDEFINED, cache, function() {\n        return keyRef.current;\n    }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update fetcher and config refs.\n    useIsomorphicLayoutEffect(function() {\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n    });\n    // After mounted or key changed.\n    useIsomorphicLayoutEffect(function() {\n        if (!key) return;\n        var keyChanged = key !== keyRef.current;\n        var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);\n        // Expose state updater to global event listeners. So we can update hook's\n        // internal state from the outside.\n        var onStateUpdate = function(updatedData, updatedError, updatedIsValidating) {\n            setState(mergeObjects({\n                error: updatedError,\n                isValidating: updatedIsValidating\n            }, // Since `setState` only shallowly compares states, we do a deep\n            // comparison here.\n            compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n                data: updatedData\n            }));\n        };\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        var nextFocusRevalidatedAt = 0;\n        var onRevalidate = function(type) {\n            if (type == FOCUS_EVENT) {\n                var now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == MUTATE_EVENT) {\n                return revalidate();\n            }\n            return;\n        };\n        var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n        var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // When `key` updates, reset the state to the initial value\n        // and trigger a rerender if necessary.\n        if (keyChanged) {\n            setState({\n                data: data,\n                error: error,\n                isValidating: isValidating\n            });\n        }\n        // Trigger a revalidation.\n        if (shouldRevalidate()) {\n            if (isUndefined(data) || IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                rAF(softRevalidate);\n            }\n        }\n        return function() {\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubUpdate();\n            unsubEvents();\n        };\n    }, [\n        key,\n        revalidate\n    ]);\n    // Polling\n    useIsomorphicLayoutEffect(function() {\n        var timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval;\n            // We only start next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online and not errored.\n            if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule next interval to check again.\n                next();\n            }\n        }\n        next();\n        return function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        revalidate\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && isUndefined(data) && key) {\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return data;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        }\n    };\n};\n_s3(useSWRHandler, \"sOzB05vjSiwoVJqNWH56tlkRmFk=\", false, function() {\n    return [\n        useStateWithDeps,\n        useStateWithDeps,\n        useStateWithDeps,\n        useStateWithDeps,\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n});\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, \"default\", {\n    value: defaultConfig\n});\n_c1 = SWRConfig;\nvar unstable_serialize = function(key) {\n    return serialize(key)[0];\n};\nvar useSWR = withArgs(useSWRHandler);\n// useSWR\n\nvar _c, _c1;\n$RefreshReg$(_c, \"SWRConfig$1\");\n$RefreshReg$(_c1, \"SWRConfig\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEySTtBQUUzSTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU1MsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sWUFBWWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDOUIsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTUEsQ0FBQyxDQUFDLEVB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d01UMUc7UUFLQUE7UUE4RUFBOzs7QUFpRUosSUFBSXNMLFlBQVkvTyxPQUFPZ1AsY0FBYyxDQUFDbEYsYUFBYSxXQUFXO0lBQzFEbk0sT0FBTzJLO0FBQ1g7O0FBQ0EsSUFBSTJHLHFCQUFxQixTQUFVL0ssR0FBRztJQUFJLE9BQU9ELFVBQVVDLElBQUksQ0FBQyxFQUFFO0FBQUU7QUFDcEUsSUFBSWdMLFNBQVNqRSxTQUFTYTtBQUV0QixTQUFTO0FBRXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmRleC5tanM/NjJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gcG9zc2libHkgYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiAgUHJldHRpZXIgaWdub3JlIGFuZCBleHRyYSBwYXJlbnRoZXNlcyBhcmUgbmVjZXNzYXJ5IGhlcmVcbi8vIHRvIGVuc3VyZSB0aGF0IHRzYyBkb2Vzbid0IHJlbW92ZSB0aGUgX19OT0lOTElORV9fIGNvbW1lbnQuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBVTkRFRklORUQgPSAoIC8qI19fTk9JTkxJTkVfXyovbm9vcCgpKTtcbnZhciBPQkpFQ1QgPSBPYmplY3Q7XG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gVU5ERUZJTkVEOyB9O1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBtZXJnZU9iamVjdHMgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gT0JKRUNULmFzc2lnbih7fSwgYSwgYik7IH07XG52YXIgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuLy8gTk9URTogVXNlIGZ1bmN0aW9uIHRvIGd1YXJhbnRlZSBpdCdzIHJlLWV2YWx1YXRlZCBiZXR3ZWVuIGpzZG9tIGFuZCBub2RlIHJ1bnRpbWUgZm9yIHRlc3RzLlxudmFyIGhhc1dpbmRvdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gU1RSX1VOREVGSU5FRDsgfTtcbnZhciBoYXNEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGFzV2luZG93KCkgJiYgdHlwZW9mIHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gIT0gU1RSX1VOREVGSU5FRDtcbn07XG5cbi8vIHVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBvYmplY3QtPmtleSBtYXBwaW5nXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZWFrTWFwIHVzZXMgYSBoYXNodGFibGUgdW5kZXIgdGhlIGhvb2QsIHNvIHRoZSBsb29rdXBcbi8vIGNvbXBsZXhpdHkgaXMgYWxtb3N0IE8oMSkuXG52YXIgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xuLy8gY291bnRlciBvZiB0aGUga2V5XG52YXIgY291bnRlciA9IDA7XG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XG4vLyAtIEZhc3QgYW5kIGVuc3VyZXMgdW5pcXVlIGhhc2ggcHJvcGVydGllc1xuLy8gLSBIYW5kbGVzIHVuc2VyaWFsaXphYmxlIHZhbHVlc1xuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcbi8vIC0gR2VuZXJhdGVzIHNob3J0IHJlc3VsdHNcbi8vXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4vLyBwYXJzaWJsZS5cbnZhciBzdGFibGVIYXNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcmcgJiYgYXJnLmNvbnN0cnVjdG9yO1xuICAgIHZhciBpc0RhdGUgPSBjb25zdHJ1Y3RvciA9PSBEYXRlO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGluZGV4O1xuICAgIGlmIChPQkpFQ1QoYXJnKSA9PT0gYXJnICYmICFpc0RhdGUgJiYgY29uc3RydWN0b3IgIT0gUmVnRXhwKSB7XG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGhhc2hlZCwgZGlyZWN0bHkgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgIHJlc3VsdCA9IHRhYmxlLmdldChhcmcpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggZmlyc3QgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3Rpb24gYmVmb3JlIGVudGVyaW5nIHRoZVxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxuICAgICAgICAvLyBGb3Igb3RoZXIgb2JqZWN0cyBsaWtlIHNldCBhbmQgbWFwLCB3ZSB1c2UgdGhpcyBpZCBkaXJlY3RseSBhcyB0aGUgaGFzaC5cbiAgICAgICAgcmVzdWx0ID0gKytjb3VudGVyICsgJ34nO1xuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LlxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJnLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gT0JKRUNUKSB7XG4gICAgICAgICAgICAvLyBPYmplY3QsIHNvcnQga2V5cy5cbiAgICAgICAgICAgIHJlc3VsdCA9ICcjJztcbiAgICAgICAgICAgIHZhciBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWlzVW5kZWZpbmVkKChpbmRleCA9IGtleXMucG9wKCkpKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0RhdGVcbiAgICAgICAgICAgID8gYXJnLnRvSlNPTigpXG4gICAgICAgICAgICA6IHR5cGUgPT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICA/IGFyZy50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiB0eXBlID09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnKVxuICAgICAgICAgICAgICAgICAgICA6ICcnICsgYXJnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEdWUgdG8gYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY3ODA3NSxcbiAqIGl0J3Mgbm90IHJlbGlhYmxlIHRvIGRldGVjdCBpZiB0aGUgYnJvd3NlciBpcyBjdXJyZW50bHkgb25saW5lIG9yIG9mZmxpbmVcbiAqIGJhc2VkIG9uIGBuYXZpZ2F0b3Iub25MaW5lYC5cbiAqIEFzIGEgd29yayBhcm91bmQsIHdlIGFsd2F5cyBhc3N1bWUgaXQncyBvbmxpbmUgb24gZmlyc3QgbG9hZCwgYW5kIGNoYW5nZVxuICogdGhlIHN0YXR1cyB1cG9uIGBvbmxpbmVgIG9yIGBvZmZsaW5lYCBldmVudHMuXG4gKi9cbnZhciBvbmxpbmUgPSB0cnVlO1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25saW5lOyB9O1xudmFyIGhhc1dpbiA9IGhhc1dpbmRvdygpO1xudmFyIGhhc0RvYyA9IGhhc0RvY3VtZW50KCk7XG4vLyBGb3Igbm9kZSBhbmQgUmVhY3QgTmF0aXZlLCBgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXJgIGRvZXNuJ3QgZXhpc3Qgb24gd2luZG93LlxudmFyIG9uV2luZG93RXZlbnQgPSBoYXNXaW4gJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA/IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuICAgIDogbm9vcDtcbnZhciBvbkRvY3VtZW50RXZlbnQgPSBoYXNEb2MgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpIDogbm9vcDtcbnZhciBvZmZXaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9mZkRvY3VtZW50RXZlbnQgPSBoYXNEb2NcbiAgICA/IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudClcbiAgICA6IG5vb3A7XG52YXIgaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXNpYmlsaXR5U3RhdGUgPSBoYXNEb2MgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2aXNpYmlsaXR5U3RhdGUpIHx8IHZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XG59O1xudmFyIGluaXRGb2N1cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIGZvY3VzIHJldmFsaWRhdGVcbiAgICBvbkRvY3VtZW50RXZlbnQoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgb25XaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIH07XG59O1xudmFyIGluaXRSZWNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXG4gICAgdmFyIG9uT25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgdmFyIG9uT2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgfTtcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgb25XaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29mZmxpbmUnLCBvbk9mZmxpbmUpO1xuICAgIH07XG59O1xudmFyIHByZXNldCA9IHtcbiAgICBpc09ubGluZTogaXNPbmxpbmUsXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGVcbn07XG52YXIgZGVmYXVsdENvbmZpZ09wdGlvbnMgPSB7XG4gICAgaW5pdEZvY3VzOiBpbml0Rm9jdXMsXG4gICAgaW5pdFJlY29ubmVjdDogaW5pdFJlY29ubmVjdFxufTtcblxudmFyIElTX1NFUlZFUiA9ICFoYXNXaW5kb3coKSB8fCAnRGVubycgaW4gd2luZG93O1xuLy8gUG9seWZpbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG52YXIgckFGID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgPyB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddKGYpIDogc2V0VGltZW91dChmLCAxKTtcbn07XG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gSVNfU0VSVkVSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xuLy8gVGhpcyBhc3NpZ25tZW50IGlzIHRvIGV4dGVuZCB0aGUgTmF2aWdhdG9yIHR5cGUgdG8gdXNlIGVmZmVjdGl2ZVR5cGUuXG52YXIgbmF2aWdhdG9yQ29ubmVjdGlvbiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLmNvbm5lY3Rpb247XG4vLyBBZGp1c3QgdGhlIGNvbmZpZyBiYXNlZCBvbiBzbG93IGNvbm5lY3Rpb24gc3RhdHVzICg8PSA3MEticHMpLlxudmFyIHNsb3dDb25uZWN0aW9uID0gIUlTX1NFUlZFUiAmJlxuICAgIG5hdmlnYXRvckNvbm5lY3Rpb24gJiZcbiAgICAoWydzbG93LTJnJywgJzJnJ10uaW5jbHVkZXMobmF2aWdhdG9yQ29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB8fFxuICAgICAgICBuYXZpZ2F0b3JDb25uZWN0aW9uLnNhdmVEYXRhKTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgbm90IHJlYWR5XG4gICAgICAgICAgICBrZXkgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IFtdLmNvbmNhdChrZXkpO1xuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cbiAgICBrZXkgPVxuICAgICAgICB0eXBlb2Yga2V5ID09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgOiAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5Lmxlbmd0aCA6IGtleSlcbiAgICAgICAgICAgICAgICA/IHN0YWJsZUhhc2goa2V5KVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgdmFyIGluZm9LZXkgPSBrZXkgPyAnJHN3ciQnICsga2V5IDogJyc7XG4gICAgcmV0dXJuIFtrZXksIGFyZ3MsIGluZm9LZXldO1xufTtcblxuLy8gR2xvYmFsIHN0YXRlIHVzZWQgdG8gZGVkdXBsaWNhdGUgcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVyc1xudmFyIFNXUkdsb2JhbFN0YXRlID0gbmV3IFdlYWtNYXAoKTtcblxudmFyIEZPQ1VTX0VWRU5UID0gMDtcbnZhciBSRUNPTk5FQ1RfRVZFTlQgPSAxO1xudmFyIE1VVEFURV9FVkVOVCA9IDI7XG5cbnZhciBicm9hZGNhc3RTdGF0ZSA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nLCByZXZhbGlkYXRlLCBicm9hZGNhc3QpIHtcbiAgICBpZiAoYnJvYWRjYXN0ID09PSB2b2lkIDApIHsgYnJvYWRjYXN0ID0gdHJ1ZTsgfVxuICAgIHZhciBfYSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIEVWRU5UX1JFVkFMSURBVE9SUyA9IF9hWzBdLCBTVEFURV9VUERBVEVSUyA9IF9hWzFdLCBGRVRDSCA9IF9hWzNdO1xuICAgIHZhciByZXZhbGlkYXRvcnMgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XTtcbiAgICB2YXIgdXBkYXRlcnMgPSBTVEFURV9VUERBVEVSU1trZXldO1xuICAgIC8vIENhY2hlIHdhcyBwb3B1bGF0ZWQsIHVwZGF0ZSBzdGF0ZXMgb2YgYWxsIGhvb2tzLlxuICAgIGlmIChicm9hZGNhc3QgJiYgdXBkYXRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdXBkYXRlcnNbaV0oZGF0YSwgZXJyb3IsIGlzVmFsaWRhdGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgYWxzbyBuZWVkIHRvIHJldmFsaWRhdGUsIG9ubHkgZG8gaXQgZm9yIHRoZSBmaXJzdCBob29rLlxuICAgIGlmIChyZXZhbGlkYXRlKSB7XG4gICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgIC8vIHJlcXVlc3RzIHdpbGwgbm90IGJlIGRlZHVwZWQuXG4gICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdG9yc1swXShNVVRBVEVfRVZFTlQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbn07XG5cbi8vIEdsb2JhbCB0aW1lc3RhbXAuXG52YXIgX190aW1lc3RhbXAgPSAwO1xudmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICsrX190aW1lc3RhbXA7IH07XG5cbnZhciBpbnRlcm5hbE11dGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgX2tleSwgX2RhdGEsIF9vcHRzLCBvcHRpb25zLCBwb3B1bGF0ZUNhY2hlLCByZXZhbGlkYXRlLCByb2xsYmFja09uRXJyb3IsIGN1c3RvbU9wdGltaXN0aWNEYXRhLCBfYSwga2V5LCBrZXlJbmZvLCBfYiwgTVVUQVRJT04sIGRhdGEsIGVycm9yLCBiZWZvcmVNdXRhdGlvblRzLCBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSwgcm9sbGJhY2tEYXRhLCBvcHRpbWlzdGljRGF0YSwgcmVzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IGFyZ3NbMF0sIF9rZXkgPSBhcmdzWzFdLCBfZGF0YSA9IGFyZ3NbMl0sIF9vcHRzID0gYXJnc1szXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBfb3B0cyA9PT0gJ2Jvb2xlYW4nID8geyByZXZhbGlkYXRlOiBfb3B0cyB9IDogX29wdHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSBpc1VuZGVmaW5lZChvcHRpb25zLnBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5wb3B1bGF0ZUNhY2hlO1xuICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlID0gb3B0aW9ucy5yZXZhbGlkYXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tPbkVycm9yID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3IgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21PcHRpbWlzdGljRGF0YSA9IG9wdGlvbnMub3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gc2VyaWFsaXplKF9rZXkpLCBrZXkgPSBfYVswXSwga2V5SW5mbyA9IF9hWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBNVVRBVElPTiA9IF9iWzJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuZXcgZGF0YSBwcm92aWRlZCwgcmV2YWxpZGF0ZSB0aGUga2V5IHdpdGggY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBhbmQgYnJvYWRjYXN0IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIGNhY2hlLmdldChrZXkpLCBVTkRFRklORUQsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgdHJ1ZSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTltrZXldID0gW2JlZm9yZU11dGF0aW9uVHMsIDBdO1xuICAgICAgICAgICAgICAgICAgICBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSA9ICFpc1VuZGVmaW5lZChjdXN0b21PcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJvbGxiYWNrRGF0YSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBvcHRpbWlzdGljIGRhdGEgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNEYXRhID0gaXNGdW5jdGlvbihjdXN0b21PcHRpbWlzdGljRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1c3RvbU9wdGltaXN0aWNEYXRhKHJvbGxiYWNrRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1c3RvbU9wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgb3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgb3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNhY2hlLmdldChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgd2Ugc2hvdWxkbid0IHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSAmJiBpc0Z1bmN0aW9uKGRhdGEudGhlbikpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGF0YS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIG11dGF0aW9uIGlzIGFzeW5jLCB3ZSBuZWVkIHRvIGNoZWNrIHRpbWVzdGFtcHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSByYWNlIHdlIGRvbid0IHVwZGF0ZSBjYWNoZSBvciBicm9hZGNhc3QgdGhlIGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVNdXRhdGlvblRzICE9PSBNVVRBVElPTltrZXldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgJiYgcm9sbGJhY2tPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWluZyB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJvbGxiYWNrRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIHJvbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2hvdWxkIHdyaXRlIGJhY2sgdGhlIGNhY2hlIGFmdGVyIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3B1bGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXN1bHQgaW50byBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBvcHVsYXRlQ2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwb3B1bGF0ZUNhY2hlKGRhdGEsIHJvbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGNhY2hlZCBkYXRhIGlmIHRoZXJlJ3Mgbm8gZXJyb3IuIERhdGEgY2FuIGJlIGB1bmRlZmluZWRgIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlIG9yIHJlc2V0IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXlJbmZvLCBtZXJnZU9iamVjdHMoY2FjaGUuZ2V0KGtleUluZm8pLCB7IGVycm9yOiBlcnJvciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVzdGFtcCB0byBtYXJrIHRoZSBtdXRhdGlvbiBoYXMgZW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV1bMV0gPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgZGF0YSwgZXJyb3IsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgISFwb3B1bGF0ZUNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwb3B1bGF0ZUNhY2hlID8gcmVzIDogZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxudmFyIHJldmFsaWRhdGVBbGxLZXlzID0gZnVuY3Rpb24gKHJldmFsaWRhdG9ycywgdHlwZSkge1xuICAgIGZvciAodmFyIGtleSBpbiByZXZhbGlkYXRvcnMpIHtcbiAgICAgICAgaWYgKHJldmFsaWRhdG9yc1trZXldWzBdKVxuICAgICAgICAgICAgcmV2YWxpZGF0b3JzW2tleV1bMF0odHlwZSk7XG4gICAgfVxufTtcbnZhciBpbml0Q2FjaGUgPSBmdW5jdGlvbiAocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxuICAgIC8vIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnMuIEFzIHdlbGwgYXMgYSBtdXRhdGUgZnVuY3Rpb24gdGhhdCBib3VuZCB0b1xuICAgIC8vIHRoZSBjYWNoZS5cbiAgICAvLyBQcm92aWRlcidzIGdsb2JhbCBzdGF0ZSBtaWdodCBiZSBhbHJlYWR5IGluaXRpYWxpemVkLiBMZXQncyB0cnkgdG8gZ2V0IHRoZVxuICAgIC8vIGdsb2JhbCBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVyIGZpcnN0LlxuICAgIGlmICghU1dSR2xvYmFsU3RhdGUuaGFzKHByb3ZpZGVyKSkge1xuICAgICAgICB2YXIgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZ2xvYmFsIHN0YXRlIGJvdW5kIHRvIHRoZSBwcm92aWRlciwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIHRoZVxuICAgICAgICAvLyBuZXcgbXV0YXRlIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgRVZFTlRfUkVWQUxJREFUT1JTID0ge307XG4gICAgICAgIHZhciBtdXRhdGUgPSBpbnRlcm5hbE11dGF0ZS5iaW5kKFVOREVGSU5FRCwgcHJvdmlkZXIpO1xuICAgICAgICB2YXIgdW5tb3VudCA9IG5vb3A7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQncyBuZXcsIG9yIHRoZSBwcm92aWRlciBoYXMgYmVlbiBleHRlbmRlZC5cbiAgICAgICAgU1dSR2xvYmFsU3RhdGUuc2V0KHByb3ZpZGVyLCBbRVZFTlRfUkVWQUxJREFUT1JTLCB7fSwge30sIHt9LCBtdXRhdGVdKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBwcm92aWRlciwgd2UgbmVlZCB0byBpbml0aWFsaXplIGl0IGFuZCBzZXR1cCBET00gZXZlbnRzXG4gICAgICAgIC8vIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9ucy5cbiAgICAgICAgaWYgKCFJU19TRVJWRVIpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbGlzdGVuaW5nIHRvIHRoZSBuYXRpdmUgZXZlbnRzIGZvciBhdXRvIHJldmFsaWRhdGlvbnMsXG4gICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gZmlyZWQgYWZ0ZXIgaW1tZWRpYXRlIEphdmFTY3JpcHQgZXhlY3V0aW9ucywgd2hpY2ggY2FuIHBvc3NpYmx5IGJlXG4gICAgICAgICAgICAvLyBSZWFjdCdzIHN0YXRlIHVwZGF0ZXMuXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE2ODAuXG4gICAgICAgICAgICB2YXIgcmVsZWFzZUZvY3VzXzEgPSBvcHRzLmluaXRGb2N1cyhzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBGT0NVU19FVkVOVCkpKTtcbiAgICAgICAgICAgIHZhciByZWxlYXNlUmVjb25uZWN0XzEgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xuICAgICAgICAgICAgdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWxlYXNlRm9jdXNfMSAmJiByZWxlYXNlRm9jdXNfMSgpO1xuICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3RfMSAmJiByZWxlYXNlUmVjb25uZWN0XzEoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVuLW1vdW50aW5nLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgY2FjaGUgcHJvdmlkZXIgZnJvbSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHRvbyBiZWNhdXNlIGl0J3MgYSBzaWRlLWVmZmVjdC4gT3RoZXJ3aXNlIHdoZW4gcmUtbW91bnRpbmcgd2VcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgU1dSR2xvYmFsU3RhdGUuZGVsZXRlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbWlnaHQgd2FudCB0byBpbmplY3QgYW4gZXh0cmEgbGF5ZXIgb24gdG9wIG9mIGBwcm92aWRlcmAgaW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgLy8gc3VjaCBhcyBrZXkgc2VyaWFsaXphdGlvbiwgYXV0byBHQywgZXRjLlxuICAgICAgICAvLyBGb3Igbm93LCBpdCdzIGp1c3QgYSBgTWFwYCBpbnRlcmZhY2Ugd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cbiAgICAgICAgcmV0dXJuIFtwcm92aWRlciwgbXV0YXRlLCB1bm1vdW50XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm92aWRlciwgU1dSR2xvYmFsU3RhdGUuZ2V0KHByb3ZpZGVyKVs0XV07XG59O1xuXG4vLyBlcnJvciByZXRyeVxudmFyIG9uRXJyb3JSZXRyeSA9IGZ1bmN0aW9uIChfLCBfXywgY29uZmlnLCByZXZhbGlkYXRlLCBvcHRzKSB7XG4gICAgdmFyIG1heFJldHJ5Q291bnQgPSBjb25maWcuZXJyb3JSZXRyeUNvdW50O1xuICAgIHZhciBjdXJyZW50UmV0cnlDb3VudCA9IG9wdHMucmV0cnlDb3VudDtcbiAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgdmFyIHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNSkgKlxuICAgICAgICAoMSA8PCAoY3VycmVudFJldHJ5Q291bnQgPCA4ID8gY3VycmVudFJldHJ5Q291bnQgOiA4KSkpICogY29uZmlnLmVycm9yUmV0cnlJbnRlcnZhbDtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG1heFJldHJ5Q291bnQpICYmIGN1cnJlbnRSZXRyeUNvdW50ID4gbWF4UmV0cnlDb3VudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQocmV2YWxpZGF0ZSwgdGltZW91dCwgb3B0cyk7XG59O1xuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxudmFyIF9hID0gaW5pdENhY2hlKG5ldyBNYXAoKSksIGNhY2hlID0gX2FbMF0sIG11dGF0ZSA9IF9hWzFdO1xuLy8gRGVmYXVsdCBjb25maWdcbnZhciBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBub29wLFxuICAgIG9uU3VjY2Vzczogbm9vcCxcbiAgICBvbkVycm9yOiBub29wLFxuICAgIG9uRXJyb3JSZXRyeTogb25FcnJvclJldHJ5LFxuICAgIG9uRGlzY2FyZGVkOiBub29wLFxuICAgIC8vIHN3aXRjaGVzXG4gICAgcmV2YWxpZGF0ZU9uRm9jdXM6IHRydWUsXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiB0cnVlLFxuICAgIHJldmFsaWRhdGVJZlN0YWxlOiB0cnVlLFxuICAgIHNob3VsZFJldHJ5T25FcnJvcjogdHJ1ZSxcbiAgICAvLyB0aW1lb3V0c1xuICAgIGVycm9yUmV0cnlJbnRlcnZhbDogc2xvd0Nvbm5lY3Rpb24gPyAxMDAwMCA6IDUwMDAsXG4gICAgZm9jdXNUaHJvdHRsZUludGVydmFsOiA1ICogMTAwMCxcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCxcbiAgICBsb2FkaW5nVGltZW91dDogc2xvd0Nvbm5lY3Rpb24gPyA1MDAwIDogMzAwMCxcbiAgICAvLyBwcm92aWRlcnNcbiAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHN0YWJsZUhhc2goY3VycmVudERhdGEpID09IHN0YWJsZUhhc2gobmV3RGF0YSk7XG4gICAgfSxcbiAgICBpc1BhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgY2FjaGU6IGNhY2hlLFxuICAgIG11dGF0ZTogbXV0YXRlLFxuICAgIGZhbGxiYWNrOiB7fVxufSwgXG4vLyB1c2Ugd2ViIHByZXNldCBieSBkZWZhdWx0XG5wcmVzZXQpO1xuXG52YXIgbWVyZ2VDb25maWdzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXG4gICAgdmFyIHYgPSBtZXJnZU9iamVjdHMoYSwgYik7XG4gICAgLy8gSWYgdHdvIGNvbmZpZ3MgYXJlIHByb3ZpZGVkLCBtZXJnZSB0aGVpciBgdXNlYCBhbmQgYGZhbGxiYWNrYCBvcHRpb25zLlxuICAgIGlmIChiKSB7XG4gICAgICAgIHZhciB1MSA9IGEudXNlLCBmMSA9IGEuZmFsbGJhY2s7XG4gICAgICAgIHZhciB1MiA9IGIudXNlLCBmMiA9IGIuZmFsbGJhY2s7XG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xuICAgICAgICAgICAgdi51c2UgPSB1MS5jb25jYXQodTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmMSAmJiBmMikge1xuICAgICAgICAgICAgdi5mYWxsYmFjayA9IG1lcmdlT2JqZWN0cyhmMSwgZjIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxudmFyIFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbnZhciBTV1JDb25maWckMSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIC8vIEV4dGVuZCBwYXJlbnQgY29udGV4dCB2YWx1ZXMgYW5kIG1pZGRsZXdhcmUuXG4gICAgdmFyIGV4dGVuZGVkQ29uZmlnID0gbWVyZ2VDb25maWdzKHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCksIHZhbHVlKTtcbiAgICAvLyBTaG91bGQgbm90IHVzZSB0aGUgaW5oZXJpdGVkIHByb3ZpZGVyLlxuICAgIHZhciBwcm92aWRlciA9IHZhbHVlICYmIHZhbHVlLnByb3ZpZGVyO1xuICAgIC8vIFVzZSBhIGxhenkgaW5pdGlhbGl6ZWQgc3RhdGUgdG8gY3JlYXRlIHRoZSBjYWNoZSBvbiBmaXJzdCBhY2Nlc3MuXG4gICAgdmFyIGNhY2hlQ29udGV4dCA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgICAgICAgICA/IGluaXRDYWNoZShwcm92aWRlcihleHRlbmRlZENvbmZpZy5jYWNoZSB8fCBjYWNoZSksIHZhbHVlKVxuICAgICAgICAgICAgOiBVTkRFRklORUQ7XG4gICAgfSlbMF07XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGNhY2hlIGlmIGEgbmV3IHByb3ZpZGVyIGlzIGdpdmVuLlxuICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcuY2FjaGUgPSBjYWNoZUNvbnRleHRbMF07XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLm11dGF0ZSA9IGNhY2hlQ29udGV4dFsxXTtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgZXZlbnRzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNhY2hlQ29udGV4dCA/IGNhY2hlQ29udGV4dFsyXSA6IFVOREVGSU5FRCk7IH0sIFtdKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyLCBtZXJnZU9iamVjdHMocHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IGV4dGVuZGVkQ29uZmlnXG4gICAgfSkpO1xufTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gKi9cbnZhciB1c2VTdGF0ZVdpdGhEZXBzID0gZnVuY3Rpb24gKHN0YXRlLCB1bm1vdW50ZWRSZWYpIHtcbiAgICB2YXIgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV07XG4gICAgdmFyIHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICAvLyBJZiBhIHN0YXRlIHByb3BlcnR5IChkYXRhLCBlcnJvciBvciBpc1ZhbGlkYXRpbmcpIGlzIGFjY2Vzc2VkIGJ5IHRoZSByZW5kZXJcbiAgICAvLyBmdW5jdGlvbiwgd2UgbWFyayB0aGUgcHJvcGVydHkgYXMgYSBkZXBlbmRlbmN5IHNvIGlmIGl0IGlzIHVwZGF0ZWQgYWdhaW5cbiAgICAvLyBpbiB0aGUgZnV0dXJlLCB3ZSB0cmlnZ2VyIGEgcmVyZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBhbHNvIGtub3duIGFzIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gICAgdmFyIHN0YXRlRGVwZW5kZW5jaWVzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgZGF0YTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRvIGNoYW5nZSBzdGF0ZVJlZiwgcGFzcyB0aGUgdmFsdWVzIGV4cGxpY2l0bHkgdG8gc2V0U3RhdGU6XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHNldFN0YXRlKHtcbiAgICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgKiAgIGRhdGE6IG5ld0RhdGEgLy8gc2V0IGRhdGEgdG8gbmV3RGF0YVxuICAgICAqICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBzZXQgZXJyb3IgdG8gdW5kZWZpbmVkXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIHNldFN0YXRlKHtcbiAgICAgKiAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgKiAgIGRhdGE6IHVuZGVmaW5lZCAvLyBzZXQgZGF0YSB0byB1bmRlZmluZWRcbiAgICAgKiAgIGVycm9yOiBlcnIgLy8gc2V0IGVycm9yIHRvIGVyclxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFyIHNldFN0YXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHNob3VsZFJlcmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBmb3IgKHZhciBfIGluIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBrID0gXztcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xuICAgICAgICAgICAgLy8gbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZVtrXSAhPT0gcGF5bG9hZFtrXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkIGJ5IHRoZSBjb21wb25lbnQsIGEgcmVyZW5kZXIgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlcmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlcmVuZGVyICYmICF1bm1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xuICAgICAgICB9XG4gICAgfSwgXG4gICAgLy8gY29uZmlnLnN1c3BlbnNlIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBzdGF0ZSByZWZlcmVuY2UuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3N0YXRlUmVmLCBzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50LCBzZXRTdGF0ZV07XG59O1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmdzWzFdKVxuICAgICAgICA/IFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdIHx8IHt9XVxuICAgICAgICA6IFthcmdzWzBdLCBudWxsLCAoYXJnc1sxXSA9PT0gbnVsbCA/IGFyZ3NbMl0gOiBhcmdzWzFdKSB8fCB7fV07XG59O1xuXG52YXIgdXNlU1dSQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtZXJnZU9iamVjdHMoZGVmYXVsdENvbmZpZywgdXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSk7XG59O1xuXG4vLyBJdCdzIHRyaWNreSB0byBwYXNzIGdlbmVyaWMgdHlwZXMgYXMgcGFyYW1ldGVycywgc28gd2UganVzdCBkaXJlY3RseSBvdmVycmlkZVxuLy8gdGhlIHR5cGVzIGhlcmUuXG52YXIgd2l0aEFyZ3MgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VTV1JBcmdzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgZGVmYXVsdCBhbmQgaW5oZXJpdGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIHZhciBmYWxsYmFja0NvbmZpZyA9IHVzZVNXUkNvbmZpZygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemUoYXJncyksIGtleSA9IF9hWzBdLCBmbiA9IF9hWzFdLCBfY29uZmlnID0gX2FbMl07XG4gICAgICAgIC8vIE1lcmdlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICB2YXIgY29uZmlnID0gbWVyZ2VDb25maWdzKGZhbGxiYWNrQ29uZmlnLCBfY29uZmlnKTtcbiAgICAgICAgLy8gQXBwbHkgbWlkZGxld2FyZVxuICAgICAgICB2YXIgbmV4dCA9IGhvb2s7XG4gICAgICAgIHZhciB1c2UgPSBjb25maWcudXNlO1xuICAgICAgICBpZiAodXNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdXNlLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdXNlW2ldKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIsIGNvbmZpZyk7XG4gICAgfTtcbn07XG5cbi8vIEFkZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBrZXllZCBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHJldHVyblxuLy8gdGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxudmFyIHN1YnNjcmliZUNhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXllZFJldmFsaWRhdG9ycyA9IGNhbGxiYWNrc1trZXldIHx8IChjYWxsYmFja3Nba2V5XSA9IFtdKTtcbiAgICBrZXllZFJldmFsaWRhdG9ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBrZXllZFJldmFsaWRhdG9ycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNbaW5kZXhdID0ga2V5ZWRSZXZhbGlkYXRvcnNba2V5ZWRSZXZhbGlkYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9ycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgV0lUSF9ERURVUEUgPSB7IGRlZHVwZTogdHJ1ZSB9O1xudmFyIHVzZVNXUkhhbmRsZXIgPSBmdW5jdGlvbiAoX2tleSwgZmV0Y2hlciwgY29uZmlnKSB7XG4gICAgdmFyIGNhY2hlID0gY29uZmlnLmNhY2hlLCBjb21wYXJlID0gY29uZmlnLmNvbXBhcmUsIGZhbGxiYWNrRGF0YSA9IGNvbmZpZy5mYWxsYmFja0RhdGEsIHN1c3BlbnNlID0gY29uZmlnLnN1c3BlbnNlLCByZXZhbGlkYXRlT25Nb3VudCA9IGNvbmZpZy5yZXZhbGlkYXRlT25Nb3VudCwgcmVmcmVzaEludGVydmFsID0gY29uZmlnLnJlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4gPSBjb25maWcucmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSA9IGNvbmZpZy5yZWZyZXNoV2hlbk9mZmxpbmU7XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIE1VVEFUSU9OID0gX2FbMl0sIEZFVENIID0gX2FbM107XG4gICAgLy8gYGtleWAgaXMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIFNXUiBgZGF0YWAgc3RhdGUsIGBrZXlJbmZvYCBob2xkcyBleHRyYVxuICAgIC8vIHN0YXRlcyBzdWNoIGFzIGBlcnJvcmAgYW5kIGBpc1ZhbGlkYXRpbmdgIGluc2lkZSxcbiAgICAvLyBhbGwgb2YgdGhlbSBhcmUgZGVyaXZlZCBmcm9tIGBfa2V5YC5cbiAgICAvLyBgZm5BcmdzYCBpcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGtleSwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAgICAvLyB0byB0aGUgZmV0Y2hlci5cbiAgICB2YXIgX2IgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9iWzBdLCBmbkFyZ3MgPSBfYlsxXSwga2V5SW5mbyA9IF9iWzJdO1xuICAgIC8vIElmIGl0J3MgdGhlIGluaXRpYWwgcmVuZGVyIG9mIHRoaXMgaG9vay5cbiAgICB2YXIgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIElmIHRoZSBob29rIGlzIHVubW91bnRlZCBhbHJlYWR5LiBUaGlzIHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IHNvbWUgZWZmZWN0c1xuICAgIC8vIHRvIGJlIGNhbGxlZCBhZnRlciB1bm1vdW50aW5nLlxuICAgIHZhciB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIFJlZnMgdG8ga2VlcCB0aGUga2V5IGFuZCBjb25maWcuXG4gICAgdmFyIGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgIHZhciBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgIHZhciBjb25maWdSZWYgPSB1c2VSZWYoY29uZmlnKTtcbiAgICB2YXIgZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnUmVmLmN1cnJlbnQ7IH07XG4gICAgdmFyIGlzQWN0aXZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkgJiYgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKTsgfTtcbiAgICB2YXIgcGF0Y2hGZXRjaEluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICByZXR1cm4gY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIGluZm8pKTtcbiAgICB9O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZSB0aGF0IFNXUiBzaG91bGQgcmV0dXJuLlxuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICB2YXIgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpXG4gICAgICAgID8gY29uZmlnLmZhbGxiYWNrW2tleV1cbiAgICAgICAgOiBmYWxsYmFja0RhdGE7XG4gICAgdmFyIGRhdGEgPSBpc1VuZGVmaW5lZChjYWNoZWQpID8gZmFsbGJhY2sgOiBjYWNoZWQ7XG4gICAgdmFyIGluZm8gPSBjYWNoZS5nZXQoa2V5SW5mbykgfHwge307XG4gICAgdmFyIGVycm9yID0gaW5mby5lcnJvcjtcbiAgICB2YXIgaXNJbml0aWFsTW91bnQgPSAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAvLyAtIFN1c3BlbnNlIG1vZGUgYW5kIHRoZXJlJ3Mgc3RhbGUgZGF0YSBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgIC8vIC0gTm90IHN1c3BlbnNlIG1vZGUgYW5kIHRoZXJlIGlzIG5vIGZhbGxiYWNrIGRhdGEgYW5kIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZC5cbiAgICAvLyAtIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZCBidXQgYGRhdGFgIGlzIG5vdCBkZWZpbmVkLlxuICAgIHZhciBzaG91bGRSZXZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKVxuICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBVbmRlciBzdXNwZW5zZSBtb2RlLCBpdCB3aWxsIGFsd2F5cyBmZXRjaCBvbiByZW5kZXIgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RhbGUgZGF0YSBzbyBubyBuZWVkIHRvIHJldmFsaWRhdGUgaW1tZWRpYXRlbHkgb24gbW91bnQgYWdhaW4uXG4gICAgICAgIC8vIElmIGRhdGEgZXhpc3RzLCBvbmx5IHJldmFsaWRhdGUgaWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyB0cnVlLlxuICAgICAgICBpZiAoc3VzcGVuc2UpXG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IGNvbmZpZy5yZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3RhbGUgZGF0YSwgd2UgbmVlZCB0byByZXZhbGlkYXRlIG9uIG1vdW50O1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHNldCB0byB0cnVlLCB3ZSB3aWxsIGFsd2F5cyByZXZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgfHwgY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgIH07XG4gICAgLy8gUmVzb2x2ZSB0aGUgY3VycmVudCB2YWxpZGF0aW5nIHN0YXRlLlxuICAgIHZhciByZXNvbHZlVmFsaWRhdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWZldGNoZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmlzVmFsaWRhdGluZylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBtb3VudGVkIHlldCBhbmQgaXQgc2hvdWxkIHJldmFsaWRhdGUgb24gbW91bnQsIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGRSZXZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICB2YXIgaXNWYWxpZGF0aW5nID0gcmVzb2x2ZVZhbGlkYXRpbmcoKTtcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZVdpdGhEZXBzKHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgIH0sIHVubW91bnRlZFJlZiksIHN0YXRlUmVmID0gX2NbMF0sIHN0YXRlRGVwZW5kZW5jaWVzID0gX2NbMV0sIHNldFN0YXRlID0gX2NbMl07XG4gICAgLy8gVGhlIHJldmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBhIGNhcmVmdWxseSBjcmFmdGVkIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXG4gICAgdmFyIHJldmFsaWRhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocmV2YWxpZGF0ZU9wdHMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50RmV0Y2hlciwgbmV3RGF0YSwgc3RhcnRBdCwgbG9hZGluZywgb3B0cywgc2hvdWxkU3RhcnROZXdSZXF1ZXN0LCBpc0N1cnJlbnRLZXlNb3VudGVkLCBjbGVhbnVwU3RhdGUsIG5ld1N0YXRlLCBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUsIG11dGF0aW9uSW5mbywgZXJyXzE7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIgPSBmZXRjaGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEZldGNoZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcmV2YWxpZGF0ZU9wdHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCA9ICFGRVRDSFtrZXldIHx8ICFvcHRzLmRlZHVwZTtcbiAgICAgICAgICAgICAgICAgICAgaXNDdXJyZW50S2V5TW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdW5tb3VudGVkUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IGtleVJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzdGlsbCB0aGUgc2FtZSByZXF1ZXN0IGJlZm9yZSBkZWxldGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IEZFVENIW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEluZm8gJiYgcmVxdWVzdEluZm9bMV0gPT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7IGlzVmFsaWRhdGluZzogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oeyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIG9ubHkgc2V0IHN0YXRlIGlmIGl0J3Mgc2FmZSAoc3RpbGwgbW91bnRlZCB3aXRoIHRoZSBzYW1lIGtleSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBmZXRjaGluZy4gQ2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZSwgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZSh7IGlzVmFsaWRhdGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCBhbGwgb3RoZXIgaG9va3MgdG8gY2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgc3RhdGVSZWYuY3VycmVudC5lcnJvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBsb2FkaW5nIHNsb3cgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvYWRpbmdUaW1lb3V0ICYmICFjYWNoZS5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uTG9hZGluZ1Nsb3coa2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29uZmlnLmxvYWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBGRVRDSFtrZXldID0gW2N1cnJlbnRGZXRjaGVyLmFwcGx5KHZvaWQgMCwgZm5BcmdzKSwgZ2V0VGltZXN0YW1wKCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9hID0gRkVUQ0hba2V5XSwgbmV3RGF0YSA9IF9hWzBdLCBzdGFydEF0ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ld0RhdGFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2xlYW51cFN0YXRlLCBjb25maWcuZGVkdXBpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpZ25vcmUgdGhlIGN1cnJlbnQgb25lIHRvIGF2b2lkIHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgdGhhdCBmaXJlZCBsYXRlciB3aWxsIGFsd2F5cyBiZSBrZXB0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkluZm8gPSBNVVRBVElPTltrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG11dGF0aW9uSW5mbykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkluZm9bMV0gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgd2l0aCBsYXRlc3Qgc3RhdGUgdG8gYXZvaWQgZXh0cmEgcmUtcmVuZGVycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIG5ld0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgYW5kIG5ld0RhdGEgYXJlIGRlZXBseSBlcXVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIHNhZmUgdG8gYnJvYWRjYXN0IHRoZSBzdGFsZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5kYXRhID0gc3RhdGVSZWYuY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uLCBgYnJvY2FzdFN0YXRlYCBpbnZva2VzIHRoZSBgb25TdGF0ZVVwZGF0ZWAgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB0YWtlcyBjYXJlIG9mIGF2b2lkaW5nIHRoZSByZS1yZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZ2xvYmFsIHN0YXRlLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGtleSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8xMDU4XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShjYWNoZS5nZXQoa2V5KSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHN1Y2Nlc3NmdWwgY2FsbGJhY2sgaWYgaXQncyB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uU3VjY2VzcyhuZXdEYXRhLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBwYXVzZWQsIHdlIGNvbnRpbnVlIGhhbmRsaW5nIHRoZSBlcnJvci4gT3RoZXJ3aXNlIGRpc2NhcmQgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IGVycm9yLCBkb24ndCB1c2UgZGVlcCBjb21wYXJpc29uIGZvciBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGVycm9yOiBlcnJfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gZXJyXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBldmVudCBhbmQgcmV0cnkgbG9naWMuIE9ubHkgZm9yIHRoZSBhY3R1YWwgcmVxdWVzdCwgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGVkIG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0ICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRXJyb3IoZXJyXzEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yID09PSAnYm9vbGVhbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IoZXJyXzEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGUgaXMgYWx3YXlzIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYWN0aXZlLCBzdG9wLiBJdCB3aWxsIGF1dG8gcmV2YWxpZGF0ZSB3aGVuIHJlZm9jdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRXJyb3JSZXRyeShlcnJfMSwga2V5LCBjb25maWcsIHJldmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgaXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVxdWVzdCwgbmVlZCB0byB0ZWxsIGFsbCBvdGhlciBob29rcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlaXIgc3RhdGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpICYmIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgbmV3U3RhdGUuZGF0YSwgbmV3U3RhdGUuZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pOyB9LCBcbiAgICAvLyBgc2V0U3RhdGVgIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ3NgLCBga2V5SW5mb2AsXG4gICAgLy8gYW5kIGBrZXlWYWxpZGF0aW5nYCBhcmUgZGVwZW5kaW5nIG9uIGBrZXlgLCBzbyB3ZSBjYW4gZXhjbHVkZSB0aGVtIGZyb21cbiAgICAvLyB0aGUgZGVwcyBhcnJheS5cbiAgICAvL1xuICAgIC8vIEZJWE1FOlxuICAgIC8vIGBmbmAgYW5kIGBjb25maWdgIG1pZ2h0IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBsaWZlY3ljbGUsXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxuICAgIC8vIGB1c2VTV1IoJ2tleScsICgpID0+IGZldGNoKCcvYXBpLycpLCB7IHN1c3BlbnNlOiB0cnVlIH0pYFxuICAgIC8vIFNvIHdlIG9taXQgdGhlIHZhbHVlcyBmcm9tIHRoZSBkZXBzIGFycmF5XG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgbWlnaHQgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtrZXldKTtcbiAgICAvLyBTaW1pbGFyIHRvIHRoZSBnbG9iYWwgbXV0YXRlLCBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB2YXIgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAvLyBCeSB1c2luZyBgYmluZGAgd2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgdGhlIHNpemUgb2YgdGhlIHJlc3QgYXJndW1lbnRzLlxuICAgIC8vIER1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3MTgxLCB3ZSBoYXZlIHRvXG4gICAgLy8gY2FzdCBpdCB0byBhbnkgZm9yIG5vdy5cbiAgICBpbnRlcm5hbE11dGF0ZS5iaW5kKFVOREVGSU5FRCwgY2FjaGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleVJlZi5jdXJyZW50OyB9KSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICB9KTtcbiAgICAvLyBBZnRlciBtb3VudGVkIG9yIGtleSBjaGFuZ2VkLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGtleUNoYW5nZWQgPSBrZXkgIT09IGtleVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgc29mdFJldmFsaWRhdGUgPSByZXZhbGlkYXRlLmJpbmQoVU5ERUZJTkVELCBXSVRIX0RFRFVQRSk7XG4gICAgICAgIC8vIEV4cG9zZSBzdGF0ZSB1cGRhdGVyIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB1cGRhdGUgaG9vaydzXG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHVwZGF0ZWREYXRhLCB1cGRhdGVkRXJyb3IsIHVwZGF0ZWRJc1ZhbGlkYXRpbmcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKG1lcmdlT2JqZWN0cyh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHVwZGF0ZWRFcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHVwZGF0ZWRJc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gU2luY2UgYHNldFN0YXRlYCBvbmx5IHNoYWxsb3dseSBjb21wYXJlcyBzdGF0ZXMsIHdlIGRvIGEgZGVlcFxuICAgICAgICAgICAgLy8gY29tcGFyaXNvbiBoZXJlLlxuICAgICAgICAgICAgY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHVwZGF0ZWREYXRhKVxuICAgICAgICAgICAgICAgID8gVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXG4gICAgICAgIC8vIHJldmFsaWRhdGlvbiBmcm9tIHRoZSBvdXRzaWRlLlxuICAgICAgICB2YXIgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IDA7XG4gICAgICAgIHZhciBvblJldmFsaWRhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gRk9DVVNfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAgbm93ID4gbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCAmJlxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBSRUNPTk5FQ1RfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uUmVjb25uZWN0ICYmIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IE1VVEFURV9FVkVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bnN1YlVwZGF0ZSA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgU1RBVEVfVVBEQVRFUlMsIG9uU3RhdGVVcGRhdGUpO1xuICAgICAgICB2YXIgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGFzIG1vdW50ZWQgYW5kIHVwZGF0ZSBjb3JyZXNwb25kaW5nIHJlZnMuXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xuICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gV2hlbiBga2V5YCB1cGRhdGVzLCByZXNldCB0aGUgc3RhdGUgdG8gdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgLy8gYW5kIHRyaWdnZXIgYSByZXJlbmRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChrZXlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiBpc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyaWdnZXIgYSByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhKSB8fCBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgIHJBRihzb2Z0UmV2YWxpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxuICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdW5zdWJVcGRhdGUoKTtcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2tleSwgcmV2YWxpZGF0ZV0pO1xuICAgIC8vIFBvbGxpbmdcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVyO1xuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBwYXNzZWQgaW50ZXJ2YWxcbiAgICAgICAgICAgIC8vIC4uLm9yIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgdXBkYXRlZCBkYXRhIHRvIGdldCB0aGUgaW50ZXJ2YWxcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKVxuICAgICAgICAgICAgICAgID8gcmVmcmVzaEludGVydmFsKGRhdGEpXG4gICAgICAgICAgICAgICAgOiByZWZyZXNoSW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHN0YXJ0IG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcbiAgICAgICAgICAgIC8vIC0gYGZvcmNlYCBpcyB0cnVlLCB3aGljaCBpcyB0aGUgc3RhcnQgb2YgcG9sbGluZ1xuICAgICAgICAgICAgLy8gLSBvciBgdGltZXJgIGlzIG5vdCAwLCB3aGljaCBtZWFucyB0aGUgZWZmZWN0IHdhc24ndCBjYW5jZWxlZFxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjdXRlLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgT0sgdG8gZXhlY3V0ZTpcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSBhbmQgbm90IGVycm9yZWQuXG4gICAgICAgICAgICBpZiAoIXN0YXRlUmVmLmN1cnJlbnQuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5IaWRkZW4gfHwgZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkpICYmXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUoV0lUSF9ERURVUEUpLnRoZW4obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXh0IGludGVydmFsIHRvIGNoZWNrIGFnYWluLlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW3JlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSwgcmV2YWxpZGF0ZV0pO1xuICAgIC8vIERpc3BsYXkgZGVidWcgaW5mbyBpbiBSZWFjdCBEZXZUb29scy5cbiAgICB1c2VEZWJ1Z1ZhbHVlKGRhdGEpO1xuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxuICAgIC8vIElmIHRoZXJlIGlzIGBlcnJvcmAsIHRoZSBgZXJyb3JgIG5lZWRzIHRvIGJlIHRocm93biB0byB0aGUgZXJyb3IgYm91bmRhcnkuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYGVycm9yYCwgdGhlIGByZXZhbGlkYXRpb25gIHByb21pc2UgbmVlZHMgdG8gYmUgdGhyb3duIHRvXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIGlmIChzdXNwZW5zZSAmJiBpc1VuZGVmaW5lZChkYXRhKSAmJiBrZXkpIHtcbiAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcyBldmVuIHdpdGggdGhlIFN1c3BlbnNlIG1vZGUuXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBpc1VuZGVmaW5lZChlcnJvcikgPyByZXZhbGlkYXRlKFdJVEhfREVEVVBFKSA6IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxuICAgICAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmlzVmFsaWRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZGF0aW5nO1xuICAgICAgICB9XG4gICAgfTtcbn07XG52YXIgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdCcsIHtcbiAgICB2YWx1ZTogZGVmYXVsdENvbmZpZ1xufSk7XG52YXIgdW5zdGFibGVfc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VyaWFsaXplKGtleSlbMF07IH07XG52YXIgdXNlU1dSID0gd2l0aEFyZ3ModXNlU1dSSGFuZGxlcik7XG5cbi8vIHVzZVNXUlxuXG5leHBvcnQgeyBTV1JDb25maWcsIHVzZVNXUiBhcyBkZWZhdWx0LCBtdXRhdGUsIHVuc3RhYmxlX3NlcmlhbGl6ZSwgdXNlU1dSQ29uZmlnIH07XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJub29wIiwiVU5ERUZJTkVEIiwiT0JKRUNUIiwiT2JqZWN0IiwiaXNVbmRlZmluZWQiLCJpc0Z1bmN0aW9uIiwibWVyZ2VPYmplY3RzIiwiYSIsImIiLCJhc3NpZ24iLCJTVFJfVU5ERUZJTkVEIiwiaGFzV2luZG93IiwiaGFzRG9jdW1lbnQiLCJkb2N1bWVudCIsImhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIndpbmRvdyIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJrZXlzIiwic29ydCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9ubGluZSIsImlzT25saW5lIiwiaGFzV2luIiwiaGFzRG9jIiwib25XaW5kb3dFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwib25Eb2N1bWVudEV2ZW50Iiwib2ZmV2luZG93RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmRG9jdW1lbnRFdmVudCIsImlzVmlzaWJsZSIsInZpc2liaWxpdHlTdGF0ZSIsImluaXRGb2N1cyIsImNhbGxiYWNrIiwiaW5pdFJlY29ubmVjdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwicHJlc2V0IiwiZGVmYXVsdENvbmZpZ09wdGlvbnMiLCJJU19TRVJWRVIiLCJyQUYiLCJzZXRUaW1lb3V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIm5hdmlnYXRvckNvbm5lY3Rpb24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2xvd0Nvbm5lY3Rpb24iLCJpbmNsdWRlcyIsImVmZmVjdGl2ZVR5cGUiLCJzYXZlRGF0YSIsInNlcmlhbGl6ZSIsImtleSIsImVyciIsImFyZ3MiLCJjb25jYXQiLCJpc0FycmF5IiwiaW5mb0tleSIsIlNXUkdsb2JhbFN0YXRlIiwiRk9DVVNfRVZFTlQiLCJSRUNPTk5FQ1RfRVZFTlQiLCJNVVRBVEVfRVZFTlQiLCJicm9hZGNhc3RTdGF0ZSIsImNhY2hlIiwiZGF0YSIsImVycm9yIiwiaXNWYWxpZGF0aW5nIiwicmV2YWxpZGF0ZSIsImJyb2FkY2FzdCIsIl9hIiwiRVZFTlRfUkVWQUxJREFUT1JTIiwiU1RBVEVfVVBEQVRFUlMiLCJGRVRDSCIsInJldmFsaWRhdG9ycyIsInVwZGF0ZXJzIiwiaSIsIl9fdGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wIiwiaW50ZXJuYWxNdXRhdGUiLCJfaSIsImFyZ3VtZW50cyIsIl9rZXkiLCJfZGF0YSIsIl9vcHRzIiwib3B0aW9ucyIsInBvcHVsYXRlQ2FjaGUiLCJyb2xsYmFja09uRXJyb3IiLCJjdXN0b21PcHRpbWlzdGljRGF0YSIsImtleUluZm8iLCJfYiIsIk1VVEFUSU9OIiwiYmVmb3JlTXV0YXRpb25UcyIsImhhc0N1c3RvbU9wdGltaXN0aWNEYXRhIiwicm9sbGJhY2tEYXRhIiwib3B0aW1pc3RpY0RhdGEiLCJyZXMiLCJfYyIsImNhdGNoIiwicmV2YWxpZGF0ZUFsbEtleXMiLCJpbml0Q2FjaGUiLCJwcm92aWRlciIsImhhcyIsIm9wdHMiLCJtdXRhdGUiLCJ1bm1vdW50IiwicmVsZWFzZUZvY3VzXzEiLCJyZWxlYXNlUmVjb25uZWN0XzEiLCJkZWxldGUiLCJvbkVycm9yUmV0cnkiLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsIk1hcCIsImRlZmF1bHRDb25maWciLCJvbkxvYWRpbmdTbG93Iiwib25TdWNjZXNzIiwib25FcnJvciIsIm9uRGlzY2FyZGVkIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZXZhbGlkYXRlSWZTdGFsZSIsInNob3VsZFJldHJ5T25FcnJvciIsImZvY3VzVGhyb3R0bGVJbnRlcnZhbCIsImRlZHVwaW5nSW50ZXJ2YWwiLCJsb2FkaW5nVGltZW91dCIsImNvbXBhcmUiLCJjdXJyZW50RGF0YSIsIm5ld0RhdGEiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidTEiLCJ1c2UiLCJmMSIsInUyIiwiZjIiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnJDEiLCJwcm9wcyIsImV4dGVuZGVkQ29uZmlnIiwiY2FjaGVDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VTdGF0ZVdpdGhEZXBzIiwic3RhdGUiLCJ1bm1vdW50ZWRSZWYiLCJyZXJlbmRlciIsInN0YXRlUmVmIiwic3RhdGVEZXBlbmRlbmNpZXNSZWYiLCJzZXRTdGF0ZSIsInBheWxvYWQiLCJzaG91bGRSZXJlbmRlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnQiLCJrIiwibm9ybWFsaXplIiwidXNlU1dSQ29uZmlnIiwid2l0aEFyZ3MiLCJob29rIiwidXNlU1dSQXJncyIsImZhbGxiYWNrQ29uZmlnIiwiZm4iLCJfY29uZmlnIiwiZmV0Y2hlciIsInN1YnNjcmliZUNhbGxiYWNrIiwiY2FsbGJhY2tzIiwia2V5ZWRSZXZhbGlkYXRvcnMiLCJpbmRleE9mIiwiV0lUSF9ERURVUEUiLCJkZWR1cGUiLCJ1c2VTV1JIYW5kbGVyIiwiZmFsbGJhY2tEYXRhIiwic3VzcGVuc2UiLCJyZXZhbGlkYXRlT25Nb3VudCIsInJlZnJlc2hJbnRlcnZhbCIsInJlZnJlc2hXaGVuSGlkZGVuIiwicmVmcmVzaFdoZW5PZmZsaW5lIiwiZm5BcmdzIiwiaW5pdGlhbE1vdW50ZWRSZWYiLCJrZXlSZWYiLCJmZXRjaGVyUmVmIiwiY29uZmlnUmVmIiwiZ2V0Q29uZmlnIiwiaXNBY3RpdmUiLCJwYXRjaEZldGNoSW5mbyIsImluZm8iLCJjYWNoZWQiLCJpc0luaXRpYWxNb3VudCIsInNob3VsZFJldmFsaWRhdGUiLCJyZXNvbHZlVmFsaWRhdGluZyIsInN0YXRlRGVwZW5kZW5jaWVzIiwicmV2YWxpZGF0ZU9wdHMiLCJjdXJyZW50RmV0Y2hlciIsInN0YXJ0QXQiLCJsb2FkaW5nIiwic2hvdWxkU3RhcnROZXdSZXF1ZXN0IiwiaXNDdXJyZW50S2V5TW91bnRlZCIsImNsZWFudXBTdGF0ZSIsIm5ld1N0YXRlIiwiZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlIiwibXV0YXRpb25JbmZvIiwiZXJyXzEiLCJyZXF1ZXN0SW5mbyIsImJvdW5kTXV0YXRlIiwia2V5Q2hhbmdlZCIsInNvZnRSZXZhbGlkYXRlIiwib25TdGF0ZVVwZGF0ZSIsInVwZGF0ZWREYXRhIiwidXBkYXRlZEVycm9yIiwidXBkYXRlZElzVmFsaWRhdGluZyIsIm5leHRGb2N1c1JldmFsaWRhdGVkQXQiLCJvblJldmFsaWRhdGUiLCJub3ciLCJ1bnN1YlVwZGF0ZSIsInVuc3ViRXZlbnRzIiwidGltZXIiLCJpbnRlcnZhbCIsImV4ZWN1dGUiLCJjbGVhclRpbWVvdXQiLCJTV1JDb25maWciLCJkZWZpbmVQcm9wZXJ0eSIsInVuc3RhYmxlX3NlcmlhbGl6ZSIsInVzZVNXUiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Ctinder%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Capp%5Cusers%5Cpage.js&modules=D%3A%5CInternShip%5Cbreeze-next-master%5Cbreeze-next-master%5Csrc%5Cstyles%5Cdashboard.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);